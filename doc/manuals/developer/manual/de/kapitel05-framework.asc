////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc User Guide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find an AsciiDoc Sheet Cheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 5 - Das Framework und die einzelnen Core-Komponenten

In diesem Kapitel werden die einzelnen Bestandteile des Clansuite Frameworks erläutert. Dabei ist jeder
Komponente des Systems ein eigener Abschnitt gewidmet. Du findest hier auch Definitionen und Erklärungen zu den
verwendeten Entwurfsmustern und zum allgemeinen Systemaufbau, insbesondere zur Model-View-Controller
Architektur (MVC) des Systems.

=== Das Clansuite CMS und das Clansuite Framework

Das Clansuite CMS basiert auf dem Clansuite Framework. Wir schreiben unser eigenes Framework, um den Aufwand
zu minimieren, ständig neuen Code für das CMS entwickeln zu müssen. Die Verwendung des Frameworks minimiert
die Anzahl der Codezeilen die geschrieben werden müssen, um bestimmte Ziele mit dem CMS zu erreichen. Viele
Methoden werden einfach zur "standardisierten" Verwendung bereitgestellt. Das Clansuite Framework dient also
dazu, die Standardaufgaben, die ein jedes CMS erledigen muss, vor die Klammern zu ziehen. Das CMS Clansuite
ist als nutzerfreundliche fertige Anwendung gedacht, die lediglich konfiguriert werden muss. Dabei werden
die einzelnen CMS Dienste werden durch Module bereitgestellt. Es ist für Erweiterungen und Plugins offen.
Das Framework vereinfacht also die Entwicklung und gibt auch dem CMS eine bestimmte Struktur und Festigkeit.

.Input-Transformation-Output (ITO) oder Eingabe-Verarbeitung-Ausgabe (EVA-Prinzip)
Die Hauptaufgabe einer Webapplikation liegt darin, einen gegebenen Input in einen Output zu transformieren.
Der gegebenen Input ist dabei regelmäßig eine URL. Der zu erzeugende Ouput ist regelmäßig der vom Webbrowser
zu interpretierende und darzustellende Quelltext, beispielsweise im Format XHTML.

.Das Input-Transformation-Output Prinzip
["graphviz", "chapter05_image01_ito.png", alt="Input-Transformation-Output"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Anfrage->Webanwendung->Ausgabe;
    Input->Transformation->Output;
}
---------------------------------------------------------------------

.MVC-Muster und die Schichten einer Applikation
Das Clansuite Framework ist dabei als ein einfaches und klassisches Model-View-Controller (auch MVC genannt)
Framework konzipiert. Unter dem Model-View-Controller Aufbau versteht man den Einsatz von bestimmten
Entwurfsmustern (Design Patterns), um eine Applikation in Schichten (auch Layers oder Tiers) zu trennen.
Dieses Muster wurde entwickelt, um die Entwicklung im Bereich der Präsentationsschicht zu verbessern.

Das Model repräsentiert die Datenschicht. Regelmäßig wird innerhalb des Models eine Datenquelle angesteuert
und ihre Daten zurückgeliefert. Die Datenquelle kann dabei eine Datenbank und ihre Tabellen oder eine XML-
oder gar Textdatei sein.

Der View repräsentiert die Präsentationsschicht. Die Aufgabe der Präsentationsschicht ist es, die Daten,
welche sie vom Model bzw. Controller angereicht bekommt, aufzubereiten und auf eine bestimmte Ausgabeart
darzustellen. Zumeist arbeitet die Präsentationsschicht dabei mit sogenannten Ansichten (Views) die aus
Vorlagen (Templates) bestehen. Das View Objekt lädt dann das vom Controller zugewiesene Template und gibt es
aus. Als Ausgabeart kommt z. B. die Einbettung der Daten in XHTML-Quellcode Vorlagen in Betracht. Aber auch
eine Ausgabe der Daten im Format PDF oder RSS ist Aufgabe der Präsentationsschicht.

Der Controller ist für die Annahme einer Anfrage an die Webapplikation und damit für die Geschäftslogik
zuständig. Er untersucht die eingehenden Daten, welche regelmäßig in Form einer URI vorliegen, daraufhin,
welche Ansicht der Präsentationschicht mit Daten bestückt werden muss. Dabei können Controller hierarchisch
verbunden sein. Es entscheidet der erste Controller, welcher nachfolgende Controller für die Ansicht und ihre
Daten zuständig ist. Der Einstiegspunkt in die Webapplikation ist dabei zumeist die zentrale Datei index.php.
Die Datei ruft regelmäßig den Frontcontroller, also den Einstiegscontroller der Applikation auf, der einen
Subcontroller, zumeist einen Modulecontroller oder direkt einen Actioncontroller aufruft. Der Modulecontroller
repräsentiert die Geschäftslogik für alle Kommandos eines Moduls, also ein ganzes Kommandopaket. Der
Actioncontroller repräsentiert die Geschäftslogik für ein einzelnes Kommando innerhalb einer Applikation. Der
Frameworkaufbau von Clansuite untergliedert sich demnach in Komponenten der Präsentationschicht
(Frontcontroller mit Interception-Filtern, Eventhandler, sowie Template-View und Viewhelper Muster), der
Datenschicht (Active- Record Muster und objektrelationales Mapping mittels Doctrine) und der Geschäftslogik.
Das besondere Kennzeichen der Schichtenarchitektur ist die Tatsache, dass das Model weder die Views noch den
Controller kennt. Die Schichtentrennung ist wünschenswert, um die Hauptaufgaben einer Applikation austauschbar
zu machen und getrennt voneinander bearbeiten zu können. Hinzu tritt die Tatsache, dass es sich beim MVC-
Muster um eine Konvention, genauer um ein Ordnungsverfahren handelt, um die Arbeit mit komplexen Anwendungen
zu erleichtern und beherrschbar zu machen. Bedenkt man, dass Softwaresysteme regelmäßig an geänderte
Anforderungen angepasst werden müssen, dann ist der Siegeszug des MVC-Musters nicht verwunderlich. Die
Applikationsschichten sind getrennt voneinander wartbar, veränderbar, ergänzbar und austauschbar. Insbesondere
können die Schichten gleichzeitig und unabhängig voneinander bearbeitet werden.
Dies sichert die benötigte Weiterentwickelbarkeit (Evolvability).

.Das Model-View-Controller Entwurfsmuster
["graphviz", "chapter05_image02_mvc.png", alt="Model-View-Controller"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Input->Controller;
    Controller->Model;
    Model->Controller;
    Controller->View;
    View->Controller;
    Controller->Output;

    Input [shape=Mdiamond]
    Output [shape=Msquare]
}
---------------------------------------------------------------------

.Die Hilfskomponenten
Beim Framework sind neben den Mustern zur Umsetzung des MVC-Patterns noch die jeweiligen Hilfskomponenten zu
nennen. Für jeden MVC Bereich gibt es eigene Hilfskomponenten. Die Hilfskomponenten im Bereich des Controllers
sind zumeist Wrapperklassen, die Zugriffsmethoden auf fremde Bibliotheken bereitstellen. Ein Beispiel hierfür
wäre die Klasse Clansuite_Mailer, welche den Zugriff auf die Bibliothek SwiftMailer ermöglicht. Das Versenden
von Mails ist eine wesentliche, sich wiederholende Aufgabe. Der Mailer ist dafür verantwortlich, die
notwendigen Methoden zum Versenden von E-Mails bereitzustellen. Nicht jedes CMS Modul sollte aber dies
Funktionalität neu implementieren müssen, wenn das Versenden von E-Mails benötigt wird, daher wurde die
Funktionalität (hier Controller-Logik) in die Hilfskomponente ausgelagert. Hilfskomponenten kommen dabei aber
nicht nur im Bereich der Controller-Logik, sondern auch im Bereich des Views vor. Hier nennt man sie
Viewhelper. Die Viewhelper enthalten, Sie ahnen es bereits, wiederholend einsetzbare Präsentations-Logik. Der
Viewhelper "date" wird Sie beispielsweise dabei unterstüzen, den Datumsstring in das richtige Datumsformat
umzuwandeln und anzuzeigen. Im Bereich des Models stehen Behaviors und Event-Callbacks über Doctrine zur
Verfügung. Mit Behaviors ist es möglich, zwischen zwei oder mehreren Modellen gemeinsame Funktionalitäten
bereitzustellen. Mit Event-Callbacks ist es möglich, sich an den Moment, genauer das Ereignis, der Datenablage
dranzuhängen und gleichzeitig bestimmte andere Dinge auszulösen. Beispielsweise könnte man an das Ereignis
afterDelete($userid) das Loggen der Löschung eines Usersaccounts anhängen.

.Die MVC-Struktur im Überblick
["graphviz", "chapter05_image03_mvcstructure.png", alt="Clansuite MVC Structure"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Input->FrontControllerResolver;

    subgraph cluster_0 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Doctrine DBAL/ORM"
        Model->ModelHelper->Model;
    }

    subgraph cluster_1 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Render Engines"
        View->Layouttemplate->Subtemplates->Layouttemplate;
        View->ViewHelper->View;
    }

    subgraph cluster_2 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Controllers"
        FrontControllerResolver->FrontController;
        FrontController->ModuleControllerResolver->ModuleController;
        ModuleController->Model->ModuleController;
        ModuleController->ComponentHelper->ModuleController;
    }

    ModuleController->View;
    ModuleController->Output;

    Input [shape=Mdiamond]
    Output [shape=Msquare]
}
---------------------------------------------------------------------

.Der Applikationsfluss im Überblick
Eine Anforderungen an die Applikation nach dem MVC-Modell kann in fünf grundlegende Schritte unterteilt werden:

1. Ausgangspunkt ist der Empfang einer URL vom Client.
2. Das Resolver- oder Routingsystem analysiert diese URL und identifiziert den Controllernamen. und sucht nun anhand des
   Controllernamens das richtige Controllerobjekt.
3. Aufrufen der richtigen Controllermethode auf dem richtigen Controllerobjekt.
4. Auswählen der richtigen Ansicht und Holen der Modelldaten, die von der Controllermethode
   zu dieser Ansicht generiert werden.
5. Das Rendern der Ansicht.


=== Architektur und Design des Frameworks

==== Dependency Injection und Inversion of Control

Für eine umfassende Beschreibung des Dependecy Injection Verfahrens verweise ich auf den Artikel von Martin Fowler
http://martinfowler.com/articles/injection.html.

===== Constructor Injection

===== Setter based Injection

=== Die Komponenten des Frameworks

==== Clansuite_HttpRequest

Die Klasse Clansuite_HttpRequest abstrahiert den Zugriff auf die Daten einer HTTP-Anfrage. Unter einer HTTP-
Anfrage versteht man den gesamten eingehenden Datenstrom (auch Input genannt) einer Anwendung. Bei einer HTTP-
Anfrage sind die Daten grundsätzlich über die superglobalen Variablen ($_REQUEST, $_POST, $_GET, $_COOKIE,
$_SERVER, $_FILES und $_ENV) zu erreichen. Diese Variablen werden allerdings von PHP unbereinigt und als
konkrete Implementierung bereitgestellt. Die Hauptaufgabe der Klasse Clansuite_HttpRequest besteht daher in
der Bereinigung der superglobalen Variablen $_REQUEST, $_POST, $_GET, $_COOKIE, $_SERVER, $_FILES, $_ENV und
dem Anbieten von Methoden zum Abruf der bereinigten Arrays. Die eingehenden Daten werden nicht direkt aus der
PHP- Umgebung, sondern über einen Umweg, nämlich aus dem HttpRequest Objekt geholt. Ein direkter Zugriff auf
die unbereinigten globalen Variablen (raw data) ist weiterhin möglich, sollte aber aus Sicherheitsgründen
vermieden werden. Eine weitere Aufgabe der Klasse besteht darin, die Effekte des "magic quoting" zu
beseitigen.

.Das Clansuite_HttpRequest Objekt
["graphviz", "chapter05_image04_httprequest.png", alt="Clansuite HttpRequest Object"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Input->struct1:webserver;
    struct1:php->struct2:httprequest->Controller;
    Controller->struct2:httprequest;

    struct1 [label="<webserver> Webserverumgebung  | {<php> PHP | { ENV | SERVER | GET | POST | REQUEST | COOKIE } }"];

    struct2 [label="<httprequest> HttpRequest | PHP Intrusion Detection System | { ENV | SERVER | GET | POST | REQUEST | COOKIE }"];

    Input [shape=Mdiamond]
}
---------------------------------------------------------------------

.Sicherheit mittels Clansuite_Doorkeeper
Des weiteren wird mittels der Klasse Clansuite_Doorkeeper (Türsteher) versucht Einbruchsversuche in die
Webanwendung zu erkennen und potentiellen Eindringlingen den Zugang zum System zu verweigern. Als System zur
Einbruchserkennugn wird das PHP Intrusion Detection System (PHPIDS) eingesetzt. PHPIDS wird seit Mai 2007 von
Mario Heiderich, Christan Matthies und Lars Strojny entwickelt. Es untersucht die Benutzereingaben auf
schadhafte Zeichen, Zeichenketten oder Skriptanteile. Erkannt werden XSS-Angriffe (Cross-Side-Scripting), SQL-
Injektionsversuche (SQLI), Remote File Inclusions, Remote File Executions (RFE) und LDAP-Injektionen.

.Bereitstellung der REST-Funktionalität
Eine weitere wesentliche Aufgabe ist die Bereitstellung der REST-Funktionalität. Die Abkürzung REST steht für
den Fachbegriff Representational State Transfer. REST ist ein Softwarearchitekturstil, welcher ein
resourcenorientiertes Denken forciert und für verteilte Applikationen entwickelt wurde. Es ist absichtlich
sehr einfach gehalten und basiert nur auf wenigen Grundprinzipien und wohldefinierten Methoden. Der Begriff
wurde durch die Dissertation von Roy Fielding aus dem Jahr 2000 eingeführt. Fielding ist einer der
Hauptautoren der Spezifikation des HTTP-Protokolls. Er ruft nochmals in Errinerung was die bestehende
Mechanismen und Protokolle des WWW (z. B. HTTP) teilweise schon definieren. REST ist neben den Alternativen
XML-RPC und SOAP eine Methode zur Umsetzung von Webservices und damit ein
Schlüsselwort des Web2.0.

.Rest-Grundprinzipien
Nachfolgend werden die Grundprinzipien von REST dargestellt.

1 Alles ist eine Resource::
    Eines dieser Prinzipien lautet "Alles ist eine Resource". Resource ist dabei jede Datenquelle.
    Einige werden hier eine Ähnlichkeit zum Linux-Prinzip "Alles ist eine Datei." feststellen.

2 Name (URI)::
    Jede Resource hat einen eindeutigen Namen.

3 Links::
    Jede Resource ist mittels eines Hyperlinks ansprechbar.

4 Verben (CRUD)::
    Die Methoden von REST sind einfache und selbstverständliche Verben.
    Für den Zugriff auf eine Ressource stehen die folgenden Methoden zur Verfügung:
    Create (POST), Read (GET), Update (PUT), Delete (DELETE).

5 Representation::
    Resourcen können mehrere Representationen haben.
    So kann die Ressource "Benutzerliste" sowohl in HTML, XHTML, CSV oder PDF repräsentiert werden.

6 Zustandslose Kommunikation (Skalierbarkeit)::
    Die Kommunikation mit dem Server einer Ressource beschränkt sich jeweils auf eine einzelne Anfrage. Der Server
    erwartet also keinen Kommunikationsvorgang bei dem Daten einer vorherigen Anfrage zwischengespeichert werden
    müssen. Letzteres würde dazu führen, dass mit steigender Anzahl an Anfragen die Serverlast steigt, da für
    jeden Client die Daten zwischen zwei oder mehreren Anfragen vorgehalten werden müssen. Berücksichtigt man nun
    die darunterliegenden zustandslosen Protokolle, wie HTTP und und fördert die Entdeckung und Verwendung der
    Resourcen. Führt dies dazu, dass wesentlich mehr Clients auf den Server zugreifen können, da die
    Serverresourcen geschont werden. Eine zustandslose Kommunikation erhöht also die Skalierbarkeit.

7 Schichtenaufbau::
    REST ist in Schichten aufgebaut. Dabei kann eine beliebige Anzahl an Zwischenebenen oder intelligenten
    Zwischendiensten, wie z. B. Caches, Proxies oder Gateways eingesetzt werden.

footnote:[Fielding, Roy Thomas: Architectural Styles and the Design of Network-based Software Architectures.
PhD Thesis, University of California, Irvine, 2000, http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm]
footnote:[Atom Publishing Protocol (RFC5023), http://www.ietf.org/rfc/rfc5023.txt]
footnote:[HTTP/1.1 Specifiction (RFC 2616), http://www.w3.org/Protocols/rfc2616/rfc2616.html]
footnote:[Yahoo! Group: rest-discuss, http://tech.groups.yahoo.com/group/rest-discuss/]
footnote:[http://restpatterns.org/]
footnote:[Alan Dean, http://www.simplewebservices.org/]
footnote:[Stefan Tilkov, http://rest-http.info/, Webseite zum Buch "REST und HTTP".]

.Instanzierung

Die Klasse wird bei Systeminitialisierung dem Dependency Injector übergeben und steht sodann in dessen
Registry zum Abruf bereit.

Das HttpRequest Objekt kann auf zwei Arten geholt werden. Erstens ist ein systemweiter Zugriff auf das Objekt
durch den Zugriff auf den Dependency Injector gegeben.

[source, php]
---------------------------------------------------------------------
# Holen des Objekts HttpRequest aus dem Dependecy Injector
$request = $this->injector->instantiate('Clansuite_HttpRequest');
---------------------------------------------------------------------

Zweitens kann in einer Klasse sind die sich vom Modulecontroller ableitet (das wird regelmäßig ein
ActionController sein) das Objekt mittels der Methode this->getHttpRequest() des ModuleControllers geholt
werden. Diese Methode ist eine Befehlsabkürzung (engl. auch Shortcut, Proxy oder Convenience Methode genannt).

[source, php]
---------------------------------------------------------------------
# Holen des Objekts HttpRequest innerhalb einer Kindklasse des ModuleControllers
$request = $this->getHttpRequest();
---------------------------------------------------------------------

.Verwendung

[source, php]
---------------------------------------------------------------------
# Holen des Objekts für einmalige Verwendung und holen des Parameters "stadt" (Method Chaining/Fluent Interface)
$stadt = $this->getHttpRequest()->getParameter('stadt');

# Holen des Objekts HttpRequest (für mehrmalige Verwendung)
$request = $this->getHttpRequest();

# Holen des Parameters 'news_category_form' aus dem Request Objekt.
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form');

# Holen des Parameters 'news_category_form' aus dem Request Objekt unter Angabe des Arraynames "REQUEST".
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form', 'REQUEST');

# Holen des Parameters 'news_category_form' aus dem Request Objekt unter Angabe des Shortcuts "R" für den Arraynamen.
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form', 'R');

# Holen des Parameters 'hausnummer' aus dem Request Objekt.
# Der Parameter wird mittels Shortcut "G" aus dem Array $get_parameters des Request Objekts geholt.
$haus_nr = $request->getParameter('hausnummer', 'G');

# Holen des Parameters ['news_form_categories]['cat_id'] unter Verwendung von ArrayAccess.
$cat_id = $request['news_form_categories]['cat_id];
---------------------------------------------------------------------

Hinweis: der Zugriff auf mehrdimensionale Arrays wird durch die Verwendung von ArrayAccess erheblich
vereinfacht. ArrayAccess bedeutet, dass ein Objekt und seine Eigenschaften auf die gleiche Art und Weise
angesprochen werden können, wie ein Array. So können auch Unterarrays und deren Schlüssel einfach angesprochen
werden.
Bei Übergabe von mehrdimensionalen Formulardaten empfiehlt sich die Verwendung von ArrayAccess besonders.

[source, php]
---------------------------------------------------------------------
# Das HTML-Formular beinhaltet ein Name Attribut mit mehrdimensionalem Aufbau.
# Dadurch werden die Daten als mehrdimensionales Array an den Server geschickt.
<input type="text" name="formular[1][variablename]" value="0"/><br />

# Das Array hat die folgende Struktur:
array( [formular] => array ( [1] => array( [variablenname] => 'wert' ) ) )

# Der Zugriff erfolgt über $request mittels ArrayAccess:
$variablenname = $request['formular']['1']['variablenname'];
---------------------------------------------------------------------

==== Clansuite_Doorkeeper

In unmittelbarem Zusammenhang mit den Sicherungs- und Bereinigungsfunktionen der HttpRequest-Klasse
steht die Klasse Clansuite_Doorkeeper.

.Instanzierung

Die Klasse wird innerhalb der HttpRequest-Klasse instanziert.

.Verwendung

Die Hauptmethode dieser Klasse ist runIDS(). Sie bewirkt die Initialisierung und den Start des Intrusion-
Detection-Systems (PHPIDS). Mehr über die Funktionsweise von PHPIDS erfahren sie im Kapitel 10.

==== Clansuite_HttpResponse

Die Klasse Clansuite_HttpResponse übernimmt die Funktion einer abstrakten Ausgabeklasse. Sie sendet die
notwendigen HTTP-Header, aktiviert die GZip-Kompression und gibt den gesamten Content ($body) an den Client
aus. Die Klasse ist für den Output zuständig.

.Instanzierung

.Verwendung

==== Clansuite_Frontcontroller

Was ist überhaupt ein Frontcontroller? Der Frontcontroller nimmt die Anfrage (Request) entgegen und
leitet sie an den entsprechenden Module-Controller bzw. Action-Controller weiter.
footnote:[http://www.martinfowler.com/eaaCatalog/frontController.html, Martin Fowler - FrontController im eaaCatalog]
footnote:[http://java.sun.com/blueprints/corej2eepatterns/Patterns/FrontController.html, J2EE Pattern FrontController]
Wenn eine Webanwendung nach dem FrontController Muster aufgebaut ist, dann erkennt man das meistens daran, dass
zum Starten der Anwendung die zentrale "index.php" aufgerufen wird. Diese "index.php" wird dann mit Parametern
ergänzt, die Modulecontroller und Actioncontroller angeben. Etwa "index.php?module=news&action=AlleNewsAnsehen".

Clansuite wird durch Aufruf der zentralen Einstiegsdatei "index.php" gestartet. Der Aufruf des
Frontcontrollers erfolgt nach der Initialisierung des Systems in der
Datei "/core/bootstrap/clansuite.application.php".

Die beiden Absätze in der Notiz haben wenig bis gar nichts mit dem Clansuite_Frontcontroller zu tun.
Sie sind vielmehr ein kleiner Exkurs in die Geschichte der Internetanwendungen und der Clanscripte.
Wer nicht daran interessiert ist, kann sie daher auch gerne überspringen.

.Exkurs
[NOTE]
===============================
Eine Alternative zur Verwendung eines Frontcontroller sind dezentrale Controller.
Dazu muss eine Anwendung in dezentrale Bereiche untergliedert werden, die jeweils eine eigene Einstiegsdatei
anbieten. In den Anfangstagen des persönlichen dynamischen Webs, so zwischen 1998 und 2004, waren dezentrale Controller
der Normalfall. In dieser Zeit hat man eine dynamische Webseite zumeist aus mehreren Skripten zusammengestellt.
So verwendete man ein Skript für die News und ein Skript für das Gästebuch.
Jedes dieser Skripte wurde in einem eigenen Verzeichnis untergebracht und über einen eigenen
Controller aufgerufen. Die URL sah typischerweise wie folgt aus: "/news/index.php" oder "/guestbook/index.php".
Häufig hat man dann versucht, die verschiedenen Skripte irgendwie miteinander zu verbinden, um sich beispielsweise
nicht bei jedem einzelnen Skript zur Administration anmelden zu müssen.

Im Clanbereich war das dezentrale Controller-Musters auch anzutreffen.
Ein damals bekanntes Clanscript mit dezentraler Controllerstruktur war das "TClanPortal"
von Martin Weitzel (aka TriggerTG). Es war auch bekannt unter dem Namen "TriggerTG's Clanportal"
und stand auf den Domains http://www.clanportal.org/ und http://www.triggertg.de/ zum kostenlosen Download bereit.
Das System war, obwohl es zahllose Sicherheitslücken gab, recht begehrt in der Szene und verbreitete sich rasch.
Die Entwicklung wurde im Jahr 2004 aus Zeitgründen eingestellt. Die letzten Version war 1.1.3.
Frank Hermann (aka Devil) nahm schließlich die Weiterentwicklung des Systems auf. Heute ist es besser bekannt
unter dem Namen "Devil's Clanportal", abgekürzt DZCP. Die dezentrale Controller-Struktur ist auch in der aktuellen
DZCP Version 1.5.1 im Jahr 2010 immernoch im Einsatz.
===============================

Inzwischen sind dezentrale Controller durch die Verwendung des Frontcontroller-Musters verdrängt worden.
Einzelne Skripte sind kaum noch anzutreffen und ihre Funktionalität wird heute zumeist durch die jeweiligen
Module einer Webanwendung repräsentiert.

.Ein einfacher Frontcontroller
["graphviz", "chapter05_image05_simplefrontcontroller.png", alt="Clansuite Simple Frontcontroller Workflow"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]
    HttpRequest->struct1:FC;
    struct1:pR->ModuleController->ActionController->HttpResponse;
    struct1 [label="<FC> FrontController | { <pR> processRequest }"]
}
---------------------------------------------------------------------

Was ist ein ModuleController bzw. ApplicationController?
Bei Clansuite nennen sich ApplicationController ModuleController.
Sie sind zuständig für einen kompletten Teilbereich des CMS.
Beispielsweise das Modul zur Verwaltung von Artikeln (News).
footnote:[http://www.martinfowler.com/eaaCatalog/applicationController.html]

Was ist ein ActionController?
ActionController ist ein Kommando der Applikation.
Beispielsweise das Kommando action_show() im Modul News.
Wird dieses Kommando ausgeführt, so bewirkt es die Anzeige aller gespeicherten Artikel des News-Moduls.

Clansuite setzt nicht nur einen einfachen FrontController ein.
Der FrontController, mit seiner Hauptmethode processRequest(), wird durch Vor- und Nachfilter erweitert.
Siehe dazu unter Clansuite_Filtermanager.

.Das Clansuite Frontcontroller Objekt
["graphviz", "chapter05_image05_startfrontcontroller.png", alt="Clansuite Frontcontroller Start"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    struct1 [label="<FC> FrontController | HttpRequest | HttpResponse | DependencyInjector | { { Prefilter | <preF> addPreFilters } | <pR> processRequest | { Postfilter | <postF> addPostFilters } }"]
}
---------------------------------------------------------------------

Dieses Bild zeigt das Frontcontroller Objekt nach dem Aufruf der Methode Clansuite_CMS::execute_Frontcontroller()
innerhalb von /bootstrap/clansuite.application.php.

Dem Frontcontroller werden der ModuleControllerResolver und der ActionControllerResolver,
sowie der Dependency Injector übergeben.
Die in einem Konfigurationsarray befindlichen Vor- und Nachfilter werden dem Frontcontroller
mittels der Methoden addPreFilter() und addPostFilter() hinzugefügt.
Durch Aufruf der Methode processRequest($request, $response) werden Request und Response Objekt
an den Frontcontroller übergeben. Die weitere Bearbeitung des Requests obliegt nun dem Frontcontroller.

.Der Ablauf im Frontcontroller - Clansuite_Frontcontroller::processRequest()
[source, txt]
---------------------------------------------------------------------
1. Den richtigen ModuleController ermitteln
   Dazu Clansuite_ControllerResolver befragen
2. Vorfilter abarbeiten
3. Dependency Injector an den ModuleController weitergeben
#. Hinzufügen eines ActionControllers mit dem ModuleDecorator
4. Aufruf des ModuleControllers
5. Aufruf des ActionControllers
6. Nachfilter abarbeiten
#7. fetches view / implicit getRenderEngine
#8. assign view to response / implicit getTemplate
9. Ausgabe
---------------------------------------------------------------------

Das Schema verdeutlich, wie die Methode processRequest() des Frontcontroller vorgeht.
Dabei geht es zunächst darum, aus dem eingehenden Request den richtigen ModuleController herauszufinden.
Dazu dient das ModuleControllerResolver Objekt.
Damit im ModuleController die Kernkomponenten zur Verfügung stehen, wird der
DI an den Modulecontroller weitergegeben (3).

Danach geht um den Aufruf des ModuleControllers (4) und des ActionControllers (5).
Der ActionController wird wiederrum mittels des ActionControllerResolvers ermittelt.

Dieser wird umlagert von der Ausführung der Vor- und Nachfilter.
Die Abarbeitung der Vorfilter (2) bewirkt möglicherweise eine Modifikation des Request Objekts.
Die Abarbeitung der Nachfilter (6) bewirkt möglicherweise eine Modifikation der Ausgabe
bevor sie ins Response Objekt gegeben wird.

Der ActionController bestimmt die Ausgabeengine und übergibt die Daten die ausgegeben werden sollen.
Um die Ausgabe zu bewirken (9), ruft der Frontcontroller die Methode flush() des HttpResponse Objekts auf.

==== Clansuite_Filtermanager

Der Filtermanager ist eng mit dem Frontcontroller verwoben. Jedem Aufruf der Hauptmethode processRequest() des
Frontcontrollers können ein oder mehrere Vorfilter vorgeschaltet oder ein oder mehrere Nachfilter
nachgeschaltet werden. Um diese Funktionalität im Frontcontroller abzubilden wurden die zwei Variablen
$preFilters und $postFilters erstellt, welche jeweils eine Instanz des Filtermanager Objekts enthalten. Der
Filtermanager stellt nur sehr wenige Methoden bereit. Hauptsächlich geht es darum Filter zu registrieren und
auszuführen. Zum einen stellt er die Methode addFilter() bereit. Mit ihr lassen sich neue Filter hinzuzufügen.
Sie akzeptiert Objekte, welche das Filter Interface implementieren, und somit vom Typ Filter sind. Die
Hauptmethode des Filtermanagers ist processFilters(). Sie iteriert über alle registrierten Filter und führt
sie aus. Die Iteration folgt dabei der Reihenfolge der Registrierung.

.Entwurfsmuster

*Frontcontroller*
Die Klasse Clansuite_Filtermanager ergänzt den Frontcontroller.
Der Frontcontroller kann eine Anfrage nur an den ModuleController und weitere Untercontroller weiterreichen,
um sie zu beantworten. Neue Funktionen könnten nur durch Änderung eines bestehenden oder hinzufügen eines
neuen Controllers geschaffen werden.

*Interception-Filters*
Das Entwurfsmuster Intercepting-Filter hilft weiter.
footnote:[http://java.sun.com/blueprints/corej2eepatterns/Patterns/InterceptingFilter.html]
Damit lässt sich die Hauptmethode processRequest() mit einem
Vorprozess und einem Nachprozess umhüllen. Ein Vorprozess ist in der Lage die Anfrage zu verändern.
Ein Nachprozess ist in der Lage die Ausgabe zu beeinflussen. Dadurch können beliebig viele Filter
hinzugefügt oder wieder entfernt werden, ohne den Code des Frontcontrollers ändern zu müssen.

Beim Intercepting-Filter-Musters implementiert jeder Filter das Filterinterface.
Die Filter sind wiederverwendbar, sequenziell aufrufbar und lose an die Geschäftslogik und andere Filter gekoppelt.
In der Java-Welt gibt es seit Version 2.3 der Servlet Spezifikation, ein Standardinterface Filter
footnote:[http://java.sun.com/products/servlet/Filters.html].
Eine Intercepting-Filter-Implementation als Teil der PHP-SPL sucht man leider vergeblich.

.Der mit Interception-Filtern erweiterte Frontcontroller
["graphviz", "chapter05_image06_frontcontrollerwithfilters.png", alt="Clansuite Frontcontroller with Interception Filters"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    HttpRequest->struct1:FC;
    struct1:pR->HttpResponse;

    subgraph cluster_0
    {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        struct1 [label="<FC> FrontController | { <preF> Vorfilter | <pR> processRequest | <postF> Nachfilter }"]
   }
}
---------------------------------------------------------------------

===== Das Filter Interface

Jeder Filter implementiert das Filter Interface (implements Clansuite_Filter_Interface).
Damit wird sichergestellt, dass der konkrete Filter alle Methoden eines abstrakten Filters bereitstellt.
Dazu gehört inbesondere das Vorhandensein der Hauptmethode executeFilter().

===== Übersicht zu den Filtern

.Vorfilter

1. Theme_via_get
2. Language_via_get
3. Statistic
4. Startup_checks
5. Set_modulelanguage
6. Maintenance
7. Ajax Request
8. Get User
9. Permissions
10. Php_debug_console
11. Session security
12. Process cronjobs

.Nachfilter

1. Html Tidy
2. Smarty Moves

TIP: Die Erstellung eines Filters um den Output zu komprimieren ist nicht erforderlich. Diese Aufgabe wird durch die Klasse Http_Response gehandhabt.

==== Clansuite_Configuration

.Instanzierung

.Verwendung

.Entwurfsmuster

===== Die Configuration-Adapter

====== Configuration: YAML

.Allgemeines zum YAML-Format

Das YAML Konfigurationsformat ist relativ minimalistisch und basiert auf Textdateien.
Die offiziellen Webseite definiert YAML (YAML Ain't Markup Language), als einen menschenlesbaren,
programiersprachenübergreifenden Standard zur Datenserialisierung.
Es wurde entwickelt, um die Lesbarkeitsschwierigkeiten aufgrund von Klammerung und Verschachtelung
bei PHP-Arrays und anderen Ausdrucksmitteln für Konfiguration zu umgehen.
Ziel war eine Konfigurationsprache zu schreiben, die auch für Nicht-Programmierer lesbar und einfach einzusetzen ist.
Die offizielle Webseite ist http://yaml.org/.
Die Spezifikation von YAML Aint Markup Language vor finden sie unter http://www.yaml.org/spec/1.2/spec.html.
Seit dem 1.Oktober 2009 liegt nunmehr die Version 1.2 der Spec vor.

Beim YAML-Format wird durch Einrückungen des Text eine Struktur erzeugt.
Um eine Textdatei des YAML-Formats zu lesen und die in ihr enthaltenen Zeichenketten wieder
in eine Arraystruktur mit Schlüsseln und Werten zu verwandeln ist ein Parser notwendig.
Der YAML-Parser wertet dabei insbesondere die zur Strukturierung des Konfigurationstextes dienenden Leerzeichen aus.

.Vergleich der Konfiguration mittels PHP-Array und YAML
[source, php]
---------------------------------------------------------------------
# definition als php-array
$configuration = array(
    'konfigurationssektion' => array(
                                     'element1' => 'wert1',
                                     'element2' => 'wert2',
                                     'element3' => 'wert3'
                                    )
                      );

# definition als yaml

konfigurationssektion:
  element1: wert1
  element2: wert2
  element3: wert3
---------------------------------------------------------------------

Das YAML-Format wurde in der PHP-Welt insbesondere mit Aufkommen des PHP-Frameworks Symfony sehr populär, wo es standardmäßig eingesetzt wird.
Der dort entstandene Parser implementiert einen Großteil der YAML 1.1 Spezifikation und wird als eigenständige
Bibliothek sfYaml weiterentwickelt. Fabien Potencier der Symfony-Gründer wird nicht müde, diese Klasse und das Format zu bewerben.

Ein Serialisierungsformat das auf YAML beruht ist JSON.

TIP: Wer YAML sagt, meint auch oft das von Dirk Jesse entwickelte (X)HTML/CSS Framework mit dem Namen "Yet Another Multicolumn Layout".
Es ist ein sehr komfortables Layoutgerüst unter CC-A 2.0 Lizenz. Sie finden das YAM-Layoutprojekt unter http://www.yaml.de/ und
weitere Projekte des Autors unter http://www.highresolution.info/webdev/.

.Arbeitsweise des Konfigurationsadapters YAML

Der Konfigurationsadapter YAML erweitert die Basisklasse Clansuite_Config_Base und implementiert das ArrayAccess Interface.
Die beiden Hauptmethoden sind readConfig() und writeConfig(). Nach erfolgreichem readConfig() kann ein Zugriff per ArrayAccess erfolgen.
Es ist ein Wrapper der zwei Parser-Bibliotheken umspannt. Primär untersützt der Wrapper die in C-geschriebene PHP-Extension SYCK.
Diese ist über PECL verfügbar. Sollte diese PHP-Extension nicht verfügbar sein, so wird sekundär, auf die PHP-Bibliothek SPYC zurückgegriffen.
SPYC muss dazu in das Verzeichnis /libraries/spyc/ installiert werden.

====== Configuration: DB

====== Configuration: INI

====== Configuration: XML

==== Clansuite_Renderer

Für die Präsentationsschicht ist die Klasse Clansuite_Renderer zuständig. Diese ist Bestandteil des Applikationskerns.

Jeder Rückgabewert des Systems ist ein Output und wird über die Response-Klasse abgewickelt.
Nur Fehlerausgaben werden nicht über die Response-Klasse, sondern direkt ausgegeben.
Die Contentzuweisung an die Response-Klasse wird durch eine Methode zur Ausgabevorbereitung veranlasst.
Diese setzt regelmäßig eine bestimmte RenderEngine ein, um den Output aufzubereiten.
RenderEngines umfassen dabei Ausgabeformate und TemplateEngines.
Hinzu kommt die direkte Ausgabe mit PHP und über den HTTP-Header.

Folgende Ausgabeformate werden zur Zeit von Clansuite unterstützt:
CVS, JSON, PDF, Serialized.

Folgende Template-Engines werden unterstützt:
PHPTAL, Smarty, XSLT, Xtemplate.
Die standardmäßige Template-Engine ist Smarty.

Es ist möglich die PHP Renderer Klasse zu verwenden, um ohne eine TemplateEngine zu arbeiten.
Desweiteren ist es möglich Einfluß auf den HTTP-Header zu nehmen, um Daten zu senden.
Dies wird beispielseweise beim Logger Firebug so gemacht.

.Ausgabemöglichkeiten
["graphviz", "chapter05_image20_renderertypes.png", alt="Ausgabetypen"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    RenderEngines->TemplateEngines;
        TemplateEngines->Smarty;
        TemplateEngines->PHPTal;
        TemplateEngines->XTemplate;
        TemplateEngines->XSLT;
    RenderEngines->Direktausgabe;
        Direktausgabe->Header;
        Direktausgabe->PHP;
    RenderEngines->Ausgabeformate;
        Ausgabeformate->CVS;
        Ausgabeformate->JSON;
        Ausgabeformate->PDF;
        Ausgabeformate->Serialized;
}
---------------------------------------------------------------------

.Instanzierung

.Verwendung

.Entwurfsmuster

Das zugrundeliegende Entwurfsmuser für das Ausgabeverhalten von Clansuite nennt sich Two-Step-View.
Dabei werden zuerst Inhalte gerendert und diese danach in das Layout eingesetzt.
Dieses zweischrittige Verfahren ermöglicht, dass zusätzliche Elemente wie JavaScript und 
CSS in das Layout in Abhängigkeit vom Inhalt eingebunden werden können.

Die einzelnen RenderEngines werden über eine Fabrikmethode aufgerufen.
Eine Schnittstelle sichert, dass die Klassen im Kern die gleichen Methoden bereitstellen.

===== Die RenderEngine Adapter

====== Renderer: CVS

Der Renderer CVS nimmt Daten auf und gibt sie in der Form als komma-getrennte Werte zurück.
CVS steht für die Abkürzung für Comma-Separated Values und ist ein Dateiformat (.csv).
Es wird in der Spezifikation RFC 4180 footnote:[http://tools.ietf.org/html/rfc4180] näher beschrieben,
aber ein Standard exisitert nicht. Gerade dies macht das Wiedereinlesen einer CVS-Datenstruktur
relativ schwer, da jeder auf seine Weise strukturieren kann.

====== Renderer: JSON

Der Renderer JSON nimmt Daten auf und gibt sie serialisiert im Format JSON zurück. Die Serialisierung
erfolgt mittels der PHP Extension JSON, die nunmehr seit PHP-Version 5.2.1 standardmäßig vorhanden ist.

.Allgemeines zu JSON (JavaScript Object Notation)
JSON steht für JavaScript Object Notation und ist ein Datenaustauschformat.
Es ist eine Untergruppe des YAML-Formats und beschrieben in RFC 4627
footnote:[http://www.ietf.org/rfc/rfc4627.txt?number=4627].
Populär wurde es durch die Verbindung und Nutzung mit Ajax. Zwar kommt auch XML als ein Tauschmittel für
Ajax in Betracht, doch sind XML-Baumstrukturen nur schwer lesbar und größer.
JSON kann eine Vielzahl von Datenstrukturelementen aufnehmen und abbilden.
Das entstehende Objekt eignet sich zum Transport und die enthaltenen Daten können einfach addressiert werden.

TIP: Ein oft gemachter Fehler ist, JSON mit einem JavaScript Array gleichzusetzen. Der feine Unterschied
besteht darin, dass JSON eine Objekt-Notation ist, die wie ein Array addressiert werden kann.

Es gibt in der PHP-Welt zahlreiche Klassen um JSON zu parsen.
Aber ist nicht verwunderlich ist, dass der PHP eigene Parser schneller ist, als alle in PHP geschriebenen Parser.
Schließlich ist er in C implementiert. Ein Vergleich zahlreicher Parser-Klassen bestätigt diesen Fakt.
footnote:[http://gggeek.altervista.org/sw/article_20061113.html]
footnote:[http://gggeek.altervista.org/sw/article_20070425.html]

====== Renderer: PDF

====== Renderer: PHP

Die Meinungen über natives PHP Rendering sind vielfältig. 
Für einige ist die direkte Ausgabe mit PHP der heilige Gral der PHP-Welt, den es zu behüten gilt.
Andere sehen die Sache weniger glaubensverklärt und konstatieren, dass man es wohl auf "die alte Art" 
oder aber auf "die Neue" machen könne. Wieder andere sind aufgeklärt und vertreten ein vollständiges 
Trennungsprinzip und betrachten "die alte Art" als altmodisch.

PHP wurde einst als Templateskriptsprache entwickelt, um statische Seiten mit dynamischen Elementen anzureichern.
Und eine Reihe anderer Sprachen, wie ColdFusion, ASP und JSP sind zeitgleich entstanden und verwenden das gleiche Prinzip.
Wenn man so will, dann war die Templateengine PHP der Versuch, die Lücke zwischen C und HTML zu verkleinern.
Doch im Laufe der Zeit wurde PHP um immer mehr Sprachmerkmale und Funktionen erweitert. 
Je mehr Sprachfeatures und Funktionen eine Skript- bzw. Programmiersprache bereitstellt, desto mächtiger ist sie.
Fraglich ist, ob man diese Macht auf Templateseite haben möchte.

Wer von Templateseite spricht, hat das Trennungsprinzip zwischen Programmseite (PHP) und Templateseite (HTML) im Hinterkopf.
Wer dieses Prinzip nicht kennt oder kennt und ablehnt, vertritt die Ansicht, dass HTML und PHP stets vermischt werden 
sollten, um die Ausgabe zu erzeugen. Dies ist die ursprüngliche, alte Art und Weise mit PHP zu entwickeln.
Wer das Trennungsprinzip von HTML und PHP verinnerlicht hat, der mag beim Anblick einer Vermischung von HTML und PHP
erhebliche Qualen empfinden. Bei Manchen gilt letzteres als eine spezielle Form des Spagetticodes mit Webgeschmack.

Wer von Templateseite spricht, kann aber auch das Trennungsprinzip zwischen Geschäftslogik (business logic) und
Präsentationslogik (presentation logic) meinen. Diese Trennung bedeutet nicht unbedingt die Trennung von PHP und HTML.
Denn Präsentationslogik ist alles, was nicht Geschäftslogik ist. Für das Trennungsprinzip zwischen Geschäfts- und
Präsentationslogik sprechen die Arbeitsteilung zwischen Programmierer und Webdesigner, sowie die Wiederverwendbarkeit,
Kapselung, Klarheit und Bearbeitbarkeit mit einem HTML-WYSIWYG Werkzeug. Der Quellcode wird zudem besser wartbar,
leichter austauschbar und kann parallel bearbeitet werden.

Eine Template Engine sollte die Trennung von Geschäftslogik und Präsentationslogik untersützen.
Was bedeutet dabei eigentlich unterstützen (encourage)? Unterstützen bedeutet, dass zu jeder Zeit die Möglichkeit
besteht, die Trennung zu beachten und mehr PHP Funktionen zum Einsatz zu bringen. Doch warum sollte man eine
Template Engine  einsetzen? Weil Template Engines den Bereich der Präsentationslogik von Haus aus und ohne zutun abdecken.
Es sind fertige, einsatzbereite und erweiterbare Präsentationsframeworks.

Gegen die Verwendung von Templateengines gibt es zahlreiche Argumente. Oft wird entgegengehalten, dass man alles,
was man mit einer Templatesprache machen könne, auch mit PHP selbst machen kann. Und zwar viel besser, weil man
mehr Funktionen zur Verfügung hat. Eine Templatesprache, wie z.B. Smarty, ersetzt die PHP-Kommandos lediglich durch
andere, nämlich Smarty-Befehle. Diese Templatesyntax zu lernen sei lästig und zeitraubend. 
Oft gehört ist daher auch das faktisch richtige Argument, dass eine Templatesprache doch eigentlich nur unnötigen Overhead erzeugt.
Trefflich streiten, lässt sich allein über die Frage, ob dieser Overhead nötig ist.

Eine Templateengine schränkt den zur Verfügung stehenden Befehlssatz ein.
Für einen Webdesigner ist sie daher immer einfacher einzusetzen als natives PHP.
Das wichtigste Argument für eine Templateengine ist daher:
Sicherheit durch einen eingeschränkten Befehlssatz.

Ich vertrete die Auffassung, dass PHP von Haus aus einen Template-Modus mitbringen sollte.
Der Template-Modus könnte beispielsweise durch die Verwendung des Tokens <?phpt aktiviert werden.
Hierdurch würde ein deutlich reduzierter, sicherer Befehlssatz für den Einsatz in Templates verfügbar.
Den entsprechenden Befehlssatz könnte man in der php.ini durch Whitelisting festlegen.

Dieses Verfahren hat einige Vorteile. Erstens wäre dieser Ansatz in C-implementiert und daher sehr schnell.
Zweitens ist dies ohne großen Aufwand zu erreichen, denn es werden lediglich bereits vorhandene Konfigurationskommandos
eingesetzt, um den Befehlssatz einzuschränken. Drittens könnte dadurch eine bessere Standardisierung von PHP-Templates erreicht werden,
als durch ständige Rewrites bekannter Engines oder überflüssige Neuerfindungen des Rades (zuletzt beispielhaft dafür Symfonys Twig).

[source, php]
---------------------------------------------------------------
<?phpt
 /**
  * PHP im Template Modus mit eingeschränktem Befehlssatz
  */
?>
---------------------------------------------------------------

Nebenbei: Diese Diskussionslinie existiert zwischen nativem PHP Rendering und Templateengines,
als auch zwischen Templateengines und XSLT Rendering.

====== Renderer: PHPTAL

PHPTAL ist eine kompilierende und cachende Templateengine. Die Abkürzung PHPTAL steht für "PHP 
Template Attribute Language". Es ist eine PHP-Portierung der Templatesprache des Zope-Servers 
(Zope Page Templates, ZPT) footnote:[http://zope3.mpg.de/cgi-bin/twiki/view/Zope/PageTemplate]
footnote:[http://docs.zope.org/zope2/zope2book/AppendixC.html]. 
Im Vordergrund steht dabei die Generierung von XML und XHTML.

Die TAL-Syntax wird in der Template Attribute Language Expression Syntax (TALES) beschrieben
footnote:[http://wiki.zope.org/ZPT/TALESSpecification13].
Die Besonderheit von TAL liegt in der Verschiebung von Viewhelper-Actions in XHTML Attribute
footnote:[http://zope3.mpg.de/cgi-bin/twiki/view/Zope/TaLes]. 
Bei anderen Templatesprachen verwendet man hingegen immer Tags oder Elemente.
Es ist theoretisch möglich eine andere Syntax als TAL zu verwenden, denn die als Attributwerte verwendbaren Ausdrücke
werden durch METAL (Macro Expansion Template Attribute Language) beschrieben. In der Praxis erweitert man TALES einfach.
 
Der Quellcode von PHPTAL wird stetig verbessert und ist unter der GNU/LGPL lizensiert.

Webseite: http://phptal.org
Handbuch: http://phptal.org/manuals.html
Wiki: http://phptal.org/wiki/doku.php

====== Renderer: Serialized

====== Renderer: Smarty

====== Renderer: XSLT

XSLT steht für XSL Transformations und ist in der gleichnamigen W3C Recommendation vom 16 November 1999 
footnote:[http://www.w3.org/TR/xslt] beschrieben. XSLT beschreibt die Semantik zur Transformation 
von XML Dokumenten in andere XML Dokumente. PHP stellt die Transformationsfunktionalität 
in der Erweiterung XSL bereit. Eine PHP-Bibliothek zur Transformation ist daher nicht erforderlich.
Der Clansuite_Renerer XSLT stützt sich auf diese PHP XSL Erweiterung.

Sie bietet die Möglichkeit PHPFunktionen im XSLTemplate aufzurufen.
Die PHP-Funktionen lassen sich mit der Methode registerPHPFunctions() festlegen.
Somit können eigene Viewhelper auch nachträglich problemlos hinzugefügt werden.
Wer mit Smarty entwickelt hat, der wird dieses Verfahren wiedererkennen.
Es entspricht der Registrierung von Smarty-Plugins.

Das der XSL Transformation zugrundeliegende Entwurfsmuster nennt sich daher auch Transform View.
Der Unterschied zwischen Template View und Transform View besteht darin, dass ein Template View 
direkt mit den Elementen des Outputs arbeitet, während der Transform View indirekt, nämlich mit
den zu transformierenden Elementen arbeitet und diese erst noch in direkten Output umwandeln muss.

Zuerst wird ein DomDocument erstellt, wobei die Formatierungsdaten aus einer XSL-Datei kommen. 
Dann wird das DomDocument mit einer XML-Datei zusammengeführt und zur Ausgabe transformiert.
Letzteres erfolgt mittels der Methode transformToXML().

Durch Verwendung von PHP in XSLT erhöht sich die Flexibilität im View.
Gleichzeitig bietet dieses Verfahren Sicherheit, da nur bestimmte, vorher 
registrierte PHP-Funktionen zur Verfügung stehen.

====== Renderer: Xtemplate

==== Clansuite_Cache

Die Klasse Clansuite_Cache ermöglicht den Zugriff auf die verschiedenen Cache-Adapter.

.Was macht ein OpCode-Cache?
Normalerweise wird bei jedem Aufruf eines Skriptes zuerst das Skript kompiliert (es wird aus der Skriptsprache 
in Maschinencode überführt) und dann ausgeführt. Das kostet Zeit und verbraucht wertvolle Rechenleistung. 
Verwendet man hingegen einen OpCode Cache, so wird ein Skript zuerst kompiliert und danach kompiliert im 
Speicher (shared memory / RAM) gehalten. Jeder weitere Aufruf des Skripts wird danach aus dem Speicher
bedient und spart Kompilierungszeit.

Der optimale Wert für die Größe des Cache-Speichers hängt natürlich vom tatsächlich verfügbaren RAM ab.
Wer zu hohe Cachewerte einstellt, zwingt den Server möglicherweise dazu, andere Sachen auszulagern.

.Instanzierung

.Verwendung

.Entwurfsmuster

===== Die Cache-Adapter

====== Cache: APC

====== Cache: eAccelerator

====== Cache: File

====== Cache: Memcached

Der Cache-Server Memcache wurde von der Firma Danga Interactive für den Multiblog-Hoster LiveJournal entwickelt.
http://memcached.org/

====== Cache: xcache

XCache wurde als OpCode Cache für den Webserver "lighttpd" (lighty) entwickelt.
Eine Featureliste findet sich unter http://xcache.lighttpd.net/wiki/FeatureList.
http://xcache.lighttpd.net/

==== Clansuite_Cronjobs

===== Allgemeines

Die Klasse Clansuite_Cronjobs (auch Pseudocron genannt) ermöglicht eine intervallgebundene Ausführung von
selbst bestimmbaren Kommandos. Beispielsweise kann man wöchentlich die Datenbank sichern, stündlich Feeds
aktualisieren oder täglich den Template-Cache leeren oder die Sitemap neu generieren lassen. Dabei kann jedes
PHP-Skript ausgeführt werden, wobei das Ausführungsintervall periodisch, also wiederkehrend oder zeitgesteuert
sein kann. Die ausgeführten Cronjobs werden in einem Log gespeichert. Aus einem Cronjob können Nachrichten ins
Log gespeichert werden. Unter Crontab versteht man die Cron-Tabelle. Sie enthält die Zeitangaben und die
auszuführenden Kommandos. Die Notation eines Cronjob in der Crontab erfolgt im Unix Cron Syntax.

Ein zulässiger Crontabeintrag könnte wiefolgt aussehen:

[source, txt]
---------------------------------------------------------------------
2   1,15    *   *   beispiel.cronjob.php
---------------------------------------------------------------------
Dieser Eintrag hätte zur Folge, das "beispiel.cronjob.php" um 2 Uhr am ersten und fünfzehnten jedes
Monats ausgeführt werden.

.PHP5-Portierung von pseudo-cron v1.3
Clansuite_Cronjobs ist ein Fork, genauer eine PHP5-Portierung, der
bekannten PHP-Klasse pseudo-cron von Kai Blankenhorn (http://www.bitfolge.de/pseudocron). Die letzte Version,
pseudo-cron v1.3, wurde am 15.06.2004 veröffentlicht. Die Veröffentlichung der PHP5 Portierung erfolgte am
10.05.2008 als Minor-Release mit der Versionsnummer v1.4. Dabei wurden die globalen Variablen entfernt, sowie
Handler für datei- sowie datenbankbasiertes Crontab-Scheduling hinzugefügt.

===== Möglichkeiten des Cronjob Triggerings

Es gibt mehrere Möglichkeiten Cronjobs zu triggern.

.Die Vorfilter Methode
Beispielsweise kann eine Kontrolle auf anstehende Cronjobs als ein Vorfilter des Systems angelegt werden.

.Die Image-Tag Methode
Der Cronjob kann auch über den HTML Tag <img> ausgelöst werden. Beide Möglichkeiten hätten zur Folge, dass
jeder Webseitenbesuch auch eine Prüfung des Crontabs auf anstehende Aufgaben auslöst.

.Die Kopplung an den "echten" Cronjob des Betriebssystems
Im Gegensatz zum normalen, betriebssystemgesteuerten Cronjob ist mit Clansuite_Cronjob jedoch keine exakte
zeitliche Ausführung der Kommandos möglich, da das Cronjobsystem immer an Ereignisse der Webanwendung geknüpft
ist. Finden keine Ereignisse statt, werden die Cronjobs auch nicht ausgeführt. Wenn Sie beispielsweise einen
stündlichen Cronjob registriert haben, der aktuelle News einholt und sie in ihrer Newsdatenbank speichert,
jedoch im Zeitraum von 23Uhr bis 7Uhr keinen Besucher auf ihrer Webseite, dann wird der Cronjob erst wieder
durch den Besucher nach um 7Uhr getriggert. Ihnen entgeht dabei die Newsaktualisierung zwischen 23Uhr und
7Uhr. Um sich einer exakten zeitlichen Ausführung anzunähern, kann man die Ausführung der Clansuite_Cronjobs
an die Cronjobs des Betriebssystem koppeln. Dazu fügt man einfach den Aufruf der Clansuite_Cronjob in die
Crontab des Betriebssystems ein (crontab -e).

[source, txt]
---------------------------------------------------------------------
* * * * * php /srv/www/clansuite/cronjobs.php
---------------------------------------------------------------------

.Instanzierung

.Verwendung

Innerhalb eines Cronjobs kann mittels der Methode logMessage("Ihre Nachricht"); eine Nachricht in das Cronjob-
Logbuch geschrieben werden.

===== Übersicht zu Crontab und Cronjobs

.Die Crontab Datei

Das Format der Crontab-Datei entspricht in Aufbau und Syntax dem von Linux bekannten Cronjob-Format.

==== Clansuite_Eventhandler

Die Klasse Clansuite-Eventhandler stellt Methoden bereit, um einen ereignisbasierten Programmablauf zu ermöglichen.
Um dies umzusetzen, werden an bestimmten Stellen im Ablauf der Applikation Ereignisse definiert.
Auf den Eintritt dieser Ereignisse wartet ein Beobachter. Dem Beobachter wird ebenfalls eine Liste mit Unterprogrammen
vorgelegt, die ausgeführten werden sollen, wenn bestimmte Ereignisse eintreten.
Stellt der Beobachter den Eintritt eines Ereignisses fest, löst er alle für dieses Ereignis angemeldeten Unterprogramme aus.

Den Beobachter nennt man auch Observer oder EventListener. Den Teil des Beobachters, der das Unterprogramm ausführt,
nennt man EventHandler (so auch der Klassenname). Nicht verwunderlich ist der Name des zugrunde liegenden Entwurfsmusters.
Es ist das Subject-Observer Muster. Manchmal wird es auch nur Signal-Slot genannt.

Durch den Einsatz ereignisbasierter Programmierung ist es möglich, die Applikation dynamisch zu erweitern ohne am
Quelltext etwas zu ändern. Man fügt lediglich eine Datei mit dem neuen Unterprogramm ein und registriert es für das
gewünschte Ereignis beim Beobachter.
Um nun eine ganze Reihe von Unterprogrammen einzubinden, kann man auf die magische PHP-Methode __autoload() zurückgreifen.
Clansuite verwendet diesen Mechanismus und lädt ereignisbasierte Unterprogramme aus einem dafür eingerichteten Verzeichnis
(/core/events/) und registriert sie automatisch. Das Verfahren fördert die Losekopplung. Gleichzeitig werden die
Hauptcontroller etwas verkleinert, indem Quellcodeanteile in die Unterprogramme ausgelagert werden.
Der Nachteil besteht allerdings darin, dass die Komplexität durch diese Dezentralisierung wieder ansteigt.
Leicht kann der Überblick über verfügbare Ereignisse und registrierbare Unterprogramme verloren gehen.

.Intanzierung

Es erfolgt eine automatische Instanzierung beim Systemstart. Der Eventdispatcher wird bei der Initialisierung des Systems automatisch instanziert bzw. gestartet, wenn in der Konfigurationsdatei (/confuguration/clansuite.config.php)
in der Sektion "eventsystem" der Wert "eventsystem_enabled" auf "true" oder "1" gesetzt ist.
Das gesamte Eventsystem kann also in der Konfiguration ein- und ausgeschaltet werden.
Danach ist das Eventhandler Objekt systemweit über den Dependency Injector verfügbar.

.Einschalten des Eventsystems
[source, text]
---------------------------------------------------------------------
;----------------------------------------
; eventsystem
;----------------------------------------
[eventsystem]
eventsystem_enabled = 1
---------------------------------------------------------------------

Möglich ist auch die direkte Instanzierung (Singleton).
$eventhandler = Clansuite_Eventhandler::instantiate();

Zumeist ist eine Instanzierung jedoch nur zum Aufruf der Methode triggerEvent() gewollt.
Um die Instanzierung abzukürzen kann direkt Clansuite_CMS::triggerEvent() eingesetzt werden.

.Verwendung

Ein neues Ereignis kann folgendermaßen registriert werden.
[source, php]
---------------------------------------------------------------------
$eventhandler->addEventHandler($eventName, Clansuite_Event $event);
---------------------------------------------------------------------

Konkretes Beispiel:
[source, php]
---------------------------------------------------------------------
$logger = new Clansuite_Logger();
$authlogger = AuthenticationLogging($logger);
$eventhandler->addEventHandler('onUserLogin', $authlogger);
---------------------------------------------------------------------

[source, php]
---------------------------------------------------------------------
# Systemweit
Clansuite_CMS::triggerEvent();

# Innerhalb eines Modulecontrollers
@todo
---------------------------------------------------------------------

.Entwurfsmuster

Die Klasse Clansuite_Eventdispatcher ist ein Kontainer für alle Eventhandler. Sie ist eine Hilfsklasse für
ereignisbasierte Entwicklung. Ereignisse können unter einem Ereignisnamen registriert werden. Wenn ein
Ereignis durch den Programmablauf ausgelöst bzw. getriggert wird, erfolgt eine Suche nach dem Ereignisnamen
unter allen registrierten Ereignissen. Wird ein entsprechendes Ereignis gefunden, so wird es ausgeführt.
Werden mehrere entsprechende Ereignisse gefunden, so werden sie in der Reihenfolge ihrer Registrierung ausgeführt.
Auf diese Art und Weise können Objekte sich sehr flexibel untereinander verständigen und es kann sehr leicht neue
Funktionalität nachträglich hinzugefügt werden.

Die Klasse Clansuite_Event ist die Basisklasse für alle Events.
Mittels der Methoden getName(), getContext(), getInfo() können Kontextinformationen über das Ereignis eingeholt werden.
Mittels der Methode cancel() kann ein Abbruch erfolgen. Um zu überprüfen, ob ein Abbruch innerhalb einer Ereigniskette stattfand,
kann die Methode getCancelled() eingesetzt werden.

Der Name des Entwurfsmusters ist mit dem Klassennamen identisch. Es ist das "Event-Dispatcher" Muster.
Häufiger ist es auch nur unter dem Namen Event oder Eventsystem anzutreffen. Alternativ wird es auch als "Hooksystem" (für Haken bzw. Aufhänger) bezeichnet.
Geläufig sind auch die Muster-Bezeichnungen "Subject-Observer-Muster" und "Notification Queue".

===== Übersicht zu Eventhandlern

.Hooks im Bereich Benutzerregistrierung, Login, Logout

- onRegisterAccount
wenn neuer Useraccount angelegt wird (Daten können bei fremdem System eingetragen werden)

- onAccountActivation
wenn ein neuer Useraccount aktiviert wird

- beforeLoginValidation
bevor die Prüfung der Eingaben erfolgt, kann ein fremdes System damit befragt werden (Bridges)

- afterLogin
nach einem erfolgreichen Login

- afterLogout
nach einem erfolgreichen Logout

- onDeleteAccount
bevor die Löschung eines Useraccounts durchgeführt wird (Daten können aus fremdem System ausgetragen werden)

- resetPassword

.Hooks im Bereich Formulargenerierung und Formularhandling

.Hooks im Bereich Dateihandling

- onDownload
nachdem eine Datei heruntergeladen wurde (Update des Downloadcounters in der Statistik)

. Hooks innerhalb von Doctrine Records

Die Hooks innerhalb von Doctrine Record Objekten an 5 Aktionen an.
Diese 5 Aktionen sind Save, Update, Insert, Delete und Validate.
Jede dieser Aktionen wird nochmals gemäß der zeitlichen Anknüpfung unterteilt.
So gibt es einen Haken vor der Aktion (Pre-Hook) und einen Haken nach der Aktion (Post-Hook).
Innerhalb von Doctrine Records stehen also die folgenden 10 Hooks zur Verfügung.

- preSave
- postSave
- preUpdate
- postUpdate
- preInsert
- postInsert
- preDelete
- postDelete
- preValidate
- postValidate

Um einen dieser Hooks zu verwenden, wird das Doctrine Record Object einfach um eine nach dem gewünschten Hook benannte Methode erweitert.

[source, php]
---------------------------------------------------------------------
class Mein_Doctrine_Record_Object extends Doctrine_Record
{

	public function setTableDefinition()
	{
		# Definition der Tabelle
	}

	public function setUp()
	{
		# Setup und Relationen
	}

	public function postInsert()
	{
		# Wenn diese Stelle des Quellcodes aufgerufen wird, befinden wir uns zeitlich nach dem Einfügen eines neuen Datensatzes.
		# An dieser Stelle können Sie den Quellcode einfügen, der nach diesem Ereignis ausgeführt werden soll.
	}
}
---------------------------------------------------------------------

==== Clansuite_Errorhandler

Die Behandlung von Programmfehlern erfolgt mittels der Klasse Clansuite_Errorhandler.

Zahlreiche Webanwendungen machen von der Möglichkeit gebrauch, das Errorhandling an den Exceptionhandler zu
übertragen. Dies führt zu einer Vereinfachung des Systems, da nicht mehr zwei Handler-Klassen gepflegt werden
müssen. Clansuite nutzt diese Möglichkeit nicht. Dies hat zwei Gründe. Zum einen müsste der Exceptionhandler
intern prüfen, ob ein Error die Exception ausgelöst hat, womit eigentlich Logik des Errorhandlers in den
Exceptionhandler verschoben wird. Zum anderen soll es bei Clansuite möglich sein, dem jeweiligen Handler
ein eigenes Aussehn durch Templates zu geben.

===== Fehlerbehandlung für strikte Typen
Auch PHP in der Version 5.2+ hat immernoch ein großes Problem im Bereich Typen.
Die Sprache PHP kennt keine strikten Typen (engl. Strict Types). PHP ist eine schwach typisierte Sprache.
Der Typ einer Variablen wird durch den Kontext bei ihrer konkreten Verwendung bestimmt.
Demnach können Variablentypen während der Laufzeit einer Typänderung unterliegen.
Dies bezeichnet man als automatisches bzw. dynamisches Type-Casting oder Type-Juggling
footnote:[http://php.net/manual/en/language.types.type-juggling.php]).
Es ist es möglich Variablen zu verwenden, ohne sie vorher zu deklarieren.

PHP stellt eine Möglichkeit bereit, um festzustellen, ob eine Variable initialisert wurde.
So lässt sich der Level der Fehlerberichterstattung mittels der Methode error_reporting() auf E_NOTICE setzen.
Nicht initialsierte Variablen werden dann als Fehler des Typs Notice angezeigt und man erhält zumindest einen Hinweis.
Clansuite wird seit Anfang der Entwicklung mit dem Fehlerberichterstattungslevel E_STRICT and E_NOTICE entwickelt.
Eine Alternative dazu, wäre der Einsatz eines externen Quelltext-Prüfwerkzeugs wie PHP Lint,
um diese Fehler hervorzuheben. Viele Editoren und IDEs integrieren ein solches Prüfwerkzeug bereits.

Die Verwendung von strikten Typen bringt einige Vorteile mit sich.
Fehler treten schneller hervor und die Ausdrucksstärke der Variablenverwendung in Funktionen und Methoden wird erhöht.
Beispielsweise kennt PERL ein "use strict", doch ein solches fehlt bei PHP noch immer.

.Die Weiterentwicklung von PHP im Hinblick auf die Unterstützung strikter Typen
Gegenwärtig wird sowohl auf der PHP-Mailingliste als auch im PHP-Wiki über die Unterstützung
strikter Typen diskutiert. Lukas Smith hat am 03.06.2009 eine PHP-RFC zum Thema "Typechecking"
footnote:[http://wiki.php.net/rfc/typechecking, PHP RFC Typechecking Vorschlag von Lukas Smith]
verfasst, sein Entwurf ist unter http://wiki.php.net/rfc/typecheckingstrictandweak abrufbar.
Ein weiterer Vorschlag footnote:[http://wiki.php.net/rfc/typecheckingstrictonly, PHP RFC
Typechecking Vorschlag von Ilia Alshanetsky] von Ilia Alshanetsky
zum Thema Typechecking befasst sich mit der Ergänzung der Reflection-Erweiterung
um typdefinierende ReflectionParameter Methoden. Er führt zum Beispiel Methoden
wie ReflectionParameter::isInt() oder ReflectionParameter::isBool() zur Typprüfung mittels Reflektion ein.

===== Die Clansuite Errorcodes

Um Fehler auszulösen kann der PHP-Befehl trigger_error() eingesetzt werden.

[source, txt]
---------------------------------------------------------------------
E_USER_WARNING
E_USER_NOTICE
E_USER_ERROR
---------------------------------------------------------------------

Statt der Verwendung von Errors bitte grunsätzlich Exceptions verwenden.

Zu jeder Regel gibts eine Ausnahme: keine Exceptions in Templates werfen. Bei Verwendung von Smarty unbedingt
trigger_error() verwenden, denn die auf diese Art geworfenen Fehler werden automatisch abgefangen und im
Template zur Bearbeitung markiert.

IMPORTANT: In Smarty Plugins und Funktionen immer trigger_error() einsetzen.

===== Übersetzung von Fehlermeldungen

Derzeit findet keine Übersetzung von Fehlermeldungen statt.
Die Sprache der Fehlermeldungen ist Englisch.

==== Clansuite_Exceptionhandler

Die Exceptionbehandlung ist ähnlich der Behandlung von Errors. Die Klasse Clansuite_Exception erweitert die
normale PHP Exception Klasse. footnote:[http://php.net/exceptions, PHP Handbuch - Kapitel Exceptions] Die
Erweiterung besteht dabei einerseits in verbesserter Darstellung der Exceptions, andererseits in dem
automatischen auffangen aller nicht abgefangenen Exceptions, z.B. denen fremder Bibliotheken.

Kern der Klasse ist die Methode yellowScreenOfDeath(), mit der eine Darstellungsmethode für Exceptions
eingeführt wird. Sie zeigt Exceptionmessage und Code, sowie die Ausgabe der nicht abgefangenen Exception an.
Erweitert wird die Anzeige durch Debuginformationen, wie z.B. dem Debug-Call-Stacktrace, welcher die zuletzt
ausgeführten Methodenaufrufe vor dem Exceptioneintritt aufführt und der Anzeige von Direktlinks zum Support
und zu den Handbüchern.

Mittels set_exception_handler wird ein systemweiter Exceptionhandler registriert. Er sorgt dafür, dass nicht
abgefangene Exceptions mittels dieser Darstellungsmethode anzeigt werden. Dies erfolgt bei Initialisierung des
Systems innerhalb der Methode initialize_Errorhandling() in der Datei "bootstrap/clansuite.application.php".
Dieser wirft durch Aufruf der Methode throwException() eine neue Clansuite_Exception.

===== Verwendung: Das Werfen von Exceptions

[source, php]
---------------------------------------------------------------------
# Hier wird eine normale Exception geworfen.
# Diese wird durch den Exception Handler gefangen und in eine Clansuite Exception umgewandelt.
throw new Exception('Meine Exception');

# Es wird eine Clansuite Exception mit der Exceptionnummer 60 geworfen.
# Sollte ein Exception Template für die Nummer 60 existieren, wird sein
# Inhalt innerhalb des Exception-Kontext dargestellt.
# Der Unterstrich vor dem Exception-Text bewirkt die Übersetzung.
throw new Clansuite_Exception( _('Meine Exception') , 60);

# Werfen einer Exception
Clansuite_Exception->throwException(),

# Verwendung bei Methoden, die einen Wert des Typs Boolean zurückliefern
someBooleanMethod() or throwException();

# Beispielsweise
isFileandReadable('filename.txt') or throwException('File not found or not readable!');
---------------------------------------------------------------------

===== Die Exceptionhandler Templates

Der Exceptionhandler bietet die Möglichkeit mit Exceptiontemplates zu arbeiten. Das sind Templates die zu
einer Exception einen ausführlicheren Beschreibungstext anbieten und somit den Kontext der Exception
erläutern, um den Fehler zu überwinden. Jeder Exception ist eine Identifikatonsnummer zugewiesen, anhand
dieser wird ein entsprechendes Template geladen.

Dabei unterscheiden wir zwei Arten von Exceptiontemplates. Zum einen normale Exceptiontemplates. Die angezeigt
werden, wenn das System im Debugmodus betrieben wird. Zum anderen Entwickler-Exceptiontemplates. Die angezeigt
werden, wenn das System im Debug- und Developermodus betrieben wird. Die Exceptionstemplates befinden sich im
Verzeichnis "themes\core\exceptions".

Der Unterschied zwischen der beiden Arten von Templates findet seinen Ausdruck in der Benennung der
Templatedateien. Der Dateiname normaler Exceptiontemplates lautet "exception-x.tpl". Der Dateiname von
Entwickler-Exceptiontemplates lautet "dev-exception-x.tpl". Hierbei steht das "x" jeweils für den
Exceptioncode, die eindeutige Identifikationsnummer. Wenn für einen Excpetioncode beide Templates existieren,
dann werden auch beide nacheinander innerhalb der Exceptionanzeige angezeigt.
Die Reihenfolge der Darstellung ist dabei Normaltemplate vor Entwicklertemplate.

===== Die Exceptionhandler Codes

Nachfolgende Tabelle schlüsselt die bisher vergebenen Exceptioncodes auf.
Eine entsprechende Datei befindet sich auch im Verzeichnis der Templates
/themes/core/exception/errorcodes.txt.

[source,txt]
---------------------------------------------------------------------
Exceptioncode    Exceptionname                                        Used in File               Method
---------------------------------------------------------------------

[source,txt]
---------------------------------------------------------------------
dev-1            Database Connection Information invalid              /core/doctrine.core.php    prepareDbConnection()
dev-2            Action Missing. Create now.
dev-3            Module Missing. Create now.
dev-4            Config Missing. Create now.                          /ini.config.php            readConfig()

09               Smarty Template Directories do not exist.            startup_checks.filter.php
10               Smarty Template Directories not writable.            "

12               The copyright tag is missing.                        Smarty.renderer.php
                 {include file='copyright.tpl'}
                 in your layout/wrapper template file:
13               The header notice tag is missing.
                 {include file='clansuite_header_notice.tpl'}         "
14               The content variable {$content} must be within       "
                 the wrapper template
---------------------------------------------------------------------

===== Übersetzung von Ausnahmemeldungen

Derzeit findet keine Übersetzung von Ausnahmemeldungen statt.
Die Sprache der Ausnahmemeldungen ist Englisch.

==== Clansuite_Feed

.Instanzierung

.Verwendung

==== Clansuite_Form

Clansuite Forms verwendet Filter und Validatoren automatisch, wenn sie für ein Formelement definiert wurden.

.Schutz vor Cross Site Request Forgery (CSRF) durch Token (Shared-Secret)

Der Fachbegriff Cross-Site-Request Forgery (CSRF) lässt sich nur schwer in die deutsche Sprache übertragen.
Man kann darunter einen Angriff verstehen, bei dem durch einen untergeschobenen Aufruf auf eine Fremdseite
eine Datenveränderung innerhalb einer Webanwendung durchgeführt wird.
Dabei wird dem Angriffsopfer in seinem Webbrowser ein URL-Aufruf untergejubelt,
der einen veränderten HTTP-Request ausführt. Der veränderte Request führt nun die vom
Angreifer gewünschte Aktion aus. Dies hat regelmäßig Erfolg, wenn der Nutzer bei der Webanwendung angemeldet
ist und aus Bequemlichkeits- und Komfortgründen ein Cookie gespeichert hat. Eine bestehende Anmeldung oder
der Zugriff auf Cookie-Daten ist Voraussetzung für einen erfolgreichen Angriff.

Die Angriffsvektoren bei Cross Site Request Forgery (CSRF) sind regelmäßig das URL-Unterschieben und das
Cross-Site- Scripting (XSS).

Ein URL-Unterschieben kann auf vielfältige Art erfolgen. So beispielsweise durch
das Verteilen einer URL während eines IRC Chats oder durch Zusenden einer E-Mail.

Bei Cross-Site-Scripting (XSS) wird HTML-Code an die Webanwendung übermittelt.
Dies erfolgt häufig durch Ausnutzen von Sicherheitslücken im JavaScript-Bereich.
So kann beispielsweise jeder <img> oder <frame> Tag zum Nachladen von Angriffselementen eingesetzt werden.
Zuerst wird also ein HTML-Tag Element mittels JS eingeschleust, sodann wird die Seite vom Opfer aufgerufen.
Beim Aufruf wird der eingeschleuste Tag vom Browser interpretiert und der schadhafte Link aufgerufen.

Um sich davor zu schützen, verwendet man ein einfaches serverseitiges Verfahren. Ein Zugriff auf die
Applikations wird mittels eines Sicherheitstokens (Shared-Secret) erreicht. Der Sicherheitstoken wird als
verstecktes Feld zusätzlich zu jedem Formular hinzugefügt. Beim Übermitteln des Formulars wird automatisch
überprüft, ob der Sicherheitstoken des Formulars mit dem intern (in der UserSession) vorliegenden
übereinstimmt. Die eingehenden Daten sind valide, wenn der Token übereinstimmt.
Liegt kein Token vor oder stimmt er nicht überein, werden die eingehenden Daten des Requests verworfen.

.Verwendung

===== Entwurfsmuster

===== Übersicht zu den einzelnen Formelementen

==== Clansuite_Flashmessages

.Instanzierung

.Verwendung

==== Clansuite_Localization

.Instanzierung

.Verwendung

==== Clansuite_Logger

Die Klasse Clansuite_Logger dient dem Logging von Nachrichten und Fehlern, die sich während des
Applikationsablaufs erreignen.

.Instanzierung

[source, php]
---------------------------------------------------------------------
$logger = new Clansuite_Logger();
---------------------------------------------------------------------

.Verwendung

.a) Übergabe eines Strings als Loggername
[source, php]
---------------------------------------------------------------------
$logger->addLogger('firebug');
---------------------------------------------------------------------

.b) Übergabe eines Loggerobjekts
[source, php]
---------------------------------------------------------------------
$logger->addLoger(new Clansuite_Logger_Firebug);
---------------------------------------------------------------------

.c) Übergabe mehrerer Loggerobjekte
[source, php]
---------------------------------------------------------------------
$logger_array = array();
$logger_array[] = new Clansuite_Logger_Firebug();
$logger_array[] = new Clansuite_Logger_File();
$logger->addLoger($logger_array);
---------------------------------------------------------------------

===== Entwurfsmuster

Das Entwurfsmuster für diese Klasse ist ein Kompositum (auch compositum order composite genannt). Die Klasse
repräsentiert also eine Zusammenstellung eines oder mehrerer Logger. Ein neues Logger-Objekt wird dem
Kompositum mittels addLogger() hinzugefügt und mittels removeLogger() wieder entfernt.
Das Kompositum wird durch die Methode writeLog() ausgelöst.

====== Die Logger Adapter

Die folgenden Logger Adapter stehen für die Komposition zur Verfügung.

======= Logger: /dev/null

Der Logger /dev/null sendet die Lognachrichten direkt in den Papierkorb.

======= Logger: E-Mail

Der Logger E-Mail sendet die Lognachrichten via E-Mail.

======= Logger: File

Der Logger File schreibt die Lognachrichten in die Logdatei.

======= Logger: Firebug

Der Logger Firebug sendet die Lognachrichten in die Firebug Konsole des Firefox Webbrowsers.

==== Clansuite_Mailer

Die Klasse Clansuite_Mailer ist eine einfache Wrapper- und Initialisierungsklasse für SwiftMailer. SwiftMailer
wurde ursprünglich von Chris Corbyn entwickelt. Seit der Version 4.0.0 ist Fabien Potencier vom Symfony-Team
als weiterer Entwickler hinzugekommen.

Webseite des SwiftMailer Projekts: http://swiftmailer.org/

.Konfiguration

Clansuite_Mailer benötigt einige Konfigurationseinstellungen.
Diese sind in der clansuite.config.php im Abschnitt [email] zu finden.

Erforderlich sind:
[source, php]
---------------------------------------------------------------------
$config['email']['mailmethod']
$config['email']['mailerhost']
$config['email']['mailerport']
$config['email']['mailencryption']
---------------------------------------------------------------------

.Instanzierung

$mailer = new Clansuite_Mailer();

.Verwendung

[source, php]
---------------------------------------------------------------------
# Senden einer E-Mail mittels der Methode sendmail()
$mailer->sendmail($to_address, $from_address, $subject, $body);

# Holen des SwiftMailer Objekts aus dem Wrapper
$swiftmailer = $mailer->getMailer();
---------------------------------------------------------------------

.Entwurfsmuster

Wrapper.

==== Clansuite_Modulecontroller

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Route

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Trail

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Security

Die Klasse Clansuite_Security stellt den Zugriff auf Streuwert-Methoden (hashing) bereit.
Die drei Methoden der Klasse ermöglichen eine Zeichenkette zu hashen, zu salzen und zu vergleichen.
Die Methode build_salted_hash() erstellt einen gesalzenen Hash.
Die Methode generate_hash() erstellt einen Hash einer Zeichenkette.
Die Methode generate_salt() erstellt eine zufällige Zeichenkette (genannt Salz).

.Allgemeines zum Thema-Hashing
Streuwert-Methoden oder Hashing-Methoden sind Funktionen zur Abbildung einer Zeichenkette auf eine
eindeutige (zumeist aus Buchstaben und Zahlen bestehende) Zeichenkette.

Man muss sich hierbei zwei Dinge vergegenwärtigen.
Erstens, dass Eindeutigkeit bedeutet, dass eine Ausgangszeichenkette immer genau einen Hash hat.

.Eindeutigkeit von Hashes
[source, php]
---------------------------------------------------------------------
Beispiel
$passwort_zeichenkette = 'meinPasswort';
$md5_hash_der_passwort_zeichenkette = md5($passwort_zeichenkette);
echo $md5_hash_der_passwort_zeichenkette; # = f14a298bc87fff2cd757f71054fdd94d
# Die Zeichenkette 'meinPasswort' entspricht dem MD5 Hash 'f14a298bc87fff2cd757f71054fdd94d'.
---------------------------------------------------------------------

Zweitens, dass ein Hash nicht umkehrbar ist. Man kann nicht von einem Hash auf die Ausgangszeichenkette schließen.
Die Unumkehrbarkeit von Hashes ist der Unterschied zur Verschlüsselung. Bei einer verschlüsselten Zeichenkette,
existiert ein Schlüssel und eine Methode, um sie in ihre Ausgangszeichenkette (regelmäßig den Klartext) umzuwandeln.

Das Hashing-Verfahren wird beispielsweise eingesetzt um zwei Dateien auf ihre Gleichheit zu überprüfen.
Anstatt nun einen zeichen- oder zeilenweisen Dateivergleich durchzuführen, wird für beide Dateien
ein Hash, also eine eindeutige Zeichenkette erzeugt. Man nennt diese Zeichenkette daher auch
Identifikator oder Fingerabdruck (engl. Fingerprint). Der Vergleich der Fingerabdrücke der beiden Dateien
gibt nun Auskunft über ihre Gleichheit oder Ungleichheit.

Im Bereich der Webanwendungssicherheit hat sich das Hashing für die Absicherung von Passwörtern als sinnvoll erwiesen.
Anstatt Benutzerpasswörter im Klartext in der Datenbank zu speichern werden sie nun gehashed abgespeichert.
Damit wird die Einsehbarkeit des Klartextes durch Administratoren oder Dritte, etwa
bei einem Datenbankeneinbruch oder -diebstahl, unterbunden. Der Angreifer erhält nun "nur" den Hash des Passworts.

.Angriffsmethoden auf gehashte Passwörter
Es gibt aber auch bei gehashten Passwörtern Angriffsmethoden. Eine Methode besteht darin, einfach alle Varianten
auszuprobieren. Eine weitere Methode setzt vorbereitete Tabellen als Nachschlagewerk ein.

Die erste Methode, die Brute-Force-Methode (Methode roher Gewaltanwendung) besteht darin,
Passwörter zusammenzusetzen und die erstellten Hashes nacheinander auszuprobieren.
Brute-Force-Algorithmen sind sehr einfach zu implementieren aber heillos ineffizient.
Der Rechenaufwand steigt proportional mit der Menge an zu probierenden Passwörtern.
Die Anzahl zu probierender Passwörter unterliegt dabei einem expotentiellen Wachstum.
Die Rechenleistung heutiger CPUs erlaubt es dennoch sehr viele Passwort-Möglichkeiten pro Zeiteinheit auszuprobieren.
Die Bedrohungslage im Bereich der Brute-Force Angriffe hat sich durch das Aufkommen
von extrem rechenstarken Grafikkarten nochmals verschärft.

In Sachen Gleitkommaoperationen (also Additionen und Multiplikationen) pro Sekunde kann eine
normale Mehrkern-CPU einer GPU, dem Rechenprozessor der Grafikkarte, niemals das Wasser reichen.
Ein Vergleich der Gleitkommaoperationen pro Sekunde (engl. Floating Point Operations per Second, abgekürzt FLOPS)
bei aktuellen Produkten (Januar 2010) mag dies verdeutlichen.
Ein Intel Core i7 965 XE Prozessor mit aktiviertem Hyper-Threading verfügt über 4 Kerne mit 3,2Ghz
und kostet rund 1000 Euro. Er erreicht in der Spitze 50 bzw. im Schnitt 33 GigaFlops.
Laut eines TechRadar Benchmarks sogar 69 GFlops. footnote:[http://mos.techradar.com/techradar-corei7-benchmarks.pdf]
Die Grafikkarte Nvidia GeForce GTX 295 ist bereits für unter 500 Euro im Handel erhältlich
und schafft rund 1750 GigaFlops. Die AMD Radeon HD 5970 knackte als erste Grafikkarte sogar
die 1-TeraFlops-Grenze und ist für rund 550 Euro im Handel erhältlich.

Für die Ermittlung dieser Rechenleistung wird zumeist auf das Programm "linpack" zurückgegriffen.
Eine webbasierte Linpack-Version findet man unter http://www.netlib.org/benchmark/linpackjava/.

Die Brute-Force-Programme greifen daher oftmals nicht mehr nur auf die CPU sondern insbesondere auf die GPU zu.
Webanwendungen müssen auf diese Bedrohung angemessen reagieren und mit der Zeit gehen.
Dazu gehört, dass Passwörter niedriger Stärke abgelehnt und neuere Hashverfahren und Salting eingesetzt werden.

.Vorteile von gesalzenden Hashes
Für gesalzene Hashes spricht, dass ein Angriff mittels einer Streuwerttabelle relativ nutzlos wird.

Streuwerttabellen beinhaltet eine vorgenerierte Liste an Hashes für eine Vielzahl von Wörtern und Zeichenkombination.
Man versucht bei einem solchen Angriff durch einen Vergleich des Hashes in der Datenbank mit dem Hash in
der Hash-Tabelle auf das eingesetzte Wort zu schließen. Da eine solche Streuwerttabelle unter Umständen
mehrere Terabyte an Daten enthält, ist sie erstens kaum zu verarbeiten und zweitens würde ein
vergleichender Rückschluß sehr lange dauern.

Um die Menge an Daten einer Streuwerttabelle zu verkleinern und sie somit in kurzer Zeit durchsuchbar zu machen,
wurde eine spezielle Form einer solchen Streuwertabelle entwickelt.
Diese Datenstruktur nennt man Regenbogentabelle (engl. Rainbow-Tables) und wurde vom Schweizer Informatiker
Philippe Oechslin im Jahr 2003 entwickelt footnote:[http://lasecwww.epfl.ch/pub/lasec/doc/Oech03.pdf],
wobei der Ansatz schon im Jahr 1980 durch Martin Hellman
footnote:[M. E. Hellman. A cryptanalytic time-memory trade off. IEEE Transactions on
Information Theory, IT-26:401406, 1980] beschrieben wurde.
Rainbowtables sind in gewisser Weise stark verkleinerte Streuwert-Tabellen, in denen viele Passwörter
mit den dazugehörigen Hashes gespeichert sind.
Bei Regenbogentabellen werden nicht alle Ausgangswerte und Hashes gespeichert, sondern der
Wert wird zuerst gehashed und anschließend reduziert. Die Reduktion erzeugt eine Zeichenkette
mit der Länge des Ausgangswerts und ist damit also ein mögliches Passwort.
Dieser Prozess der Reduktion wird mehrmals durchlaufen, um eine bestimmt Menge (eine Kette) an möglichen
Passwörtern zur Verfügung zu haben (= ein Spektralbereich des Regenbogens).
In die Regenbogentabelle wird regelmäßig nur der Ausgangswert und der letzte Hashwert gespeichert
(Start und Ende des Spektralbereichs bzw. der Kette).
Das Nachschlagen in einer solchen Regenbogentabelle ist zweischrittig.
Der erste Schritt ist die Bestimmung der Kette. Fällt ein Hash in den Spektralbereich,
dann berechnet man diese Kette (diesen Teil des Spektralbereichs) neu.
Dabei hat man soviele Chancen den Ausgangswert zu finden, wie diese Kette lang ist.
Wenn der Hash in der Tabelle steht findet man das Passwort also viel schneller
als mit einem normalen Brute-Force Programm.

Daraus resultiert, dass unter Verwendung eines gesalzenen Hashes ein solcher Angriff
nur auf ein einzelnes Nutzerkonto ausgeführt werden kann, denn jeder Hash
ist aufgrund einer zufällige vorangestellten Zeichenkette erstellt worden.
Damit wird ein Problem behoben, dass entsteht, wenn mehrere Nutzerkonten das gleiche
Passwort verwenden, also identische Hashes haben. Anstatt zwei identischer Hashes
wird durch den zufälligen Salzanteil nun jeweils ein unterschiedlicher Hash erzeugt.

.Nachteile von gesalzenen Hashes
Die Passworter können wegen der Zufälligkeit nicht angefordert werden. Man kann sie nur neu generieren.
Das mag einerseits einen Useability-Nachteil bedeuten, andererseits bietet es einen deutlichen Sicherheitsvorteil.

.Die Bibliothek "phpass" und ein Blick auf andere CMS/CMF
Seit 2004 gibt es die Bibliothek "Portable PHP password hashing framework"
footnote:[http://www.openwall.com/phpass/] geschrieben von Solar Designer <solar[at]openwall.com>
unter einer Public Domain Lizenz.
Diese Bibliothek reimplementiert als Kernmethode den in PHP verfügbaren CRYPT_BLOWFISH Hashing-Algorithmus.
Der Blowfish Algorithmus wurde 1993 (im Jahr 2010 ist er 17 Jahre alt) durch Bruce Schneier
entwickelt und beschrieben footnote:[http://www.schneier.com/paper-blowfish-fse.html].
Das Blowfish Verfahren ist nicht patentiert und lizenzfrei verfügbar. footnote:[http://www.schneier.com/blowfish.html]
Diese Open-Source Verfügbarkeit bewirkte eine rasche Verbreitung in der Open-Source Szene.
Blowfish bietet auch heute noch (2010) eine mit aktuellen Algorithmen vergleichbare Sicherheit und Geschwindigkeit.
Als weitere Fallbacks bietet phpass ein CRYPT_EXT_DES und ein MD5-basiertes Hashing.
Diese Bibliothek wird von Backpress/Wordpress
footnote:[http://backpress.automattic.com/browser/tags/1.0.2/includes/class.passwordhash.php]
Drupal und TYPO3
footnote:[http://typo3.org/extensions/repository/view/t3sec_saltedpw/current/, Typo3 Extension T3Sec_SaltedPW]
eingesetzt.

.Instanzierung

Durch Autoloading kann jederzeit auf die Klasse zugegriffen werden.
Auch eine Constructor Injection ist möglich.

[source, php]
---------------------------------------------------------------------
# systemweites autoloading
$security = new Clansuite_Security();

# Holen des Objekts aus dem Dependency Injector
$config = $this->injector->instantiate('Clansuite_Security');

# Automatisches holen bei Verwendung der Constructor Dependency Injection
public function __construct(Clansuite_Security $security)
---------------------------------------------------------------------

.Verwendung

*Die Methode build_salted_hash()*
Die Methode nimmt als ersten Parameter eine Zeichenkette entgegen und als zweiten Parameter die
Abkürzung eines Hashing-Algorithmus. Diese Zeichenkette wird am Anfang mit einer zufällige Zeichenkette versehen.
Dieses Voranstellen einer zufälligen Zeichenkette nennt man salzen (engl. salting).
Die neu entstandene Kombination aus Salz+Zeichenkette wird dann der Hashing Methode generate_hash() übergeben,
um von ihr einen Hash als Rückgabewert zu erhalten.

*Die Methode generate_hash()*
Die Methode generiert einen Hash aus einer Zeichenkette unter Verwendung eines Hashing-Algorithmus.
Dabei wird auf die PHP-Funktion hash() zurückgegriffen.
Somit stehen beispielsweise die Hashing-Algorithmen md5, sha1, sha256 zur Verfügung.
Als das Standardverfahren ist sha1 festgelegt.
Um eine komplette Liste der verfügbaren Hashing Algorithmen des Kommandos hash() zu erhalten,
 eignet sich die PHP-Kommandokombination print_r(hash_algos()); .
Falls hash() nicht verfügbar sein sollte, wird als Fallback auf die PHP-Kommandos md5() bzw. sha1() zurückgegriffen.
Falls sie die PHP Extension "skein" installiert haben und in der Konfiguration als
Hash-Algorithmus 'skein' festgelegt haben, dann wird ein 512-bit Skein-Hash erstellt.
Sie finden die PHP Extension auf Skein Webseite unter http://www.skein-hash.info/downloads.

*Die Methode generate_salt()*
Diese Methode erzeugt einen Zufallsstring der gewünschten Länge.
Der Zufallsstring besteht Zahlen, sowie Groß- und Kleinbuchstaben und den Sonderzeichen '.' und '/'.
Die "Zufälligkeit" von Zeichen wird mittels mt_srand() and mt_rand() erzeugt.

==== Clansuite_Session

Das PHP Sessionhandling ist ein sicherheitskritischer Bereich. Die normalen PHP Sessions sind ungeschützt.

.Sicherung von Session-Cookie

a) Sicherung von Session-Cookies mittels SSL und Secure Flag
Wenn Clansuite mit SSL verwendet wird, ist das Cookie "secure" flag zu
setzen. Dies sorgt dafür, dass der Cookie nicht unverschlüsselt gesendet wird, sondern so verschlüsselt,
sodass niemand den Cookie stehlen kann.

b) Cookie HTTPONLY
Das Session-Cookie kann mittels der Konfigurationseinstellung "cookie_httpOnly" gegen XSS geschützt werden. In
diesem Fall werden Javascripte
wirksam davon ausgeschlossen die Session ID zu stehlen.

.Zufällige SessionID für jede Clansuite Installation
Falls zwei Clansuite Applikationen sich auf dem gleichen Server befinden und sich einen Sessionspace teilen,
ist es möglich das beide Applikationen gegenseitig Sicherheitslöcher in das Sessionhandling reißen. Es gibt
zwei Methoden um dies zu unterbinden: Erstens, wenn sie Clansuite_Session (DB) verwenden, legen Sie für jede
Installation eine Datenbank an. Installieren sie nicht zwei Clansuite Versionen (eine für ein Blog) die andere
für den Clan. Zweitens, wenns die Session im save_path abgespeichert wird, dann ist jeder Clansuite
Installation ein eigenes Sessionverzeichnis zu geben. So kommen die zwei Versionen sich nicht in die Quere.

.Niedrigen Session Timeout ansetzen (maxlifetime)
Je weniger Zeit ein Session Fenster hat, desto sicherer ist es.
Die Session Lifetime kann in der Clansuite Konfiguration eingestellt werden.

.Schutz vor Session Fixierung (Session Fixation)
Einer Session Fixation kann man nur durch Erneuerung der SessionID bei Änderung des Userstatus (login/logout)
begegnen. Die Erneuerung der Session erfolgt mittels Clansuite_Session::regenerateID().
Sie ist direkt mit der Login-Funktion verknüpft.

.Session Hijacking
Session Hijacking bedeutet, dass ein Dritter sich den Inhalt der Session zu eigen machen kann.
Häufig geschieht dies über Man-in-the-middle Attacken oder Sniffing/XSS.
Guten Schutz bietet nur die Verwendung von "cookie_httpOnly" und SSL-Verschlüsselung.

.Session Validation
Clansuite hat für die Sessionvalidierung den Filter Session Security.
Doch die Session Validierungsregeln, z. B. die Überprüfung, ob die Session von der gleichen IP oder
der Request vom gleichen User-Agent kommt, halten einem Session Hijacking nicht stand.
Zusätzlich bereiten Session-Überprüfungen eine Menge Probleme.
a) Man schließt bestimmte IPs aus.
Bei bestimmten Providern hat jeder Request eine neue IP (AOL). Stichwort: Proxy Farming.
b) User-Agent HTTP Header Checks
c) Accept Header Check
Aus vorgenannten Gründen wird vom Einsatz des Sessionfilters abgeraten.

.Instanzierung

.Verwendung

==== Clansuite_Upload

.Instanzierung

.Verwendung