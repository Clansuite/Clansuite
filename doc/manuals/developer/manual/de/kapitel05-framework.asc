////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc User Guide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find an AsciiDoc Sheet Cheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 5 - Das Framework und die einzelnen Core-Komponenten

In diesem Kapitel werden die einzelnen Bestandteile des Clansuite Frameworks erläutert. Dabei ist jeder
Komponente des Systems ein eigener Abschnitt gewidmet. Du findest hier auch Definitionen und Erklärungen zu den
verwendeten Entwurfsmustern und zum allgemeinen Systemaufbau, insbesondere zur Model-View-Controller
Architektur (MVC) des Systems.

=== Das Clansuite CMS und das Clansuite Framework

Das Clansuite CMS basiert auf dem Clansuite Framework. Wir schreiben unser eigenes Framework, um den Aufwand
zu minimieren, ständig neuen Code für das CMS entwickeln zu müssen. Die Verwendung des Frameworks minimiert
die Anzahl der Codezeilen die geschrieben werden müssen, um bestimmte Ziele mit dem CMS zu erreichen. Viele
Methoden werden einfach zur "standardisierten" Verwendung bereitgestellt. Das Clansuite Framework dient also
dazu, die Standardaufgaben, die ein jedes CMS erledigen muss, vor die Klammern zu ziehen. Das CMS Clansuite
ist als nutzerfreundliche fertige Anwendung gedacht, die lediglich konfiguriert werden muss. Dabei werden
die einzelnen CMS Dienste werden durch Module bereitgestellt. Es ist für Erweiterungen und Plugins offen.
Das Framework vereinfacht also die Entwicklung und gibt auch dem CMS eine bestimmte Struktur und Festigkeit.

.Input-Transformation-Output (ITO) oder Eingabe-Verarbeitung-Ausgabe (EVA-Prinzip)
Die Hauptaufgabe einer Webapplikation liegt darin, einen gegebenen Input in einen Output zu transformieren.
Der gegebenen Input ist dabei regelmäßig eine URL. Der zu erzeugende Ouput ist regelmäßig der vom Webbrowser
zu interpretierende und darzustellende Quelltext, beispielsweise im Format XHTML.

.Das Input-Transformation-Output Prinzip
["graphviz", "chapter05_image01_ito.png", alt="Input-Transformation-Output"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Anfrage->Webanwendung->Ausgabe;
    Input->Transformation->Output;
}
---------------------------------------------------------------------

.MVC-Muster und die Schichten einer Applikation
Das Clansuite Framework ist dabei als ein einfaches und klassisches Model-View-Controller (auch MVC genannt)
Framework konzipiert. Unter dem Model-View-Controller Aufbau versteht man den Einsatz von bestimmten
Entwurfsmustern (Design Patterns), um eine Applikation in Schichten (auch Layers oder Tiers) zu trennen.
Dieses Muster wurde entwickelt, um die Entwicklung im Bereich der Präsentationsschicht zu verbessern.

Das Model repräsentiert die Datenschicht. Regelmäßig wird innerhalb des Models eine Datenquelle angesteuert
und ihre Daten zurückgeliefert. Die Datenquelle kann dabei eine Datenbank und ihre Tabellen oder eine XML-
oder gar Textdatei sein.

Der View repräsentiert die Präsentationsschicht. Die Aufgabe der Präsentationsschicht ist es, die Daten,
welche sie vom Model bzw. Controller angereicht bekommt, aufzubereiten und auf eine bestimmte Ausgabeart
darzustellen. Zumeist arbeitet die Präsentationsschicht dabei mit sogenannten Ansichten (Views) die aus
Vorlagen (Templates) bestehen. Das View Objekt lädt dann das vom Controller zugewiesene Template und gibt es
aus. Als Ausgabeart kommt z. B. die Einbettung der Daten in XHTML-Quellcode Vorlagen in Betracht. Aber auch
eine Ausgabe der Daten im Format PDF oder RSS ist Aufgabe der Präsentationsschicht.

Der Controller ist für die Annahme einer Anfrage an die Webapplikation und damit für die Geschäftslogik
zuständig. Er untersucht die eingehenden Daten, welche regelmäßig in Form einer URI vorliegen, daraufhin,
welche Ansicht der Präsentationschicht mit Daten bestückt werden muss. Dabei können Controller hierarchisch
verbunden sein. Es entscheidet der erste Controller, welcher nachfolgende Controller für die Ansicht und ihre
Daten zuständig ist. Der Einstiegspunkt in die Webapplikation ist dabei zumeist die zentrale Datei index.php.
Die Datei ruft regelmäßig den Frontcontroller, also den Einstiegscontroller der Applikation auf, der einen
Subcontroller, zumeist einen Modulecontroller oder direkt einen Actioncontroller aufruft. Der Modulecontroller
repräsentiert die Geschäftslogik für alle Kommandos eines Moduls, also ein ganzes Kommandopaket. Der
Actioncontroller repräsentiert die Geschäftslogik für ein einzelnes Kommando innerhalb einer Applikation. Der
Frameworkaufbau von Clansuite untergliedert sich demnach in Komponenten der Präsentationschicht
(Frontcontroller mit Interception-Filtern, Eventhandler, sowie Template-View und Viewhelper Muster), der
Datenschicht (Active- Record Muster und objektrelationales Mapping mittels Doctrine) und der Geschäftslogik.
Das besondere Kennzeichen der Schichtenarchitektur ist die Tatsache, dass das Model weder die Views noch den
Controller kennt. Die Schichtentrennung ist wünschenswert, um die Hauptaufgaben einer Applikation austauschbar
zu machen und getrennt voneinander bearbeiten zu können. Hinzu tritt die Tatsache, dass es sich beim MVC-
Muster um eine Konvention, genauer um ein Ordnungsverfahren handelt, um die Arbeit mit komplexen Anwendungen
zu erleichtern und beherrschbar zu machen. Bedenkt man, dass Softwaresysteme regelmäßig an geänderte
Anforderungen angepasst werden müssen, dann ist der Siegeszug des MVC-Musters nicht verwunderlich. Die
Applikationsschichten sind getrennt voneinander wartbar, veränderbar, ergänzbar und austauschbar. Insbesondere
können die Schichten gleichzeitig und unabhängig voneinander bearbeitet werden.
Dies sichert die benötigte Weiterentwickelbarkeit (Evolvability).

.Das Model-View-Controller Entwurfsmuster
["graphviz", "chapter05_image02_mvc.png", alt="Model-View-Controller"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Input->Controller;
    Controller->Model;
    Model->Controller;
    Controller->View;
    View->Controller;
    Controller->Output;

    Input [shape=Mdiamond]
    Output [shape=Msquare]
}
---------------------------------------------------------------------

.Die Hilfskomponenten
Beim Framework sind neben den Mustern zur Umsetzung des MVC-Patterns noch die jeweiligen Hilfskomponenten zu
nennen. Für jeden MVC Bereich gibt es eigene Hilfskomponenten. Die Hilfskomponenten im Bereich des Controllers
sind zumeist Wrapperklassen, die Zugriffsmethoden auf fremde Bibliotheken bereitstellen. Ein Beispiel hierfür
wäre die Klasse Clansuite_Mailer, welche den Zugriff auf die Bibliothek SwiftMailer ermöglicht. Das Versenden
von Mails ist eine wesentliche, sich wiederholende Aufgabe. Der Mailer ist dafür verantwortlich, die
notwendigen Methoden zum Versenden von E-Mails bereitzustellen. Nicht jedes CMS Modul sollte aber dies
Funktionalität neu implementieren müssen, wenn das Versenden von E-Mails benötigt wird, daher wurde die
Funktionalität (hier Controller-Logik) in die Hilfskomponente ausgelagert. Hilfskomponenten kommen dabei aber
nicht nur im Bereich der Controller-Logik, sondern auch im Bereich des Views vor. Hier nennt man sie
Viewhelper. Die Viewhelper enthalten, Sie ahnen es bereits, wiederholend einsetzbare Präsentations-Logik. Der
Viewhelper "date" wird Sie beispielsweise dabei unterstüzen, den Datumsstring in das richtige Datumsformat
umzuwandeln und anzuzeigen. Im Bereich des Models stehen Behaviors und Event-Callbacks über Doctrine zur
Verfügung. Mit Behaviors ist es möglich, zwischen zwei oder mehreren Modellen gemeinsame Funktionalitäten
bereitzustellen. Mit Event-Callbacks ist es möglich, sich an den Moment, genauer das Ereignis, der Datenablage
dranzuhängen und gleichzeitig bestimmte andere Dinge auszulösen. Beispielsweise könnte man an das Ereignis
afterDelete($userid) das Loggen der Löschung eines Usersaccounts anhängen.

.Die MVC-Struktur im Überblick
["graphviz", "chapter05_image03_mvcstructure.png", alt="Clansuite MVC Structure"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Input->FrontController_Resolver;

    subgraph cluster_0 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Doctrine DBAL/ORM"
        Model->ModelHelper->Model;
    }

    subgraph cluster_1 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Render Engines"
        View->Layouttemplate->Subtemplates->Layouttemplate;
        View->ViewHelper->View;
    }

    subgraph cluster_2 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Controllers"
        FrontController_Resolver->FrontController;
        FrontController->ModuleController_Resolver->ModuleController;
        ModuleController->Model->ModuleController;
        ModuleController->ComponentHelper->ModuleController;
    }

    ModuleController->View;
    ModuleController->Output;

    Input [shape=Mdiamond]
    Output [shape=Msquare]
}
---------------------------------------------------------------------

.Der Applikationsfluss im Überblick
Eine Anforderungen an die Applikation nach dem MVC-Modell kann in fünf grundlegende Schritte unterteilt werden:

1. Ausgangspunkt ist der Empfang einer URL vom Client.
2. Das Routingsystem analysiert die URL und identifiziert den Controllernamen und sucht das Controllerobjekt.
3. Der Dispatcher ruft die Controllermethode auf dem Controllerobjekt auf.
4. Auswählen der Ansicht und Holen der Modelldaten, die von der Controllermethode zu dieser Ansicht generiert werden.
5. Das Rendern der Ansicht.

=== Architektur und Design des Frameworks

Das Framework ist objektorientiert programmiert (OOP) und folgt der Model-View-Controller Architektur (MVC).
Es werden Entwurfsmuster eingesetzt (DP). Objekte sollen nach Möglichkeit funktional eigenständig sein (Lose Kopplung).
Wir versuchen die Funktionalität der Komponenten mit Funktionstests zu sichern (TDD), siehe dazu auch Kapitel 9.
Wir legen Wert auf schrittweises, inkrementelles Wachstum (commit often).

==== Programmierprinzipien

===== Lose Kopplung

Unter dem Begriff "Lose Kopplung" vesteht man in der objektorientierten Programmierung, die Verringerung von Abhängigkeiten zwischen Objekten.
Abhängigkeiten zwischen Objekten entstehen, wenn ein Objekt auf einem weiteren Objekt eine Methode aufruft.
Das Prinzip der "Lose Kopplung" besagt, dass Objekte möglichst eigenständig sein sollen.
Die Befolgung dieses Prinzip hilft, Softwarefehler zu vermeiden, die aufgrund von Kopplungs- und Kommunikationsbeziehungen zwischen Objekten entstehen.
Im englischen Sprachraum ist dieses Prinzip auch als das Gesetz von Demeter (engl. Law of Demeter) bekannt.

Im Programmierslang ist dieses Prinzip gemeint, wenn von den "schüchternen Objekten" (engl. shy-objects / shy-programming) gesprochen wird oder,
im Bezug auf Objekte etwa Satze wie "Sprich nicht mit Fremden!" oder besser noch "Sprich nur mit Deinen Freunden!" (engl. only talk to your friends) fallen.
Das Gesetzt von Demeter beinhaltet einige unbedenkliche Fälle von Abhängigkeiten zwischen Objekten.
Eine Objektmethode darf demnach immer eigene, aber die Methoden eines anderen Objekts nur in 3 Fällen aufrufen:
Fall 1:: Methodenaufruf auf dem eigenen Objekt
Fall 2:: Methodenaufruf eines assoziierten/referenzierten Objekts
Fall 3:: Methodenaufruf auf einem Objekt, welches durch Parameterübergabe in die Methode oder das Objekt gelangt ist
Fall 4:: Methodenaufruf auf einem Objekten, welches die Methode selbst erzeugt hat

[source, php]
---------------------------------------------------------------------
/**
 * Fall 1 - Es wird eine Methode auf dem eigenen Objekt aufgerufen.
 */
class KlasseA
{
    public function methode1()
    {
        $this->method2(); # Aufruf der objekteigenen Methode
    }

    public function methode2()
    {

    }
}

/**
 * Fall 2 - Es wird eine Methode auf einem Objekt aufgerufen,
 *          welches durch Parameterübergabe in die Methode oder das Objekt gelangt ist.
 */
class KlasseA
{
    public function methode1(KlasseB $b) # Das Objekt wird per Parameter übergeben.
    {
        $b->methode2(); # auf dem übergebenen Objekt erfolgt der Parameteraufruf
    }
}

class KlasseB
{
    public function methode2()
    {
    }
}

/**
 * Fall 3 - Es wird eine Methode auf einem assoziierten/referenzierten Objekt aufgerufen.
 */
class KlasseA
{
    private $b; # Instanz des Objekts KlasseB

    public function methode1()
    {
        $this->b->methode2(); # Aufruf der Methode methode2() auf Objekt B
    }
}

class KlasseB
{
    public function methode2()
    {
    }
}

/**
 * Fall 4 - Es wird eine Methode auf einem Objekt aufgerufen, welches die Methode selbst erzeugt hat.
 */
class KlasseA
{
    public function methode1()
    {
        $b = new KlasseB(); # Instanzierung von Objekt B
        $b->methode2();     # Aufruf der Methode methode2() auf Objekt B
    }
}

class KlasseB
{
    public function methode2()
    {

    }
}
---------------------------------------------------------------------

Das Gesetz von Demeter entstand während des Demeter-Softwareprojekts an der University von Boston und wurde von Karl J. Lieberherr und
Ian Holland im Jahr 1989 im Aufsatz "Assuring Good Style for Object-Oriented Programs" erläutert
footnote:[http://www.ccs.neu.edu/home/lieber/what-is-demeter.html]. Wer erfahren will, warum das Gesetz nach der griechischen Göttin für
Landwirtschaft und Fruchtbarkeit benannt wurde, der ist eingeladen im besagten Aufsatz nachzulesen.

Wie hoch der Grad an Kopplung ist, kann mittels statischer Quellcodeanalyse festgestellt werden.
Regelmäßig gibt die Maßzahl names "LoD" einer Softwaremetrik an, wie hoch die Kopplung zwischen Objekten ist.
In der Praxis ist es nicht immer sinnvol dieses Prinzip vollständig zu beachten, da durch die Verringerung der Abhängigkeiten
oft viele Wrapperklassen oder Weiterleitungsmethoden entstehen.

===== Schrittweises inkrementelles Wachstum

Das Framework wird schrittweise entwickelt. Dieses Verfahren wird auch durch das Demeter-Projekt nahe gelegt, wonach
Software sich in ihrem Wachstum an der Natur orientieren sollte.

===== Dependency Injection und Inversion of Control

Für eine umfassende Beschreibung des Dependecy Injection Verfahrens verweise ich auf den Artikel von Martin Fowler
http://martinfowler.com/articles/injection.html.

=== Die Komponenten des Frameworks

==== Clansuite_Bootstrap

Bootstrapping bedeutet umgangssprachlich "Sich an den eigenen Haaren aus dem Sumpf ziehen".
Diese Metapher geht auf eine Geschichte des Barons von Münchhausen zurück, der sich und sein Pferd
allein durch die inneren Kräfte seines Arms aus dem Morast befreite.

Ein meiner Meinung nach besseres Bild für den Startprozess ist, dass Anstoßen des ersten Dominosteins.
Die Beschaffenheit des Dominosteins ist dabei relativ gleichgültig, solange er in der Lage ist seine Kraft
an den nächsten Stein weiterzugeben. Es kann ein Buch oder ein Dachziegel sein. Es entsteht eine Kausalkette.

Im Kontext von Softwaresystemen steht Bootstrapping für die Technik hinter dem Startvorgangs eines komplexeren Systems.
Jeder kennt diesen Vorgang vom Starten des eigenen Rechners. Am Anfang muss dieser "Booten", d.h. es werden grundlegende Operationen
durchgeführt, beispielsweise Hardware geprüft und initialisiert, damit diese dem Betriebsystem später zur Verfügung stehen.
Bootstrapping ist daher kein Anteil der eigentlichen Applikation, sondern bereitet nur deren spätere Lauffähigkeit vor.
Läuft die Applikation einmal, braucht sie kein Wissen darüber, wie es eigentlich dazu gekommen ist.

Im Kontext von Webanwendungen beschäftigt sich Bootstrapping mit den zwingenden Systemanforderungen, beispielsweise der Prüfung auf
die richtige PHP Version, das Laden von Extensions und Konfigurationsdateien, sowie dem Definieren von Konstanten. Ist dieser Vorgang
abgeschlossen, wird die Kontrolle an die Applikation übergeben. Regelmäßig ist dies der Frontcontroller, der sodann mit der Abarbeitung des
Requests beginnt.

==== Clansuite_Autoloader

Was macht überhaupt das Autoloading? Grundsätzlich ist ein Laden der entsprechenden Datei (require/include) mit der entsprechenden Klasse
und die Instanzierung dieser Klasse notwendig. Das Autoloading zieht nun den ersten Schritt ab, indem anhand eines Klassennamens die richtige Datei geladen wird.
Damit ist das grundlegende Problem beim Autoloading angezeigt: die Pflege einer Zuordnungstabelle (Autoloading-Map), die sowohl Datei- als auch Klassennamen beinhaltet und eine Suche
der richtigen Datei anhand des Klassennames ermöglicht. Bei diesem Verfahren steht die Methode des require(dirname(__FILE__).'.php') im Vordergrund. Hierbei wird
explizit auf einen bestimmten Ort im Dateisystem verwiesen und dies unabhängig vom Klassennamen.

Für einen Programmierer ist Autoloading in gewisser Hinsicht bequem, da er nicht den Ort der Klasse wissen und sie nicht laden muss.

Regelmäßig enthalten die Klassennamen Unterstriche als logische Trennzeichen und geben damit die Verzeichnisstruktur an.
Einfache Autoloadinglösungen verwenden daher im Kern immer str_replace('_','/', $classname). '.php'; um aus dem Klassennamen einen Dateinamen mit
ausreichenden Pfadinformationen zu erzeugen.

[source, php]
---------------------------------------------------------------------
    /**
     * An autoload function for MyApp
     * @param string
     */
    public static function MyAppAutoload($classname)
    {
        if (strpos($className, 'MyApp_') === 0)
        {
            $classname = substr($classname, 6);
            $path = str_replace('_', '/', $classname) . '.php';
            if (is_file(dirname(__FILE__) . '/' . $path) === true)
            {
                include dirname(__FILE__) . '/' . $path;
            }
        }
    }
---------------------------------------------------------------------

Schwieriger wird es, wenn man Dateien nach ihrer Zugehörigkeit zu einer logischen Komponente ablegen möchte.
Nun muss der Name der Komponente mit in den Klassennamen, um ihn in einen Dateinamen umwandeln zu können.
Dies führt zu komponentenbasiertem Autoloading. 

Ein weiteres Problem ergibt sich, wenn in einer Datei mehrere Klassen untergebracht sind.
Hier kann nicht vom Klassennamen auf die Datei geschlossen werden.

Der extensiven Verwendung des Autoloadings mit langen Klassennamen wird nun durch die Einführung der Namespaces etwas entgegengewirkt.
Hierdurch werden lediglich wiederkehrende Prefixes vom Klassennamen abgezogen und als Namespaces deklariert.
Ebenso wird es nun möglich Slashes in den Namespaces zu verwenden. Dies geht bei Klassennamen nicht.

Die beste Autoloading Lösung besteht darin, im Voraus das komplette Dateisystem auf PHP Dateien und enthaltene Klassen zu scannen
und eine Autoloading-Map zu erstellen. Professionelle Systeme integrieren diesen Schritt in den Build-Prozess der Applikation und
lagern ihn somit aus der Applikation aus. Das Autoloading besteht bei dieser Lösung aus einem reinen Lookup des Klassennames in einem Array
mit Klassennamen als Schlüsseln und Pfad- und Dateinamen als Werten.

Merksätze zum Thema Autoloading: Autoloading ist für Bequeme und Bequemlichkeit bringt Probleme.

Clansuite verwendet ein zweistufiges Autoloading. Im ersten Schritt wird versucht die Datei anhand des Klassennames zu finden.
Sollte dies erfolgreich sein, wird die Klassenname-Datei-Beziehung in eine Autoloading Map eingetragen. Bei jedem weiteren Autoloading
erfolgt dann nur noch ein Lookup und keine Auflösung des Klassennames in den Dateinamen. Die Namensauflösungsstrategie deaktiviert sich 
also schrittweise und es wird ein reiner Lookup-Betriebsmodus erreicht wird.

==== Clansuite_HttpRequest

Die Klasse Clansuite_HttpRequest abstrahiert den Zugriff auf die Daten einer HTTP-Anfrage. Unter einer HTTP-
Anfrage versteht man den gesamten eingehenden Datenstrom (auch Input genannt) einer Anwendung. Bei einer HTTP-
Anfrage sind die Daten grundsätzlich über die superglobalen Variablen ($_REQUEST, $_POST, $_GET, $_COOKIE,
$_SERVER, $_FILES und $_ENV) zu erreichen. Diese Variablen werden allerdings von PHP unbereinigt und als
konkrete Implementierung bereitgestellt. Die Hauptaufgabe der Klasse Clansuite_HttpRequest besteht daher in
der Bereinigung der superglobalen Variablen $_REQUEST, $_POST, $_GET, $_COOKIE, $_SERVER, $_FILES, $_ENV und
dem Anbieten von Methoden zum Abruf der bereinigten Arrays. Die eingehenden Daten werden nicht direkt aus der
PHP- Umgebung, sondern über einen Umweg, nämlich aus dem HttpRequest Objekt geholt. Ein direkter Zugriff auf
die unbereinigten globalen Variablen (raw data) ist weiterhin möglich, sollte aber aus Sicherheitsgründen
vermieden werden. Eine weitere Aufgabe der Klasse besteht darin, die Effekte des "magic quoting" zu
beseitigen.

.Das Clansuite_HttpRequest Objekt
["graphviz", "chapter05_image04_httprequest.png", alt="Clansuite HttpRequest Object"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Input->struct1:webserver;
    struct1:php->struct2:httprequest->Controller;
    Controller->struct2:httprequest;

    struct1 [label="<webserver> Webserverumgebung  | {<php> PHP | { ENV | SERVER | GET | POST | REQUEST | COOKIE } }"];

    struct2 [label="<httprequest> HttpRequest | PHP Intrusion Detection System | { ENV | SERVER | GET | POST | REQUEST | COOKIE }"];

    Input [shape=Mdiamond]
}
---------------------------------------------------------------------

.Sicherheit mittels Clansuite_Doorkeeper
Des weiteren wird mittels der Klasse Clansuite_Doorkeeper (Türsteher) versucht Einbruchsversuche in die
Webanwendung zu erkennen und potentiellen Eindringlingen den Zugang zum System zu verweigern. Als System zur
Einbruchserkennugn wird das PHP Intrusion Detection System (PHPIDS) eingesetzt. PHPIDS wird seit Mai 2007 von
Mario Heiderich, Christan Matthies und Lars Strojny entwickelt. Es untersucht die Benutzereingaben auf
schadhafte Zeichen, Zeichenketten oder Skriptanteile. Erkannt werden XSS-Angriffe (Cross-Side-Scripting), SQL-
Injektionsversuche (SQLI), Remote File Inclusions, Remote File Executions (RFE) und LDAP-Injektionen.

.Bereitstellung der REST-Funktionalität
Eine weitere wesentliche Aufgabe ist die Bereitstellung der REST-Funktionalität. Die Abkürzung REST steht für
den Fachbegriff Representational State Transfer. REST ist ein Softwarearchitekturstil, welcher ein
resourcenorientiertes Denken forciert und für verteilte Applikationen entwickelt wurde. Es ist absichtlich
sehr einfach gehalten und basiert nur auf wenigen Grundprinzipien und wohldefinierten Methoden. Der Begriff
wurde durch die Dissertation von Roy Fielding aus dem Jahr 2000 eingeführt. Fielding ist einer der
Hauptautoren der Spezifikation des HTTP-Protokolls. Er ruft nochmals in Errinerung was die bestehende
Mechanismen und Protokolle des WWW (z. B. HTTP) teilweise schon definieren. REST ist neben den Alternativen
XML-RPC und SOAP eine Methode zur Umsetzung von Webservices und damit ein
Schlüsselwort des Web2.0.

.Rest-Grundprinzipien
Nachfolgend werden die Grundprinzipien von REST dargestellt.

1 Alles ist eine Resource::
    Eines dieser Prinzipien lautet "Alles ist eine Resource". Resource ist dabei jede Datenquelle.
    Einige werden hier eine Ähnlichkeit zum Linux-Prinzip "Alles ist eine Datei." feststellen.

2 Name (URI)::
    Jede Resource hat einen eindeutigen Namen.

3 Links::
    Jede Resource ist mittels eines Hyperlinks ansprechbar.

4 Verben (CRUD)::
    Die Methoden von REST sind einfache und selbstverständliche Verben.
    Für den Zugriff auf eine Ressource stehen die folgenden Methoden zur Verfügung:
    Create (POST), Read (GET), Update (PUT), Delete (DELETE).

5 Representation::
    Resourcen können mehrere Representationen haben.
    So kann die Ressource "Benutzerliste" sowohl in HTML, XHTML, CSV oder PDF repräsentiert werden.

6 Zustandslose Kommunikation (Skalierbarkeit)::
    Die Kommunikation mit dem Server einer Ressource beschränkt sich jeweils auf eine einzelne Anfrage. Der Server
    erwartet also keinen Kommunikationsvorgang bei dem Daten einer vorherigen Anfrage zwischengespeichert werden
    müssen. Letzteres würde dazu führen, dass mit steigender Anzahl an Anfragen die Serverlast steigt, da für
    jeden Client die Daten zwischen zwei oder mehreren Anfragen vorgehalten werden müssen. Berücksichtigt man nun
    die darunterliegenden zustandslosen Protokolle, wie HTTP und und fördert die Entdeckung und Verwendung der
    Resourcen. Führt dies dazu, dass wesentlich mehr Clients auf den Server zugreifen können, da die
    Serverresourcen geschont werden. Eine zustandslose Kommunikation erhöht also die Skalierbarkeit.

7 Schichtenaufbau::
    REST ist in Schichten aufgebaut. Dabei kann eine beliebige Anzahl an Zwischenebenen oder intelligenten
    Zwischendiensten, wie z. B. Caches, Proxies oder Gateways eingesetzt werden.

footnote:[Fielding, Roy Thomas: Architectural Styles and the Design of Network-based Software Architectures.
PhD Thesis, University of California, Irvine, 2000, http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm]
footnote:[Atom Publishing Protocol (RFC5023), http://www.ietf.org/rfc/rfc5023.txt]
footnote:[HTTP/1.1 Specifiction (RFC 2616), http://www.w3.org/Protocols/rfc2616/rfc2616.html]
footnote:[Yahoo! Group: rest-discuss, http://tech.groups.yahoo.com/group/rest-discuss/]
footnote:[http://restpatterns.org/]
footnote:[Alan Dean, http://www.simplewebservices.org/]
footnote:[Stefan Tilkov, http://rest-http.info/, Webseite zum Buch "REST und HTTP".]
footnote:[REST URL Conventions, http://microformats.org/wiki/rest/urls/]

.Instanzierung

Die Klasse wird bei Systeminitialisierung dem Dependency Injector übergeben und steht sodann in dessen
Registry zum Abruf bereit.

Das HttpRequest Objekt kann auf zwei Arten geholt werden. Erstens ist ein systemweiter Zugriff auf das Objekt
durch den Zugriff auf den Dependency Injector gegeben.

[source, php]
---------------------------------------------------------------------
# Holen des Objekts HttpRequest aus dem Dependecy Injector
$request = $this->injector->instantiate('Clansuite_HttpRequest');
---------------------------------------------------------------------

Zweitens kann in einer Klasse sind die sich vom Modulecontroller ableitet (das wird regelmäßig ein
ActionController sein) das Objekt mittels der Methode this->getHttpRequest() des ModuleControllers geholt
werden. Diese Methode ist eine Befehlsabkürzung (engl. auch Shortcut, Proxy oder Convenience Methode genannt).

[source, php]
---------------------------------------------------------------------
# Holen des Objekts HttpRequest innerhalb einer Kindklasse des ModuleControllers
$request = $this->getHttpRequest();
---------------------------------------------------------------------

.Verwendung

[source, php]
---------------------------------------------------------------------
# Holen des Objekts für einmalige Verwendung und holen des Parameters "stadt" (Method Chaining/Fluent Interface)
$stadt = $this->getHttpRequest()->getParameter('stadt');

# Holen des Objekts HttpRequest (für mehrmalige Verwendung)
$request = $this->getHttpRequest();

# Holen des Parameters 'news_category_form' aus dem Request Objekt.
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form');

# Holen des Parameters 'news_category_form' aus dem Request Objekt unter Angabe des Arraynames "REQUEST".
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form', 'REQUEST');

# Holen des Parameters 'news_category_form' aus dem Request Objekt unter Angabe des Shortcuts "R" für den Arraynamen.
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form', 'R');

# Holen des Parameters 'hausnummer' aus dem Request Objekt.
# Der Parameter wird mittels Shortcut "G" aus dem Array $get_parameters des Request Objekts geholt.
$haus_nr = $request->getParameter('hausnummer', 'G');

# Holen des Parameters ['news_form_categories]['cat_id'] unter Verwendung von ArrayAccess.
$cat_id = $request['news_form_categories]['cat_id];
---------------------------------------------------------------------

Hinweis: der Zugriff auf mehrdimensionale Arrays wird durch die Verwendung von ArrayAccess erheblich
vereinfacht. ArrayAccess bedeutet, dass ein Objekt und seine Eigenschaften auf die gleiche Art und Weise
angesprochen werden können, wie ein Array. So können auch Unterarrays und deren Schlüssel einfach angesprochen
werden.
Bei Übergabe von mehrdimensionalen Formulardaten empfiehlt sich die Verwendung von ArrayAccess besonders.

[source, php]
---------------------------------------------------------------------
# Das HTML-Formular beinhaltet ein Name Attribut mit mehrdimensionalem Aufbau.
# Dadurch werden die Daten als mehrdimensionales Array an den Server geschickt.
<input type="text" name="formular[1][variablename]" value="0"/><br />

# Das Array hat die folgende Struktur:
array( [formular] => array ( [1] => array( [variablenname] => 'wert' ) ) )

# Der Zugriff erfolgt über $request mittels ArrayAccess:
$variablenname = $request['formular']['1']['variablenname'];
---------------------------------------------------------------------

==== Clansuite_Doorkeeper

In unmittelbarem Zusammenhang mit den Sicherungs- und Bereinigungsfunktionen der HttpRequest-Klasse
steht die Klasse Clansuite_Doorkeeper.

.Instanzierung

Die Klasse wird innerhalb der HttpRequest-Klasse instanziert.

.Verwendung

Die Hauptmethode dieser Klasse ist runIDS(). Sie bewirkt die Initialisierung und den Start des Intrusion-
Detection-Systems (PHPIDS). Mehr über die Funktionsweise von PHPIDS erfahren sie im Kapitel 10.

==== Clansuite_HttpResponse

Die Klasse Clansuite_HttpResponse übernimmt die Funktion einer abstrakten Ausgabeklasse. Sie sendet die
notwendigen HTTP-Header, aktiviert die GZip-Kompression und gibt den gesamten Content ($body) an den Client
aus. Die Klasse ist für den Output zuständig.

.Instanzierung

.Verwendung

==== Clansuite_Front_Controller

Was ist überhaupt ein Frontcontroller? Der Frontcontroller nimmt die Anfrage (Request) entgegen und
leitet sie an den entsprechenden Module-Controller bzw. Action-Controller weiter.
footnote:[http://www.martinfowler.com/eaaCatalog/frontController.html, Martin Fowler - FrontController im eaaCatalog]
footnote:[http://java.sun.com/blueprints/corej2eepatterns/Patterns/FrontController.html, J2EE Pattern FrontController]
Wenn eine Webanwendung nach dem FrontController Muster aufgebaut ist, dann erkennt man das meistens daran, dass
zum Starten der Anwendung die zentrale "index.php" aufgerufen wird. Diese "index.php" wird dann mit Parametern
ergänzt, die Modulecontroller und Actioncontroller angeben. Etwa "index.php?module=news&action=AlleNewsAnsehen".

Clansuite wird durch Aufruf der zentralen Einstiegsdatei "index.php" gestartet. Der Aufruf des
Frontcontrollers erfolgt nach der Initialisierung des Systems in der
Datei "/core/bootstrap/clansuite.application.php".

Die beiden Absätze in der Notiz haben wenig bis gar nichts mit dem Clansuite_Front_Controller zu tun.
Sie sind vielmehr ein kleiner Exkurs in die Geschichte der Internetanwendungen und der Clanscripte.
Wer nicht daran interessiert ist, kann sie daher auch gerne überspringen.

.Exkurs
[NOTE]
===============================
Eine Alternative zur Verwendung eines Frontcontroller sind dezentrale Controller.
Dazu muss eine Anwendung in dezentrale Bereiche untergliedert werden, die jeweils eine eigene Einstiegsdatei
anbieten. In den Anfangstagen des persönlichen dynamischen Webs, so zwischen 1998 und 2004, waren dezentrale Controller
der Normalfall. In dieser Zeit hat man eine dynamische Webseite zumeist aus mehreren Skripten zusammengestellt.
So verwendete man ein Skript für die News und ein Skript für das Gästebuch.
Jedes dieser Skripte wurde in einem eigenen Verzeichnis untergebracht und über einen eigenen
Controller aufgerufen. Die URL sah typischerweise wie folgt aus: "/news/index.php" oder "/guestbook/index.php".
Häufig hat man dann versucht, die verschiedenen Skripte irgendwie miteinander zu verbinden, um sich beispielsweise
nicht bei jedem einzelnen Skript zur Administration anmelden zu müssen.

Im Clanbereich war das dezentrale Controller-Musters auch anzutreffen.
Ein damals bekanntes Clanscript mit dezentraler Controllerstruktur war das "TClanPortal"
von Martin Weitzel (aka TriggerTG). Es war auch bekannt unter dem Namen "TriggerTG's Clanportal"
und stand auf den Domains http://www.clanportal.org/ und http://www.triggertg.de/ zum kostenlosen Download bereit.
Das System war, obwohl es zahllose Sicherheitslücken gab, recht begehrt in der Szene und verbreitete sich rasch.
Die Entwicklung wurde im Jahr 2004 aus Zeitgründen eingestellt. Die letzten Version war 1.1.3.
Frank Hermann (aka Devil) nahm schließlich die Weiterentwicklung des Systems auf. Heute ist es besser bekannt
unter dem Namen "Devil's Clanportal", abgekürzt DZCP. Die dezentrale Controller-Struktur ist auch in der aktuellen
DZCP Version 1.5.1 im Jahr 2010 immernoch im Einsatz.
===============================

Inzwischen sind dezentrale Controller durch die Verwendung des Frontcontroller-Musters verdrängt worden.
Einzelne Skripte sind kaum noch anzutreffen und ihre Funktionalität wird heute zumeist durch die jeweiligen
Module einer Webanwendung repräsentiert.

.Ein einfacher Frontcontroller
["graphviz", "chapter05_image05_simplefrontcontroller.png", alt="Clansuite Simple Frontcontroller Workflow"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]
    HttpRequest->struct1:FC;
    struct1:pR->ModuleController->ActionController->HttpResponse;
    struct1 [label="<FC> FrontController | { <pR> processRequest }"]
}
---------------------------------------------------------------------

Was ist ein ModuleController bzw. ApplicationController?
Bei Clansuite nennen sich ApplicationController ModuleController.
Sie sind zuständig für einen kompletten Teilbereich des CMS.
Beispielsweise das Modul zur Verwaltung von Artikeln (News).
footnote:[http://www.martinfowler.com/eaaCatalog/applicationController.html]

Was ist ein ActionController?
ActionController ist ein Kommando der Applikation.
Beispielsweise das Kommando action_show() im Modul News.
Wird dieses Kommando ausgeführt, so bewirkt es die Anzeige aller gespeicherten Artikel des News-Moduls.

Clansuite setzt nicht nur einen einfachen FrontController ein.
Der FrontController, mit seiner Hauptmethode processRequest(), wird durch Vor- und Nachfilter erweitert.
Siehe dazu unter Clansuite_Filtermanager.

.Das Clansuite Frontcontroller Objekt
["graphviz", "chapter05_image05_startfrontcontroller.png", alt="Clansuite Frontcontroller Start"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    struct1 [label="<FC> FrontController | HttpRequest | HttpResponse | DependencyInjector | { { Prefilter | <preF> addPreFilters } | <pR> processRequest | { Postfilter | <postF> addPostFilters } }"]
}
---------------------------------------------------------------------

Dieses Bild zeigt das Frontcontroller Objekt nach dem Aufruf der Methode Clansuite_CMS::execute_Frontcontroller()
innerhalb von /bootstrap/clansuite.application.php.

Dem Frontcontroller werden der ModuleController_Resolver und der ActionController_Resolver,
sowie der Dependency Injector übergeben.
Die in einem Konfigurationsarray befindlichen Vor- und Nachfilter werden dem Frontcontroller
mittels der Methoden addPreFilter() und addPostFilter() hinzugefügt.
Durch Aufruf der Methode processRequest($request, $response) werden Request und Response Objekt
an den Frontcontroller übergeben. Die weitere Bearbeitung des Requests obliegt nun dem Frontcontroller.

.Der Ablauf im Frontcontroller - Clansuite_Front_Controller::processRequest()
[source, txt]
---------------------------------------------------------------------
1. Den richtigen ModuleController ermitteln
   Dazu Clansuite_Controller_Resolver befragen
2. Vorfilter abarbeiten
3. Dependency Injector an den ModuleController weitergeben
#. Hinzufügen eines ActionControllers mit dem ModuleDecorator
4. Aufruf des ModuleControllers
5. Aufruf des ActionControllers
6. Nachfilter abarbeiten
#7. fetches view / implicit getRenderEngine
#8. assign view to response / implicit getTemplate
9. Ausgabe
---------------------------------------------------------------------

Das Schema verdeutlich, wie die Methode processRequest() des Frontcontroller vorgeht.
Dabei geht es zunächst darum, aus dem eingehenden Request den richtigen ModuleController herauszufinden.
Dazu dient das ModuleController_Resolver Objekt.
Damit im ModuleController die Kernkomponenten zur Verfügung stehen, wird der
DI an den Modulecontroller weitergegeben (3).

Danach geht um den Aufruf des ModuleControllers (4) und des ActionControllers (5).
Der ActionController wird wiederrum mittels des ActionController_Resolvers ermittelt.

Dieser wird umlagert von der Ausführung der Vor- und Nachfilter.
Die Abarbeitung der Vorfilter (2) bewirkt möglicherweise eine Modifikation des Request Objekts.
Die Abarbeitung der Nachfilter (6) bewirkt möglicherweise eine Modifikation der Ausgabe
bevor sie ins Response Objekt gegeben wird.

Der ActionController bestimmt die Ausgabeengine und übergibt die Daten die ausgegeben werden sollen.
Um die Ausgabe zu bewirken (9), ruft der Frontcontroller die Methode flush() des HttpResponse Objekts auf.

==== Clansuite_Filtermanager

Der Filtermanager ist eng mit dem Frontcontroller verwoben. Jedem Aufruf der Hauptmethode processRequest() des
Frontcontrollers können ein oder mehrere Vorfilter vorgeschaltet oder ein oder mehrere Nachfilter
nachgeschaltet werden. Um diese Funktionalität im Frontcontroller abzubilden wurden die zwei Variablen
$preFilters und $postFilters erstellt, welche jeweils eine Instanz des Filtermanager Objekts enthalten. Der
Filtermanager stellt nur sehr wenige Methoden bereit. Hauptsächlich geht es darum Filter zu registrieren und
auszuführen. Zum einen stellt er die Methode addFilter() bereit. Mit ihr lassen sich neue Filter hinzuzufügen.
Sie akzeptiert Objekte, welche das Filter Interface implementieren, und somit vom Typ Filter sind. Die
Hauptmethode des Filtermanagers ist processFilters(). Sie iteriert über alle registrierten Filter und führt
sie aus. Die Iteration folgt dabei der Reihenfolge der Registrierung.

.Entwurfsmuster

*Frontcontroller*
Die Klasse Clansuite_Filtermanager ergänzt den Frontcontroller.
Der Frontcontroller kann eine Anfrage nur an den ModuleController und weitere Untercontroller weiterreichen,
um sie zu beantworten. Neue Funktionen könnten nur durch Änderung eines bestehenden oder hinzufügen eines
neuen Controllers geschaffen werden.

*Interception-Filters*
Das Entwurfsmuster Intercepting-Filter hilft weiter.
footnote:[http://java.sun.com/blueprints/corej2eepatterns/Patterns/InterceptingFilter.html]
Damit lässt sich die Hauptmethode processRequest() mit einem
Vorprozess und einem Nachprozess umhüllen. Ein Vorprozess ist in der Lage die Anfrage zu verändern.
Ein Nachprozess ist in der Lage die Ausgabe zu beeinflussen. Dadurch können beliebig viele Filter
hinzugefügt oder wieder entfernt werden, ohne den Code des Frontcontrollers ändern zu müssen.

Beim Intercepting-Filter-Musters implementiert jeder Filter das Filterinterface.
Die Filter sind wiederverwendbar, sequenziell aufrufbar und lose an die Geschäftslogik und andere Filter gekoppelt.
In der Java-Welt gibt es seit Version 2.3 der Servlet Spezifikation, ein Standardinterface Filter
footnote:[http://java.sun.com/products/servlet/Filters.html].
Eine Intercepting-Filter-Implementation als Teil der PHP-SPL sucht man leider vergeblich.

.Der mit Interception-Filtern erweiterte Frontcontroller
["graphviz", "chapter05_image06_frontcontrollerwithfilters.png", alt="Clansuite Frontcontroller with Interception Filters"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    HttpRequest->struct1:FC;
    struct1:pR->HttpResponse;

    subgraph cluster_0
    {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        struct1 [label="<FC> FrontController | { <preF> Vorfilter | <pR> processRequest | <postF> Nachfilter }"]
   }
}
---------------------------------------------------------------------

===== Das Filter Interface

Jeder Filter implementiert das Filter Interface (implements Clansuite_Filter_Interface).
Damit wird sichergestellt, dass der konkrete Filter alle Methoden eines abstrakten Filters bereitstellt.
Dazu gehört inbesondere das Vorhandensein der Hauptmethode executeFilter().

===== Übersicht zu den Filtern

.Vorfilter

1. Theme_via_get
2. Language_via_get
3. Statistic
4. Startup_checks
5. Set_modulelanguage
6. Maintenance
7. Ajax Request
8. Get User
9. Permissions
10. Php_debug_console
11. Session security
12. Process cronjobs

.Nachfilter

1. Html Tidy
2. Smarty Moves

TIP: Die Erstellung eines Filters um den Output zu komprimieren ist nicht erforderlich. Diese Aufgabe wird durch die Klasse Http_Response gehandhabt.

==== Clansuite_Configuration

.Instanzierung

.Verwendung
[source, php]
---------------------------------------------------------------------
$config = $this->config->readConfig( ROOT_MOD . '/news/news.config.php');
# Der obige Aufruf entspricht dem im Modulecontroller verfügbaren Shortcut-Kommando:
$config = $this->getModuleConfig();
---------------------------------------------------------------------

.Entwurfsmuster

===== Die Configuration-Adapter

====== Configuration: YAML

.Allgemeines zum YAML-Format

Das YAML Konfigurationsformat ist relativ minimalistisch und basiert auf Textdateien.
Die offiziellen Webseite definiert YAML (YAML Ain't Markup Language), als einen menschenlesbaren,
programiersprachenübergreifenden Standard zur Datenserialisierung.
Es wurde entwickelt, um die Lesbarkeitsschwierigkeiten aufgrund von Klammerung und Verschachtelung
bei PHP-Arrays und anderen Ausdrucksmitteln für Konfiguration zu umgehen.
Ziel war eine Konfigurationsprache zu schreiben, die auch für Nicht-Programmierer lesbar und einfach einzusetzen ist.
Die offizielle Webseite ist http://yaml.org/.
Die Spezifikation von YAML Ain’t Markup Language vor finden sie unter http://www.yaml.org/spec/1.2/spec.html.
Seit dem 1.Oktober 2009 liegt nunmehr die Version 1.2 der Spec vor.

Beim YAML-Format wird durch Einrückungen des Text eine Struktur erzeugt.
Um eine Textdatei des YAML-Formats zu lesen und die in ihr enthaltenen Zeichenketten wieder
in eine Arraystruktur mit Schlüsseln und Werten zu verwandeln ist ein Parser notwendig.
Der YAML-Parser wertet dabei insbesondere die zur Strukturierung des Konfigurationstextes dienenden Leerzeichen aus.

.Vergleich der Konfiguration mittels PHP-Array und YAML
[source, php]
---------------------------------------------------------------------
# definition als php-array
$configuration = array(
    'konfigurationssektion' => array(
                                     'element1' => 'wert1',
                                     'element2' => 'wert2',
                                     'element3' => 'wert3'
                                    )
                      );

# definition als yaml

konfigurationssektion:
  element1: wert1
  element2: wert2
  element3: wert3
---------------------------------------------------------------------

Das YAML-Format wurde in der PHP-Welt insbesondere mit Aufkommen des PHP-Frameworks Symfony sehr populär, wo es standardmäßig eingesetzt wird.
Der dort entstandene Parser implementiert einen Großteil der YAML 1.1 Spezifikation und wird als eigenständige
Bibliothek sfYaml weiterentwickelt. Fabien Potencier der Symfony-Gründer wird nicht müde, diese Klasse und das Format zu bewerben.

Ein Serialisierungsformat das auf YAML beruht ist JSON.

TIP: Wer YAML sagt, meint auch oft das von Dirk Jesse entwickelte (X)HTML/CSS Framework mit dem Namen "Yet Another Multicolumn Layout".
Es ist ein sehr komfortables Layoutgerüst unter CC-A 2.0 Lizenz. Sie finden das YAM-Layoutprojekt unter http://www.yaml.de/ und
weitere Projekte des Autors unter http://www.highresolution.info/webdev/.

.Arbeitsweise des Konfigurationsadapters YAML

Der Konfigurationsadapter YAML erweitert die Basisklasse Clansuite_Config_Base und implementiert das ArrayAccess Interface.
Die beiden Hauptmethoden sind readConfig() und writeConfig(). Nach erfolgreichem readConfig() kann ein Zugriff per ArrayAccess erfolgen.
Es ist ein Wrapper der zwei Parser-Bibliotheken umspannt. Primär untersützt der Wrapper die in C-geschriebene PHP-Extension SYCK.
Diese ist über PECL verfügbar. Sollte diese PHP-Extension nicht verfügbar sein, so wird sekundär, auf die PHP-Bibliothek SPYC zurückgegriffen.
SPYC muss dazu in das Verzeichnis /libraries/spyc/ installiert werden.

====== Configuration: DB

====== Configuration: INI

====== Configuration: XML

==== Clansuite_Renderer

Für die Präsentationsschicht ist die Klasse Clansuite_Renderer zuständig. Diese ist Bestandteil des Applikationskerns.

Jeder Rückgabewert des Systems ist ein Output und wird über die Response-Klasse abgewickelt.
Nur Fehlerausgaben werden nicht über die Response-Klasse, sondern direkt ausgegeben.
Die Contentzuweisung an die Response-Klasse wird durch eine Methode zur Ausgabevorbereitung veranlasst.
Diese setzt regelmäßig eine bestimmte RenderEngine ein, um den Output aufzubereiten.
RenderEngines umfassen dabei Ausgabeformate und TemplateEngines.
Hinzu kommt die direkte Ausgabe mit PHP und über den HTTP-Header.

Folgende Ausgabeformate werden zur Zeit von Clansuite unterstützt:
CVS, JSON, PDF, Serialized.

Folgende Template-Engines werden unterstützt:
PHPTAL, Smarty, XSLT, Xtemplate.
Die standardmäßige Template-Engine ist Smarty.

Es ist möglich die PHP Renderer Klasse zu verwenden, um ohne eine TemplateEngine zu arbeiten.
Desweiteren ist es möglich Einfluß auf den HTTP-Header zu nehmen, um Daten zu senden.
So beispielsweise beim Logger Firebug.

.Ausgabemöglichkeiten
["graphviz", "chapter05_image20_renderertypes.png", alt="Ausgabetypen"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    RenderEngines->TemplateEngines;
        TemplateEngines->Smarty;
        TemplateEngines->PHPTal;
        TemplateEngines->XTemplate;
        TemplateEngines->XSLT;
    RenderEngines->Direktausgabe;
        Direktausgabe->Header;
        Direktausgabe->PHP;
    RenderEngines->Ausgabeformate;
        Ausgabeformate->CVS;
        Ausgabeformate->JSON;
        Ausgabeformate->PDF;
        Ausgabeformate->Serialized;
}
---------------------------------------------------------------------

.Instanzierung

.Verwendung

.Entwurfsmuster

Das zugrundeliegende Entwurfsmuser für das Ausgabeverhalten von Clansuite nennt sich Two-Step-View.
Dabei werden zuerst Inhalte gerendert und diese danach in das Layout eingesetzt.
Dieses zweischrittige Verfahren ermöglicht, dass zusätzliche Elemente wie JavaScript und
CSS in das Layout in Abhängigkeit vom Inhalt eingebunden werden können.

Die einzelnen RenderEngines werden über eine Fabrikmethode aufgerufen.
Eine Schnittstelle sichert, dass die Klassen im Kern die gleichen Methoden bereitstellen.

===== Die RenderEngine Adapter

====== Renderer: CVS

Der Renderer CVS nimmt Daten auf und gibt sie in der Form als komma-getrennte Werte zurück.
CVS steht für die Abkürzung für Comma-Separated Values und ist ein Dateiformat (.csv).
Es wird in der Spezifikation RFC 4180 footnote:[http://tools.ietf.org/html/rfc4180] näher beschrieben,
aber ein Standard exisitert nicht. Gerade dies macht das Wiedereinlesen einer CVS-Datenstruktur
relativ schwer, da jeder auf seine Weise strukturieren kann.

====== Renderer: JSON

Der Renderer JSON nimmt Daten auf und gibt sie serialisiert im Format JSON zurück. Die Serialisierung
erfolgt mittels der PHP Extension JSON, die nunmehr seit PHP-Version 5.2.1 standardmäßig vorhanden ist.

.Allgemeines zu JSON (JavaScript Object Notation)
JSON steht für JavaScript Object Notation und ist ein Datenaustauschformat.
Es ist eine Untergruppe des YAML-Formats und beschrieben in RFC 4627
footnote:[http://www.ietf.org/rfc/rfc4627.txt?number=4627].
Populär wurde es durch die Verbindung und Nutzung mit Ajax. Zwar kommt auch XML als ein Tauschmittel für
Ajax in Betracht, doch sind XML-Baumstrukturen nur schwer lesbar und größer.
JSON kann eine Vielzahl von Datenstrukturelementen aufnehmen und abbilden.
Das entstehende Objekt eignet sich zum Transport und die enthaltenen Daten können einfach addressiert werden.

TIP: Ein oft gemachter Fehler ist, JSON mit einem JavaScript Array gleichzusetzen. Der feine Unterschied
besteht darin, dass JSON eine Objekt-Notation ist, die wie ein Array addressiert werden kann.

Es gibt in der PHP-Welt zahlreiche Klassen um JSON zu parsen.
Aber ist nicht verwunderlich ist, dass der PHP eigene Parser schneller ist, als alle in PHP geschriebenen Parser.
Schließlich ist er in C implementiert. Ein Vergleich zahlreicher Parser-Klassen bestätigt diesen Fakt.
footnote:[http://gggeek.altervista.org/sw/article_20061113.html]
footnote:[http://gggeek.altervista.org/sw/article_20070425.html]

====== Renderer: PDF

====== Renderer: PHP

Die Meinungen über natives PHP Rendering sind vielfältig.
Für einige ist die direkte Ausgabe mit PHP der heilige Gral der PHP-Welt, den es zu behüten gilt.
Andere sehen die Sache weniger glaubensverklärt und konstatieren, dass man es wohl auf "die alte Art"
oder aber auf "die Neue" machen könne. Wieder andere sind aufgeklärt und vertreten ein vollständiges
Trennungsprinzip und betrachten "die alte Art" als altmodisch.

PHP wurde einst als Templateskriptsprache entwickelt, um statische Seiten mit dynamischen Elementen anzureichern.
Und eine Reihe anderer Sprachen, wie ColdFusion, ASP und JSP sind zeitgleich entstanden und verwenden das gleiche Prinzip.
Wenn man so will, dann war die Templateengine PHP der Versuch, die Lücke zwischen C und HTML zu verkleinern.
Doch im Laufe der Zeit wurde PHP um immer mehr Sprachmerkmale und Funktionen erweitert.
Je mehr Sprachfeatures und Funktionen eine Skript- bzw. Programmiersprache bereitstellt, desto mächtiger ist sie.
Fraglich ist, ob man diese Macht auf Templateseite haben möchte.

Wer von Templateseite spricht, hat das Trennungsprinzip zwischen Programmseite (PHP) und Templateseite (HTML) im Hinterkopf.
Wer dieses Prinzip nicht kennt oder kennt und ablehnt, vertritt die Ansicht, dass HTML und PHP stets vermischt werden
sollten, um die Ausgabe zu erzeugen. Dies ist die ursprüngliche, alte Art und Weise mit PHP zu entwickeln.
Wer das Trennungsprinzip von HTML und PHP verinnerlicht hat, der mag beim Anblick einer Vermischung von HTML und PHP
erhebliche Qualen empfinden. Bei Manchen gilt letzteres als eine spezielle Form des Spagetticodes mit Webgeschmack.

Wer von Templateseite spricht, kann aber auch das Trennungsprinzip zwischen Geschäftslogik (business logic) und
Präsentationslogik (presentation logic) meinen. Diese Trennung bedeutet nicht unbedingt die Trennung von PHP und HTML.
Denn Präsentationslogik ist alles, was nicht Geschäftslogik ist. Für das Trennungsprinzip zwischen Geschäfts- und
Präsentationslogik sprechen die Arbeitsteilung zwischen Programmierer und Webdesigner, sowie die Wiederverwendbarkeit,
Kapselung, Klarheit und Bearbeitbarkeit mit einem HTML-WYSIWYG Werkzeug. Der Quellcode wird zudem besser wartbar,
leichter austauschbar und kann parallel bearbeitet werden.

Eine Template Engine sollte die Trennung von Geschäftslogik und Präsentationslogik untersützen.
Was bedeutet dabei eigentlich unterstützen (encourage)? Unterstützen bedeutet, dass zu jeder Zeit die Möglichkeit
besteht, die Trennung zu beachten und mehr PHP Funktionen zum Einsatz zu bringen. Doch warum sollte man eine
Template Engine  einsetzen? Weil Template Engines den Bereich der Präsentationslogik von Haus aus und ohne zutun abdecken.
Es sind fertige, einsatzbereite und erweiterbare Präsentationsframeworks.

Gegen die Verwendung von Templateengines gibt es zahlreiche Argumente. Oft wird entgegengehalten, dass man alles,
was man mit einer Templatesprache machen könne, auch mit PHP selbst machen kann. Und zwar viel besser, weil man
mehr Funktionen zur Verfügung hat. Eine Templatesprache, wie z.B. Smarty, ersetzt die PHP-Kommandos lediglich durch
andere, nämlich Smarty-Befehle. Diese Templatesyntax zu lernen sei lästig und zeitraubend.
Oft gehört ist daher auch das faktisch richtige Argument, dass eine Templatesprache doch eigentlich nur unnötigen Overhead erzeugt.
Trefflich streiten, lässt sich allein über die Frage, ob dieser Overhead nötig ist.

Eine Templateengine schränkt den zur Verfügung stehenden Befehlssatz ein.
Für einen Webdesigner ist sie daher immer einfacher einzusetzen als natives PHP.
Das wichtigste Argument für eine Templateengine ist daher:
Sicherheit durch einen eingeschränkten Befehlssatz.

Ich vertrete die Auffassung, dass PHP von Haus aus einen Template-Modus mitbringen sollte.
Der Template-Modus könnte beispielsweise durch die Verwendung des Tokens <?phpt aktiviert werden.
Hierdurch würde ein deutlich reduzierter, sicherer Befehlssatz für den Einsatz in Templates verfügbar.
Den entsprechenden Befehlssatz könnte man in der php.ini durch Whitelisting festlegen.

Dieses Verfahren hat einige Vorteile. Erstens wäre dieser Ansatz in C-implementiert und daher sehr schnell.
Zweitens ist dies ohne großen Aufwand zu erreichen, denn es werden lediglich bereits vorhandene Konfigurationskommandos
eingesetzt, um den Befehlssatz einzuschränken. Drittens könnte dadurch eine bessere Standardisierung von PHP-Templates erreicht werden,
als durch ständige Rewrites bekannter Engines oder überflüssige Neuerfindungen des Rades (zuletzt beispielhaft dafür Symfonys Twig).

[source, php]
---------------------------------------------------------------
<?phpt
 /**
  * PHP im Template Modus mit eingeschränktem Befehlssatz
  */
?>
---------------------------------------------------------------

Nebenbei: Diese Diskussionslinie existiert zwischen nativem PHP Rendering und Templateengines,
als auch zwischen Templateengines und XSLT Rendering.

====== Renderer: PHPTAL

PHPTAL ist eine kompilierende und cachende Templateengine. Die Abkürzung PHPTAL steht für "PHP
Template Attribute Language". Es ist eine PHP-Portierung der Templatesprache des Zope-Servers
(Zope Page Templates, ZPT) footnote:[http://zope3.mpg.de/cgi-bin/twiki/view/Zope/PageTemplate]
footnote:[http://docs.zope.org/zope2/zope2book/AppendixC.html].
Im Vordergrund steht dabei die Generierung von XML und XHTML.

Die TAL-Syntax wird in der Template Attribute Language Expression Syntax (TALES) beschrieben
footnote:[http://wiki.zope.org/ZPT/TALESSpecification13].
Die Besonderheit von TAL liegt in der Verschiebung von Viewhelper-Actions in XHTML Attribute
footnote:[http://zope3.mpg.de/cgi-bin/twiki/view/Zope/TaLes].
Bei anderen Templatesprachen verwendet man hingegen immer Tags oder Elemente.
Es ist theoretisch möglich eine andere Syntax als TAL zu verwenden, denn die als Attributwerte verwendbaren Ausdrücke
werden durch METAL (Macro Expansion Template Attribute Language) beschrieben. In der Praxis erweitert man TALES einfach.

Der Quellcode von PHPTAL wird stetig verbessert und ist unter der GNU/LGPL lizensiert.

Webseite: http://phptal.org
Handbuch: http://phptal.org/manuals.html
Wiki: http://phptal.org/wiki/doku.php

====== Renderer: Serialized

====== Renderer: Smarty

====== Renderer: XSLT

XSLT steht für XSL Transformations und ist in der gleichnamigen W3C Recommendation vom 16 November 1999
footnote:[http://www.w3.org/TR/xslt] beschrieben. XSLT beschreibt die Semantik zur Transformation
von XML Dokumenten in andere XML Dokumente. PHP stellt die Transformationsfunktionalität
in der Erweiterung XSL bereit. Eine PHP-Bibliothek zur Transformation ist daher nicht erforderlich.
Der Clansuite_Renerer XSLT stützt sich auf diese PHP XSL Erweiterung.

Sie bietet die Möglichkeit PHP–Funktionen im XSL–Template aufzurufen.
Die PHP-Funktionen lassen sich mit der Methode registerPHPFunctions() festlegen.
Somit können eigene Viewhelper auch nachträglich problemlos hinzugefügt werden.
Wer mit Smarty entwickelt hat, der wird dieses Verfahren wiedererkennen.
Es entspricht der Registrierung von Smarty-Plugins.

Das der XSL Transformation zugrundeliegende Entwurfsmuster nennt sich daher auch Transform View.
Der Unterschied zwischen Template View und Transform View besteht darin, dass ein Template View
direkt mit den Elementen des Outputs arbeitet, während der Transform View indirekt, nämlich mit
den zu transformierenden Elementen arbeitet und diese erst noch in direkten Output umwandeln muss.

Zuerst wird ein DomDocument erstellt, wobei die Formatierungsdaten aus einer XSL-Datei kommen.
Dann wird das DomDocument mit einer XML-Datei zusammengeführt und zur Ausgabe transformiert.
Letzteres erfolgt mittels der Methode transformToXML().

Durch Verwendung von PHP in XSLT erhöht sich die Flexibilität im View.
Gleichzeitig bietet dieses Verfahren Sicherheit, da nur bestimmte, vorher
registrierte PHP-Funktionen zur Verfügung stehen.

====== Renderer: Xtemplate

==== Clansuite_Cache

Die Klasse Clansuite_Cache ermöglicht den Zugriff auf die verschiedenen Cache-Adapter.

.Was macht ein OpCode-Cache?
Normalerweise wird bei jedem Aufruf eines Skriptes zuerst das Skript kompiliert (es wird aus der Skriptsprache
in Maschinencode überführt) und dann ausgeführt. Das kostet Zeit und verbraucht wertvolle Rechenleistung.
Verwendet man hingegen einen OpCode Cache, so wird ein Skript zuerst kompiliert und danach kompiliert im
Speicher (shared memory / RAM) gehalten. Jeder weitere Aufruf des Skripts wird danach aus dem Speicher
bedient und spart Kompilierungszeit.

Der optimale Wert für die Größe des Cache-Speichers hängt natürlich vom tatsächlich verfügbaren RAM ab.
Wer zu hohe Cachewerte einstellt, zwingt den Server möglicherweise dazu, andere Sachen auszulagern.

.Instanzierung

.Verwendung

.Entwurfsmuster

===== Die Cache-Adapter

====== Cache: APC

====== Cache: eAccelerator

====== Cache: File

====== Cache: Memcached

Der Cache-Server Memcache wurde von der Firma Danga Interactive für den Multiblog-Hoster LiveJournal entwickelt.
http://memcached.org/

====== Cache: xcache

XCache wurde als OpCode Cache für den Webserver "lighttpd" (lighty) entwickelt.
Eine Featureliste findet sich unter http://xcache.lighttpd.net/wiki/FeatureList.
http://xcache.lighttpd.net/

==== Clansuite_Cronjobs

===== Allgemeines

Die Klasse Clansuite_Cronjobs (auch Pseudocron genannt) ermöglicht eine intervallgebundene Ausführung von
selbst bestimmbaren Kommandos. Beispielsweise kann man wöchentlich die Datenbank sichern, stündlich Feeds
aktualisieren oder täglich den Template-Cache leeren oder die Sitemap neu generieren lassen. Dabei kann jedes
PHP-Skript ausgeführt werden, wobei das Ausführungsintervall periodisch, also wiederkehrend oder zeitgesteuert
sein kann. Die ausgeführten Cronjobs werden in einem Log gespeichert. Aus einem Cronjob können Nachrichten ins
Log gespeichert werden. Unter Crontab versteht man die Cron-Tabelle. Sie enthält die Zeitangaben und die
auszuführenden Kommandos. Die Notation eines Cronjob in der Crontab erfolgt im Unix Cron Syntax.

Ein zulässiger Crontabeintrag könnte wiefolgt aussehen:

[source, txt]
---------------------------------------------------------------------
2   1,15    *   *   beispiel.cronjob.php
---------------------------------------------------------------------
Dieser Eintrag hätte zur Folge, das "beispiel.cronjob.php" um 2 Uhr am ersten und fünfzehnten jedes
Monats ausgeführt werden.

.PHP5-Portierung von pseudo-cron v1.3
Clansuite_Cronjobs ist ein Fork, genauer eine PHP5-Portierung, der
bekannten PHP-Klasse pseudo-cron von Kai Blankenhorn (http://www.bitfolge.de/pseudocron). Die letzte Version,
pseudo-cron v1.3, wurde am 15.06.2004 veröffentlicht. Die Veröffentlichung der PHP5 Portierung erfolgte am
10.05.2008 als Minor-Release mit der Versionsnummer v1.4. Dabei wurden die globalen Variablen entfernt, sowie
Handler für datei- sowie datenbankbasiertes Crontab-Scheduling hinzugefügt.

===== Möglichkeiten des Cronjob Triggerings

Es gibt mehrere Möglichkeiten Cronjobs zu triggern.

.Die Vorfilter Methode
Beispielsweise kann eine Kontrolle auf anstehende Cronjobs als ein Vorfilter des Systems angelegt werden.

.Die Image-Tag Methode
Der Cronjob kann auch über den HTML Tag <img> ausgelöst werden. Beide Möglichkeiten hätten zur Folge, dass
jeder Webseitenbesuch auch eine Prüfung des Crontabs auf anstehende Aufgaben auslöst.

.Die Kopplung an den "echten" Cronjob des Betriebssystems
Im Gegensatz zum normalen, betriebssystemgesteuerten Cronjob ist mit Clansuite_Cronjob jedoch keine exakte
zeitliche Ausführung der Kommandos möglich, da das Cronjobsystem immer an Ereignisse der Webanwendung geknüpft
ist. Finden keine Ereignisse statt, werden die Cronjobs auch nicht ausgeführt. Wenn Sie beispielsweise einen
stündlichen Cronjob registriert haben, der aktuelle News einholt und sie in ihrer Newsdatenbank speichert,
jedoch im Zeitraum von 23Uhr bis 7Uhr keinen Besucher auf ihrer Webseite, dann wird der Cronjob erst wieder
durch den Besucher nach um 7Uhr getriggert. Ihnen entgeht dabei die Newsaktualisierung zwischen 23Uhr und
7Uhr. Um sich einer exakten zeitlichen Ausführung anzunähern, kann man die Ausführung der Clansuite_Cronjobs
an die Cronjobs des Betriebssystem koppeln. Dazu fügt man einfach den Aufruf der Clansuite_Cronjob in die
Crontab des Betriebssystems ein (crontab -e).

Ereignisse der Webanwendung werden natürlich auch von Suchmaschinencrawlern ausgelöst. Crawler sind reguläre Besucher,
wenn sie nicht durch Konfigurationsanweisung in der ".htaccess" oder "robots.txt" ausgeschlossen wurden.
Webseitenbetreiber mit guter Besuchsfrequenz von Crawlern brauchen sich also keine Sorgen um die Cronjob-Auslösung machen.
Die Kopplung von Web-Cronjobs an den Cronjob-Dienst des Betriebssystems bietet sich immer dann an,
wenn man unabhängig von Besuchern und Ereignissen der Webanwendung, seine Cronjobs regelmäßig ausgelöst wissen möchte.

[source, txt]
---------------------------------------------------------------------
* * * * * php /srv/www/clansuite/cronjobs.php
---------------------------------------------------------------------

.Instanzierung

.Verwendung

Innerhalb eines Cronjobs kann mittels der Methode logMessage("Ihre Nachricht"); eine Nachricht in das Cronjob-
Logbuch geschrieben werden.

===== Übersicht zu Crontab und Cronjobs

.Die Crontab Datei

Das Format der Crontab-Datei entspricht in Aufbau und Syntax dem von Linux bekannten Cronjob-Format.

==== Clansuite_Eventhandler

Die Klasse Clansuite-Eventhandler stellt Methoden bereit, um einen ereignisbasierten Programmablauf zu ermöglichen.
Um dies umzusetzen, werden an bestimmten Stellen im Ablauf der Applikation Ereignisse definiert.
Auf den Eintritt dieser Ereignisse wartet ein Beobachter. Dem Beobachter wird ebenfalls eine Liste mit Unterprogrammen
vorgelegt, die ausgeführten werden sollen, wenn bestimmte Ereignisse eintreten.
Stellt der Beobachter den Eintritt eines Ereignisses fest, löst er alle für dieses Ereignis angemeldeten Unterprogramme aus.

Den Beobachter nennt man auch Observer oder EventListener. Den Teil des Beobachters, der das Unterprogramm ausführt,
nennt man EventHandler (so auch der Klassenname). Nicht verwunderlich ist der Name des zugrunde liegenden Entwurfsmusters.
Es ist das Subject-Observer Muster. Manchmal wird es auch nur Signal-Slot genannt.

Durch den Einsatz ereignisbasierter Programmierung ist es möglich, die Applikation dynamisch zu erweitern ohne am
Quelltext etwas zu ändern. Man fügt lediglich eine Datei mit dem neuen Unterprogramm ein und registriert es für das
gewünschte Ereignis beim Beobachter.
Um nun eine ganze Reihe von Unterprogrammen einzubinden, kann man auf die magische PHP-Methode __autoload() zurückgreifen.
Clansuite verwendet diesen Mechanismus und lädt ereignisbasierte Unterprogramme aus einem dafür eingerichteten Verzeichnis
(/core/events/) und registriert sie automatisch. Das Verfahren fördert die Losekopplung. Gleichzeitig werden die
Hauptcontroller etwas verkleinert, indem Quellcodeanteile in die Unterprogramme ausgelagert werden.
Der Nachteil besteht allerdings darin, dass die Komplexität durch diese Dezentralisierung wieder ansteigt.
Leicht kann der Überblick über verfügbare Ereignisse und registrierbare Unterprogramme verloren gehen.

.Intanzierung

Es erfolgt eine automatische Instanzierung beim Systemstart. Der Eventdispatcher wird bei der Initialisierung des Systems automatisch instanziert bzw. gestartet, wenn in der Konfigurationsdatei (/confuguration/clansuite.config.php)
in der Sektion "eventsystem" der Wert "eventsystem_enabled" auf "true" oder "1" gesetzt ist.
Das gesamte Eventsystem kann also in der Konfiguration ein- und ausgeschaltet werden.
Danach ist das Eventhandler Objekt systemweit über den Dependency Injector verfügbar.

.Einschalten des Eventsystems in der Konfiguration
[source, txt]
---------------------------------------------------------------------
;----------------------------------------
; eventsystem
;----------------------------------------
[eventsystem]
eventsystem_enabled = 1
---------------------------------------------------------------------

Möglich ist auch die direkte Instanzierung (Singleton).

[source, php]
---------------------------------------------------------------------
$eventhandler = Clansuite_Eventhandler::instantiate();
---------------------------------------------------------------------

Zumeist ist eine Instanzierung jedoch nur zum Aufruf der Methode triggerEvent() gewollt.
Um die Instanzierung abzukürzen kann direkt Clansuite_CMS::triggerEvent() eingesetzt werden.

.Verwendung

Ein neues Ereignis kann folgendermaßen registriert werden.
[source, php]
---------------------------------------------------------------------
$eventhandler->addEventHandler($eventName, Clansuite_Event $event);
---------------------------------------------------------------------

Konkretes Beispiel:
[source, php]
---------------------------------------------------------------------
$logger = new Clansuite_Logger();
$authlogger = AuthenticationLogging($logger);
$eventhandler->addEventHandler('onUserLogin', $authlogger);
---------------------------------------------------------------------

[source, php]
---------------------------------------------------------------------
# Systemweit
Clansuite_CMS::triggerEvent();

# Innerhalb eines Modulecontrollers
@todo
---------------------------------------------------------------------

.Entwurfsmuster

Die Klasse Clansuite_Eventdispatcher ist ein Kontainer für alle Eventhandler. Sie ist eine Hilfsklasse für
ereignisbasierte Entwicklung. Ereignisse können unter einem Ereignisnamen registriert werden. Wenn ein
Ereignis durch den Programmablauf ausgelöst bzw. getriggert wird, erfolgt eine Suche nach dem Ereignisnamen
unter allen registrierten Ereignissen. Wird ein entsprechendes Ereignis gefunden, so wird es ausgeführt.
Werden mehrere entsprechende Ereignisse gefunden, so werden sie in der Reihenfolge ihrer Registrierung ausgeführt.
Auf diese Art und Weise können Objekte sich sehr flexibel untereinander verständigen und es kann sehr leicht neue
Funktionalität nachträglich hinzugefügt werden.

Die Klasse Clansuite_Event ist die Basisklasse für alle Events.
Mittels der Methoden getName(), getContext(), getInfo() können Kontextinformationen über das Ereignis eingeholt werden.
Mittels der Methode cancel() kann ein Abbruch erfolgen. Um zu überprüfen, ob ein Abbruch innerhalb einer Ereigniskette stattfand,
kann die Methode getCancelled() eingesetzt werden.

Der Name des Entwurfsmusters ist mit dem Klassennamen identisch. Es ist das "Event-Dispatcher" Muster.
Häufiger ist es auch nur unter dem Namen Event oder Eventsystem anzutreffen. Alternativ wird es auch als "Hooksystem" (für Haken bzw. Aufhänger) bezeichnet.
Geläufig sind auch die Muster-Bezeichnungen "Subject-Observer-Muster" und "Notification Queue".

===== Übersicht zu Eventhandlern

[horizontal]
.Hooks im Bereich Benutzerregistrierung, Login, Logout
onRegisterAccount::       wenn neuer Useraccount angelegt wird (Daten können bei fremdem System eingetragen werden)
onAccountActivation::     wenn ein neuer Useraccount aktiviert wird
beforeLoginValidation::   bevor die Prüfung der Eingaben erfolgt, kann ein fremdes System damit befragt werden (Bridges)
afterLogin::              nach einem erfolgreichen Login
afterLogout::             nach einem erfolgreichen Logout
onDeleteAccount::         bevor die Löschung eines Useraccounts durchgeführt wird (Daten können aus fremdem System ausgetragen werden)
resetPassword::

.Hooks im Bereich Formulargenerierung und Formularhandling

.Hooks im Bereich Dateihandling

onDownload::              nachdem eine Datei heruntergeladen wurde (Update des Downloadcounters in der Statistik)

. Hooks innerhalb von Doctrine Records

Die Hooks innerhalb von Doctrine Record Objekten an 5 Aktionen an.
Diese 5 Aktionen sind Save, Update, Insert, Delete und Validate.
Jede dieser Aktionen wird nochmals gemäß der zeitlichen Anknüpfung unterteilt.
So gibt es einen Haken vor der Aktion (Pre-Hook) und einen Haken nach der Aktion (Post-Hook).
Innerhalb von Doctrine Records stehen also die folgenden 10 Hooks zur Verfügung.

- preSave
- postSave
- preUpdate
- postUpdate
- preInsert
- postInsert
- preDelete
- postDelete
- preValidate
- postValidate

Um einen dieser Hooks zu verwenden, wird das Doctrine Record Object einfach um eine nach dem gewünschten Hook benannte Methode erweitert.

[source, php]
---------------------------------------------------------------------
class Mein_Doctrine_Record_Object extends Doctrine_Record
{

	public function setTableDefinition()
	{
		# Definition der Tabelle
	}

	public function setUp()
	{
		# Setup und Relationen
	}

	public function postInsert()
	{
		# Wenn diese Stelle des Quellcodes aufgerufen wird, befinden wir uns zeitlich nach dem Einfügen eines neuen Datensatzes.
		# An dieser Stelle können Sie den Quellcode einfügen, der nach diesem Ereignis ausgeführt werden soll.
	}
}
---------------------------------------------------------------------

==== Clansuite_Errorhandler

Die Behandlung von Programmfehlern erfolgt mittels der Klasse Clansuite_Errorhandler.

Zahlreiche Webanwendungen machen von der Möglichkeit Gebrauch, das Errorhandling an den Exceptionhandler zu
übertragen. Dies führt zu einer Vereinfachung des Systems, da nicht mehr zwei
Handler-Klassen gepflegt werden müssen. Clansuite nutzt diese Möglichkeit nicht. Dies hat zwei Gründe. Zum
einen müsste der Exceptionhandler intern prüfen, ob ein Error die Exception ausgelöst hat, womit eigentlich
Logik des Errorhandlers in den Exceptionhandler verschoben wird. Zum anderen soll es bei Clansuite möglich
sein, dem jeweiligen Handler ein eigenes Aussehn durch Templates zu geben.

===== Fehlerbehandlung für strikte Typen

Auch PHP in der Version 5.2+ hat immernoch ein großes Problem im Bereich Typen.
Die Sprache PHP kennt keine strikten Typen (engl. Strict Types). PHP ist eine schwach typisierte Sprache.
Der Typ einer Variablen wird durch den Kontext bei ihrer konkreten Verwendung bestimmt.
Demnach können Variablentypen während der Laufzeit einer Typänderung unterliegen.
Dies bezeichnet man als automatisches bzw. dynamisches Type-Casting oder Type-Juggling
footnote:[http://php.net/manual/en/language.types.type-juggling.php]).
Es ist es möglich Variablen zu verwenden, ohne sie vorher zu deklarieren.

PHP stellt eine Möglichkeit bereit, um festzustellen, ob eine Variable initialisert wurde.
So lässt sich der Level der Fehlerberichterstattung mittels der Methode error_reporting() auf E_NOTICE setzen.
Nicht initialsierte Variablen werden dann als Fehler des Typs Notice angezeigt und man erhält zumindest einen Hinweis.
Clansuite wird seit Anfang der Entwicklung mit dem Fehlerberichterstattungslevel E_STRICT and E_NOTICE entwickelt.
Eine Alternative dazu, wäre der Einsatz eines externen Quelltext-Prüfwerkzeugs wie PHP Lint,
um diese Fehler hervorzuheben. Viele Editoren und IDEs integrieren ein solches Prüfwerkzeug bereits.

Die Verwendung von strikten Typen bringt einige Vorteile mit sich.
Fehler treten schneller hervor und die Ausdrucksstärke der Variablenverwendung in Funktionen und Methoden wird erhöht.
Beispielsweise kennt PERL ein "use strict", doch ein solches fehlt bei PHP noch immer.

.Die Weiterentwicklung von PHP im Hinblick auf die Unterstützung strikter Typen
Gegenwärtig wird sowohl auf der PHP-Mailingliste als auch im PHP-Wiki über die Unterstützung
strikter Typen diskutiert. Lukas Smith hat am 03.06.2009 eine PHP-RFC zum Thema "Typechecking"
footnote:[http://wiki.php.net/rfc/typechecking, PHP RFC Typechecking Vorschlag von Lukas Smith]
verfasst, sein Entwurf ist unter http://wiki.php.net/rfc/typecheckingstrictandweak abrufbar.
Ein weiterer Vorschlag footnote:[http://wiki.php.net/rfc/typecheckingstrictonly, PHP RFC
Typechecking Vorschlag von Ilia Alshanetsky] von Ilia Alshanetsky
zum Thema Typechecking befasst sich mit der Ergänzung der Reflection-Erweiterung
um typdefinierende ReflectionParameter Methoden. Er führt zum Beispiel Methoden
wie ReflectionParameter::isInt() oder ReflectionParameter::isBool() zur Typprüfung mittels Reflektion ein.

===== Die Clansuite Errorcodes

Um Fehler auszulösen kann der PHP-Befehl trigger_error() eingesetzt werden.

[source, php]
---------------------------------------------------------------------
trigger_error('Auslösen eines USER_ERRORS!', E_USER_ERROR);
---------------------------------------------------------------------

Es stehen die folgenden Fehlerlevel für den Programmierer zur Verfügung:

.Fehlerlevel für trigger_error()
[source, txt]
---------------------------------------------------------------------
E_USER_WARNING
E_USER_NOTICE
E_USER_ERROR
---------------------------------------------------------------------

PHP verfügt über weitere Fehlerlevel footnote:[http://php.net/manual/en/errorfunc.constants.php].
Diese können jedoch nicht manuell, d.h. über die Funktion trigger_error() ausgelöst werden.

.Fehlerlevel von PHP
[source, txt]
---------------------------------------------------------------------
Catchable Fatal Error
    E_RECOVERABLE_ERROR
Parser-Fehler
    E_PARSE
    E_ERROR
    E_WARNING
    E_NOTICE
Compiler-Fehler
    E_COMPILE_ERROR
    E_COMPILE_WARNING
PHP Code-Errors
    E_CORE_ERROR,
    E_CORE_WARNING
Runtime Notices
    E_STRICT
---------------------------------------------------------------------

Statt der Verwendung von Errors bitte grundsätzlich Exceptions verwenden.

Zu jeder Regel gibts eine Ausnahme: keine Exceptions in Templates werfen. Bei Verwendung von Smarty unbedingt
trigger_error() verwenden, denn die auf diese Art geworfenen Fehler werden automatisch abgefangen und im
Template zur Bearbeitung markiert.

IMPORTANT: In Smarty Plugins und Funktionen immer trigger_error() einsetzen.

===== Übersetzung von Fehlermeldungen

Derzeit findet keine Übersetzung von Fehlermeldungen statt.
Die Sprache der Fehlermeldungen ist Englisch.

==== Clansuite_Exceptionhandler

Die Exceptionbehandlung ist ähnlich der Behandlung von Errors. Die Klasse Clansuite_Exception erweitert die
normale PHP Exception Klasse. footnote:[http://php.net/exceptions, PHP Handbuch - Kapitel Exceptions] Die
Erweiterung besteht dabei einerseits in verbesserter Darstellung der Exceptions, andererseits in dem
automatischen Auffangen aller nicht abgefangenen Exceptions, z.B. denen fremder Bibliotheken.

Kern der Klasse ist die Methode yellowScreenOfDeath(), mit der eine Darstellungsmethode für Exceptions
eingeführt wird. Sie zeigt Exceptionmessage und Code, sowie die Ausgabe der nicht abgefangenen Exception an.
Erweitert wird die Anzeige durch Debuginformationen, wie z.B. dem Debug-Call-Stacktrace, welcher die zuletzt
ausgeführten Methodenaufrufe vor dem Exceptioneintritt aufführt und der Anzeige von Direktlinks zum Support
und zu den Handbüchern.

Normalerweise, also ohne einen eigenen Exceptionhandler, werden nicht abgefangene Exceptions als "Fatal
Errors" ausgegeben. Mittels der PHP Funktion set_exception_handler wird ein systemweiter Exceptionhandler
registriert. Er sorgt dafür, dass nicht abgefangene Exceptions nun behandelt und mittels der eigenen Darstellungsmethode
anzeigt werden können. Dies erfolgt bei Initialisierung des Systems innerhalb der Methode initialize_Errorhandling()
in der Datei "bootstrap/clansuite.application.php".

===== Behandlung von Exceptions

Es gibt 3 bzw. 4 Sprachelemente für den Umgang mit Ausnahmen.
Dies sind "try", "catch", "throw" und "finally".

throw:: Bewirkt das Werfen einer Ausnahme.
try:: Das Sprachelement try umklammert den Quelltext, in welchem möglicherweise eine Ausnahme geworfen wird.
catch:: Das Sprachelement catch umklammert den Quelltext, der ausgeführt wird, wenn eine Ausnahme im try-Block geworfen wurde.

[source, php]
---------------------------------------------------------------------
try
{
    throw Exception();
}
catch (Exception $e)
{
    # Behandlung der Exception
    echo $e->Message;
    exit();
}
---------------------------------------------------------------------

Eine im try-Block geworfene Exception steigt bis zum ersten Catch-Block auf.

.Kaskadierung von Exceptions
[source, php]
---------------------------------------------------------------------
try
{
    throw Exception();
}
catch (SpezielleException $e)
{
    # Behandlung der Exception
    echo $e->Message;
    exit();
}
catch (Exception $e)
{
    # Behandlung der Exception
    echo $e->Message;
    exit();
}
---------------------------------------------------------------------

===== Verwendung: Das Werfen von Exceptions

Exceptions kann man als Kontrollstrukturen, vergleichbar mit if-else, foreach oder while verstehen.
Dennoch sind sie denkbar ungünstig für diesen Einsatzzweck, denn sie sind langsamer und verbrauchen mehr Speicher,
als normale Kontrollstrukturen.

Der Clansuite_Exceptionhandler wirft durch Aufruf der Methode throwException() eine neue Clansuite_Exception.
Es stehen die folgenden Möglichkeiten zum Werfen einer Clansuite_Exception zur Verfügung:

[source, php]
---------------------------------------------------------------------
# Hier wird eine normale Exception geworfen.
# Diese wird durch den Exception Handler gefangen und in eine Clansuite Exception umgewandelt.
throw new Exception('Meine Exception');

# Es wird eine Clansuite Exception mit der Exceptionnummer 60 geworfen.
# Sollte ein Exception Template für die Nummer 60 existieren, wird sein
# Inhalt innerhalb des Exception-Kontext dargestellt.
# Der Unterstrich vor dem Exception-Text bewirkt die Übersetzung.
throw new Clansuite_Exception( _('Meine Exception') , 60);

# Werfen einer Exception
Clansuite_Exception->throwException(),

# Verwendung bei Methoden, die einen Wert des Typs Boolean zurückliefern
someBooleanMethod() or throwException();

# Beispielsweise
isFileandReadable('filename.txt') or throwException('File not found or not readable!');
---------------------------------------------------------------------

===== Die Exceptionhandler Templates

Der Exceptionhandler bietet die Möglichkeit mit Exceptiontemplates zu arbeiten. Das sind Templates die zu
einer Exception einen ausführlicheren Beschreibungstext anbieten und somit den Kontext der Exception
erläutern, um den Fehler zu überwinden. Jeder Exception ist eine Identifikatonsnummer zugewiesen, anhand
dieser wird ein entsprechendes Template geladen.

Dabei unterscheiden wir zwei Arten von Exceptiontemplates. Zum einen normale Exceptiontemplates. Die angezeigt
werden, wenn das System im Debugmodus betrieben wird. Zum anderen Entwickler-Exceptiontemplates. Die angezeigt
werden, wenn das System im Debug- und Developermodus betrieben wird. Die Exceptionstemplates befinden sich im
Verzeichnis "themes\core\exceptions".

Der Unterschied zwischen der beiden Arten von Templates findet seinen Ausdruck in der Benennung der
Templatedateien. Der Dateiname normaler Exceptiontemplates lautet "exception-x.tpl". Der Dateiname von
Entwickler-Exceptiontemplates lautet "dev-exception-x.tpl". Hierbei steht das "x" jeweils für den
Exceptioncode, die eindeutige Identifikationsnummer. Wenn für einen Excpetioncode beide Templates existieren,
dann werden auch beide nacheinander innerhalb der Exceptionanzeige angezeigt.
Die Reihenfolge der Darstellung ist dabei Normaltemplate vor Entwicklertemplate.

===== Die Exceptionhandler Codes

Nachfolgende Tabelle schlüsselt die bisher vergebenen Exceptioncodes auf.
Eine entsprechende Datei befindet sich auch im Verzeichnis der Templates
/themes/core/exception/errorcodes.txt.

[source,txt]
---------------------------------------------------------------------
Exceptioncode    Exceptionname                                        Used in File               Method
---------------------------------------------------------------------

[source,txt]
---------------------------------------------------------------------
dev-1   Database Connection Information invalid              /core/doctrine.core.php    prepareDbConnection()
dev-2   Action Missing. Create now.
dev-3   Module Missing. Create now.
dev-4   Config Missing. Create now.                          /ini.config.php            readConfig()

09      Smarty Template Directories do not exist.            startup_checks.filter.php
10      Smarty Template Directories not writable.            "

12      The copyright tag is missing.                        Smarty.renderer.php
        {include file='copyright.tpl'} in your layout/wrapper template file.
13      The header notice tag is missing.                    "
        {include file='clansuite_header_notice.tpl'} in your layout/wrapper template file.
14      The content variable {$content} must be within       "
        the wrapper template
30      Ensure that all obligatory formelements are present. /core/viewhelper/formgenerator __construct()
---------------------------------------------------------------------

===== Übersetzung von Ausnahmemeldungen

Derzeit findet keine Übersetzung von Ausnahmemeldungen statt.
Die Sprache der Ausnahmemeldungen ist Englisch.

==== Clansuite_Feed

.Instanzierung

.Verwendung

==== Clansuite_Form

Clansuite Forms verwendet Filter und Validatoren automatisch, wenn sie für ein Formelement definiert wurden.

.Schutz vor Cross Site Request Forgery (CSRF) durch Token (Shared-Secret)

Der Fachbegriff Cross-Site-Request Forgery (CSRF) lässt sich nur schwer in die deutsche Sprache übertragen.
Man kann darunter einen Angriff verstehen, bei dem durch einen untergeschobenen Aufruf auf eine Fremdseite
eine Datenveränderung innerhalb einer Webanwendung durchgeführt wird.
Dabei wird dem Angriffsopfer in seinem Webbrowser ein URL-Aufruf untergejubelt,
der einen veränderten HTTP-Request ausführt. Der veränderte Request führt nun die vom
Angreifer gewünschte Aktion aus. Dies hat regelmäßig Erfolg, wenn der Nutzer bei der Webanwendung angemeldet
ist und aus Bequemlichkeits- und Komfortgründen ein Cookie gespeichert hat. Eine bestehende Anmeldung oder
der Zugriff auf Cookie-Daten ist Voraussetzung für einen erfolgreichen Angriff.

Die Angriffsvektoren bei Cross Site Request Forgery (CSRF) sind regelmäßig das URL-Unterschieben und das
Cross-Site- Scripting (XSS).

Ein URL-Unterschieben kann auf vielfältige Art erfolgen. So beispielsweise durch
das Verteilen einer URL während eines IRC Chats oder durch Zusenden einer E-Mail.

Bei Cross-Site-Scripting (XSS) wird HTML-Code an die Webanwendung übermittelt.
Dies erfolgt häufig durch Ausnutzen von Sicherheitslücken im JavaScript-Bereich.
So kann beispielsweise jeder <img> oder <frame> Tag zum Nachladen von Angriffselementen eingesetzt werden.
Zuerst wird also ein HTML-Tag Element mittels JS eingeschleust, sodann wird die Seite vom Opfer aufgerufen.
Beim Aufruf wird der eingeschleuste Tag vom Browser interpretiert und der schadhafte Link aufgerufen.

Um sich davor zu schützen, verwendet man ein einfaches serverseitiges Verfahren. Ein Zugriff auf die
Applikations wird mittels eines Sicherheitstokens (Shared-Secret) erreicht. Der Sicherheitstoken wird als
verstecktes Feld zusätzlich zu jedem Formular hinzugefügt. Beim Übermitteln des Formulars wird automatisch
überprüft, ob der Sicherheitstoken des Formulars mit dem intern (in der UserSession) vorliegenden
übereinstimmt. Die eingehenden Daten sind valide, wenn der Token übereinstimmt.
Liegt kein Token vor oder stimmt er nicht überein, werden die eingehenden Daten des Requests verworfen.

.Instanzierung
[source, php]
---------------------------------------------------------------------
/**
 * Instanzierung von Clansuite_Form mittels Übergabe eines Attribute Array als Parameter
 */
$formattributes = array( 'name'   => '1',
                         'method' => '2',
                         'action' => '3');
$form = new Clansuite_Form($formattributes);

/**
 * Instanzierung von Clansuite_Form mittels der drei Parameter name, method, action.
 */
$form = new Clansuite_Form('name','method','action');

# Übergabe des Formular HTML-Quelltextes an das Template
# Beachte: Es sind keine Formularelemente verwendet worden!
$view->assign('form', $form);
---------------------------------------------------------------------

.Verwendung

===== Entwurfsmuster

===== Übersicht zu den einzelnen Formelementen

==== Clansuite_Flashmessages

Die Klasse Clansuite_Flashmessages dient der Speicherung von Einmal-Nachrichten in der Session und damit über
einen Request hinweg. Man kann sich die Klasse Clansuite_Flashmessages als Erweiterung der Klasse
Clansuite_Session denken. Tatsächlich ist sie es aber nicht. Flashmessages können beispielsweise
Kurznachrichten, Statusmeldungen, sowie Erfolgs- oder Misserfolgsmeldungen nach Aktionen sein.
Daher kann man die Flashmessages in die Typen 'error', 'warning', 'notice', 'success', 'debug' einteilen.

Grundsätzlich gibt es ein Nachrichtenübermittlungsproblem an den Benutzer nach GET oder POST Requests. Das
Absetzen von Meldungen nach einem GET-Request ist sehr einfach, denn man kann sie per echo oder im Template
ausgeben. Bei POST-Requests, die zumeist von einem Redirect begleitet werden, wird es schwieriger.
Im Allgemeinen gibt es dazu 3 Lösungsansätze. Flashmessages sind eine Art dieses Problem zu lösen.

Erstens kann man kann die Nachricht an die URL anhängen. Das bedeutet, dass man zu einer POST Übergabe auch
Daten über GET übergibt. Es kann auch bedeuten, dass die URL unter Umständen (je nach Nachrichtenlänge) sehr
lang werden kann, wie z.B. header('Location: http://www.example.com/index.php?message='.urlencode($message));.

Zweitens kann eine Doppelweiterleitung einsetzen. Stellen Sie sich dazu die folgende typische Situation vor:
Nachdem Sie ein ein Formular ausgefüllt und es abgesendet haben, werden sie auf eine neue Seite
weitergeleitet. Diese Seite zeigt Ihnen zunächst eine Erfolgsmeldung der Art "Ihr Datensatz wurde
eingetragen." an. Sodann werden sie entweder automatisch oder nach Klick auf die Ausgangsseite zurückgeleitet.
Es erfolgte eine Doppelweiterleitung, wobei die erste Weiterleitung nur der Erfolgsmeldung (engl. successview)
diente u nd die zweite Weiterleitung die Zielseite war.

Drittens kann Flashmessages verwenden, um die Nachrichten über einen Request in der Session zu speichern.
Diese Klasse setzt genau diesen Lösungsweg um. Mit Flashmessages umgeht man diese Doppelweiterleitung (engl.
two-step-redirect) auf elegante Art und Weise. Nachdem die Daten des Formulars empfangen und in die Datenbank
eingetragen wurden, setzen Sie eine Flashmessage ein, um die Erfolgsmeldung in der Session zu speichern.
Danach leiten Sie auf die Zielseite weiter. Mit dem Erreichen der Zielseite wird geprüft, ob eine Flashmessage
in der Session enthalten ist. Wenn es so ist, wird Sie nun dem Benutzer angezeigt und danach aus der Session
gelöscht.

Flashmessages haben also einige Vorteile. Bei diesem Verfahren brauchen Sie keine Weiterleitungsseiten
anlegen, die nur den Zweck haben Statusmeldungen anzuzeigen. Auch müssen Sie sich nich um die Länge der
Nachricht kümmern, wie es bei einer Nachrichtenübergabe mittels GET der Fall wäre.
Sie können die Darstellung und die Position der Anzeige der Flashmessages flexibel an Ihren View anpassen.

.Instanzierung

Eine Instanzierung der Klasse ist nicht nötig. Alle Methodenaufrufe erfolgen statisch. Die Klasse steht
systemweit über den Autoloading-Mechanismus zur Verfügung und muss nicht gesondert geladen werden.

.Verwendung

[source, php]
---------------------------------------------------------------------
/**
 * Das Setzen einer Flashmessage erfolgt mittels der Methode setMessage().
 * Diese erwartet die Angabe eines Nachrichtentyps und die Nachricht als Parameter.
 * Folgende Nachrichtentypen sind zulässig: error, warning, notice, success, debug.
 */

# abstrakt
Clansuite_Flashmessages::setMessage($type, $message)
# konkret
Clansuite_Flashmessages::setMessage('success', 'Die Aktion war erfolgreich.');
Clansuite_Flashmessages::setMessage('notice', 'Es sind nicht alle Formularfelder richtig ausgefüllt.');
Clansuite_Flashmessages::setMessage('warning', 'Die Dateirechte sind nicht ordnungsgemäß (read-only) gesetzt.');

/**
 * Die Ausgabe der Flashmessages erfolgt mittels der Methode render().
 */
Clansuite_Flashmessages::render();
---------------------------------------------------------------------

==== Clansuite_Localization

.Instanzierung

.Verwendung

==== Clansuite_Logger

Die Klasse Clansuite_Logger dient dem Logging von Nachrichten und Fehlern, die sich während des
Applikationsablaufs erreignen.

.Instanzierung

[source, php]
---------------------------------------------------------------------
$logger = new Clansuite_Logger();
---------------------------------------------------------------------

.Verwendung

.a) Übergabe eines Strings als Loggername
[source, php]
---------------------------------------------------------------------
$logger->addLogger('firebug');
---------------------------------------------------------------------

.b) Übergabe eines Loggerobjekts
[source, php]
---------------------------------------------------------------------
$logger->addLoger(new Clansuite_Logger_Firebug);
---------------------------------------------------------------------

.c) Übergabe mehrerer Loggerobjekte
[source, php]
---------------------------------------------------------------------
$logger_array = array();
$logger_array[] = new Clansuite_Logger_Firebug();
$logger_array[] = new Clansuite_Logger_File();
$logger->addLoger($logger_array);
---------------------------------------------------------------------

===== Entwurfsmuster

Das Entwurfsmuster für diese Klasse ist ein Kompositum (auch compositum order composite genannt). Die Klasse
repräsentiert also eine Zusammenstellung eines oder mehrerer Logger. Ein neues Logger-Objekt wird dem
Kompositum mittels addLogger() hinzugefügt und mittels removeLogger() wieder entfernt.
Das Kompositum wird durch die Methode writeLog() ausgelöst.

====== Die Logger Adapter

Die folgenden Logger Adapter stehen für die Komposition zur Verfügung.

======= Logger: /dev/null

Der Logger /dev/null sendet die Lognachrichten direkt in den Papierkorb.

======= Logger: E-Mail

Der Logger E-Mail sendet die Lognachrichten via E-Mail.

======= Logger: File

Der Logger File schreibt die Lognachrichten in die Logdatei.

======= Logger: Firebug

Der Logger Firebug sendet die Lognachrichten in die Firebug Konsole des Firefox Webbrowsers.

==== Clansuite_Mailer

Die Klasse Clansuite_Mailer ist eine einfache Wrapper- und Initialisierungsklasse für SwiftMailer. SwiftMailer
wurde ursprünglich von Chris Corbyn entwickelt. Seit der Version 4.0.0 ist Fabien Potencier vom Symfony-Team
als weiterer Entwickler hinzugekommen.

Webseite des SwiftMailer Projekts: http://swiftmailer.org/

.Konfiguration

Clansuite_Mailer benötigt einige Konfigurationseinstellungen.
Diese sind in der clansuite.config.php im Abschnitt [email] zu finden.

Erforderlich sind:
[source, php]
---------------------------------------------------------------------
$config['email']['mailmethod']
$config['email']['mailerhost']
$config['email']['mailerport']
$config['email']['mailencryption']
---------------------------------------------------------------------

.Instanzierung

$mailer = new Clansuite_Mailer();

.Verwendung

[source, php]
---------------------------------------------------------------------
# Senden einer E-Mail mittels der Methode sendmail()
$mailer->sendmail($to_address, $from_address, $subject, $body);

# Holen des SwiftMailer Objekts aus dem Wrapper
$swiftmailer = $mailer->getMailer();
---------------------------------------------------------------------

.Entwurfsmuster

Wrapper.

==== Clansuite_Module_Controller

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Router

Die Klasse Clansuite_Router sorgt für die Zuordnung (engl. mapping) einer URI zu einem Controller, seiner
Action und, wenn vorhanden, auch zusätzlicher Parameter. Eine eingehende URL wird zunächst in ihre
Bestandteile zerlegt. Dabei wird der anfängliche URL Teil ("http://www.xy-domain.com") vom URI Teil
("/index.php" oder "/index") abgetrennt. Die Bestandteile der URI dienen als Abfrageparameter an eine
Zuordungstabelle (engl. mapping- table). Die Zuordnungstabelle ist ein Nachschlagewerk für alle Informationen
über aufrufbare Controller und Actions und ihre möglichen Parameter. Sie liefert anhand der URI-Bestandteile
die nötigen (Aufruf-)Informationen für den Dispatcher. Der Dispatcher instanziert mit diesem Wissen den
richtigen Controller und ruft die richtigen Methode mit den richtigen Parameters auf.

Eine Routingklasse muss also Methoden für die Zerlegung der URL und die Verwaltung von Einträgen und die Suche
in einer Zurordnungstabelle bereitstellen. Hinzu tritt eine zusätzliche Aufgabe, die darin besteht, den
umgekehrten Weg zu gehen: nämlich eine URL zu generieren. Die URL Generierung ist insbesondere bei Formularen sehr hilfreich.
Anstatt die URL der Zielseite im "action" Attribut eines "form" Elements manuell festzulegen,
kann diese nun automatisch aus Modulenamen und Actionnamen generiert werden.

.Debbuging des Routings auf lokalem Apache Webserver Um das Routing und insbesondere die Rewrite Conditions
und Rewrite Rules zu testen und anschließend zu debuggen, empfehle ich die nachfolgende Einstellungen in die
globale Serverkonfiguration (httpd.conf) oder die spezifische VirtualHost-Konfiguration (vhost.conf)
aufzunehmen. Das Setzen dieser Einstellungen in der ".htaccess" im Anwendungspfad wird nur bis zur Apache
Version 1.3 unterstützt. Für Apache Version 2 sind die Einstellungen also zwingend in der globalen
Konfigurationsdatei zu machen (siehe dazu auch
http://httpd.apache.org/docs/2.2/mod/mod_rewrite.html#rewritelog).

Die Klasse bestimmt zunächst den RewriteMode. Der RewriteMode entscheided darüber, welcher URL-Parser
eingesetzt wird, um die URL zu zerlegen. Dazu wird geprüft, ob das Apache Modul ModRewrite verfügbar ist und
die RewriteEngine in der ".htaccess" aktiviert wurde. Bei Verfügbarkeit von ModRewrite wird die URL (etwa
"news/show/77") mittels der Methode UrlParser_Rewrite() zerlegt. Sollte ModRewrite nicht verfügbar sein, so
wird die URL (etwa "index.php?mod=news&action=show&id=77) mittels der Methode UrlParser_NoRewrite() zerlegt.

.Notwendige Angaben in der ".htaccess" um URL-Rewriting zu aktivieren
[source, php]
---------------------------------------------------------------------
Options -MultiViews

# Einschalten der RewriteEngine
RewriteEngine On

# Bedingungen für das Rewriting
RewriteCond %{REQUEST_FILENAME} !-d # physisch existierende Verzeichnisse ausschliessen
RewriteCond %{REQUEST_FILENAME} !-f # physisch existierende Dateien ausschliessen

# Anzuwendende Regel für das Rewriting
RewriteRule ^(.*)$ index.php [QSA,L]
---------------------------------------------------------------------

[source, php]
---------------------------------------------------------------------
# Pfadangabe für Linux:
RewriteLog /var/log/apache2/clansuite-rewrite.log
# Pfandangabe für Windows:
RewriteLog D:/xampplite/htdocs/work/clansuite/trunk/logs/clansuite-rewrite.log

# Angabe des Detailgrades der Meldungen bei der Abarbeitung der Rewrite Anweisungen.
# Die Parameterangabe reicht von 1 für spärliche Angaben, bis 9 für sehr detailierte Ausführungen.
RewriteLogLevel 9
---------------------------------------------------------------------

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Trail

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Security

Die Klasse Clansuite_Security stellt den Zugriff auf Streuwert-Methoden (hashing) bereit.
Die drei Methoden der Klasse ermöglichen eine Zeichenkette zu hashen, zu salzen und zu vergleichen.
Die Methode build_salted_hash() erstellt einen gesalzenen Hash.
Die Methode generate_hash() erstellt einen Hash einer Zeichenkette.
Die Methode generate_salt() erstellt eine zufällige Zeichenkette (genannt Salz).

.Allgemeines zum Thema-Hashing
Streuwert-Methoden oder Hashing-Methoden sind Funktionen zur Abbildung einer Zeichenkette auf eine
eindeutige (zumeist aus Buchstaben und Zahlen bestehende) Zeichenkette.

Man muss sich hierbei zwei Dinge vergegenwärtigen.
Erstens, dass Eindeutigkeit bedeutet, dass eine Ausgangszeichenkette immer genau einen Hash hat.

.Eindeutigkeit von Hashes
[source, php]
---------------------------------------------------------------------
Beispiel
$passwort_zeichenkette = 'meinPasswort';
$md5_hash_der_passwort_zeichenkette = md5($passwort_zeichenkette);
echo $md5_hash_der_passwort_zeichenkette; # = f14a298bc87fff2cd757f71054fdd94d
# Die Zeichenkette 'meinPasswort' entspricht dem MD5 Hash 'f14a298bc87fff2cd757f71054fdd94d'.
---------------------------------------------------------------------

Zweitens, dass ein Hash nicht umkehrbar ist. Man kann nicht von einem Hash auf die Ausgangszeichenkette schließen.
Die Unumkehrbarkeit von Hashes ist der Unterschied zur Verschlüsselung. Bei einer verschlüsselten Zeichenkette,
existiert ein Schlüssel und eine Methode, um sie in ihre Ausgangszeichenkette (regelmäßig den Klartext) umzuwandeln.

Das Hashing-Verfahren wird beispielsweise eingesetzt um zwei Dateien auf ihre Gleichheit zu überprüfen.
Anstatt nun einen zeichen- oder zeilenweisen Dateivergleich durchzuführen, wird für beide Dateien
ein Hash, also eine eindeutige Zeichenkette erzeugt. Man nennt diese Zeichenkette daher auch
Identifikator oder Fingerabdruck (engl. Fingerprint). Der Vergleich der Fingerabdrücke der beiden Dateien
gibt nun Auskunft über ihre Gleichheit oder Ungleichheit.

Im Bereich der Webanwendungssicherheit hat sich das Hashing für die Absicherung von Passwörtern als sinnvoll erwiesen.
Anstatt Benutzerpasswörter im Klartext in der Datenbank zu speichern werden sie nun gehashed abgespeichert.
Damit wird die Einsehbarkeit des Klartextes durch Administratoren oder Dritte, etwa
bei einem Datenbankeneinbruch oder -diebstahl, unterbunden. Der Angreifer erhält nun "nur" den Hash des Passworts.

.Angriffsmethoden auf gehashte Passwörter
Es gibt aber auch bei gehashten Passwörtern Angriffsmethoden. Eine Methode besteht darin, einfach alle Varianten
auszuprobieren. Eine weitere Methode setzt vorbereitete Tabellen als Nachschlagewerk ein.

Die erste Methode, die Brute-Force-Methode (Methode roher Gewaltanwendung) besteht darin,
Passwörter zusammenzusetzen und die erstellten Hashes nacheinander auszuprobieren.
Brute-Force-Algorithmen sind sehr einfach zu implementieren aber heillos ineffizient.
Der Rechenaufwand steigt proportional mit der Menge an zu probierenden Passwörtern.
Die Anzahl zu probierender Passwörter unterliegt dabei einem expotentiellen Wachstum.
Die Rechenleistung heutiger CPUs erlaubt es dennoch sehr viele Passwort-Möglichkeiten pro Zeiteinheit auszuprobieren.
Die Bedrohungslage im Bereich der Brute-Force Angriffe hat sich durch das Aufkommen
von extrem rechenstarken Grafikkarten nochmals verschärft.

In Sachen Gleitkommaoperationen (also Additionen und Multiplikationen) pro Sekunde kann eine
normale Mehrkern-CPU einer GPU, dem Rechenprozessor der Grafikkarte, niemals das Wasser reichen.
Ein Vergleich der Gleitkommaoperationen pro Sekunde (engl. Floating Point Operations per Second, abgekürzt FLOPS)
bei aktuellen Produkten (Januar 2010) mag dies verdeutlichen.
Ein Intel Core i7 965 XE Prozessor mit aktiviertem Hyper-Threading verfügt über 4 Kerne mit 3,2Ghz
und kostet rund 1000 Euro. Er erreicht in der Spitze 50 bzw. im Schnitt 33 GigaFlops.
Laut eines TechRadar Benchmarks sogar 69 GFlops. footnote:[http://mos.techradar.com/techradar-corei7-benchmarks.pdf]
Die Grafikkarte Nvidia GeForce GTX 295 ist bereits für unter 500 Euro im Handel erhältlich
und schafft rund 1750 GigaFlops. Die AMD Radeon HD 5970 knackte als erste Grafikkarte sogar
die 1-TeraFlops-Grenze und ist für rund 550 Euro im Handel erhältlich.

Für die Ermittlung dieser Rechenleistung wird zumeist auf das Programm "linpack" zurückgegriffen.
Eine webbasierte Linpack-Version findet man unter http://www.netlib.org/benchmark/linpackjava/.

Die Brute-Force-Programme greifen daher oftmals nicht mehr nur auf die CPU sondern insbesondere auf die GPU zu.
Webanwendungen müssen auf diese Bedrohung angemessen reagieren und mit der Zeit gehen.
Dazu gehört, dass Passwörter niedriger Stärke abgelehnt und neuere Hashverfahren und Salting eingesetzt werden.

.Vorteile von gesalzenden Hashes
Für gesalzene Hashes spricht, dass ein Angriff mittels einer Streuwerttabelle relativ nutzlos wird.

Streuwerttabellen beinhaltet eine vorgenerierte Liste an Hashes für eine Vielzahl von Wörtern und Zeichenkombination.
Man versucht bei einem solchen Angriff durch einen Vergleich des Hashes in der Datenbank mit dem Hash in
der Hash-Tabelle auf das eingesetzte Wort zu schließen. Da eine solche Streuwerttabelle unter Umständen
mehrere Terabyte an Daten enthält, ist sie erstens kaum zu verarbeiten und zweitens würde ein
vergleichender Rückschluß sehr lange dauern.

Um die Menge an Daten einer Streuwerttabelle zu verkleinern und sie somit in kurzer Zeit durchsuchbar zu machen,
wurde eine spezielle Form einer solchen Streuwertabelle entwickelt.
Diese Datenstruktur nennt man Regenbogentabelle (engl. Rainbow-Tables) und wurde vom Schweizer Informatiker
Philippe Oechslin im Jahr 2003 entwickelt footnote:[http://lasecwww.epfl.ch/pub/lasec/doc/Oech03.pdf],
wobei der Ansatz schon im Jahr 1980 durch Martin Hellman
footnote:[M. E. Hellman. A cryptanalytic time-memory trade off. IEEE Transactions on
Information Theory, IT-26:401–406, 1980] beschrieben wurde.
Rainbowtables sind in gewisser Weise stark verkleinerte Streuwert-Tabellen, in denen viele Passwörter
mit den dazugehörigen Hashes gespeichert sind.
Bei Regenbogentabellen werden nicht alle Ausgangswerte und Hashes gespeichert, sondern der
Wert wird zuerst gehashed und anschließend reduziert. Die Reduktion erzeugt eine Zeichenkette
mit der Länge des Ausgangswerts und ist damit also ein mögliches Passwort.
Dieser Prozess der Reduktion wird mehrmals durchlaufen, um eine bestimmt Menge (eine Kette) an möglichen
Passwörtern zur Verfügung zu haben (= ein Spektralbereich des Regenbogens).
In die Regenbogentabelle wird regelmäßig nur der Ausgangswert und der letzte Hashwert gespeichert
(Start und Ende des Spektralbereichs bzw. der Kette).
Das Nachschlagen in einer solchen Regenbogentabelle ist zweischrittig.
Der erste Schritt ist die Bestimmung der Kette. Fällt ein Hash in den Spektralbereich,
dann berechnet man diese Kette (diesen Teil des Spektralbereichs) neu.
Dabei hat man soviele Chancen den Ausgangswert zu finden, wie diese Kette lang ist.
Wenn der Hash in der Tabelle steht findet man das Passwort also viel schneller
als mit einem normalen Brute-Force Programm.

Daraus resultiert, dass unter Verwendung eines gesalzenen Hashes ein solcher Angriff
nur auf ein einzelnes Nutzerkonto ausgeführt werden kann, denn jeder Hash
ist aufgrund einer zufällige vorangestellten Zeichenkette erstellt worden.
Damit wird ein Problem behoben, dass entsteht, wenn mehrere Nutzerkonten das gleiche
Passwort verwenden, also identische Hashes haben. Anstatt zwei identischer Hashes
wird durch den zufälligen Salzanteil nun jeweils ein unterschiedlicher Hash erzeugt.

.Nachteile von gesalzenen Hashes
Die Passworter können wegen der Zufälligkeit nicht angefordert werden. Man kann sie nur neu generieren.
Das mag einerseits einen Useability-Nachteil bedeuten, andererseits bietet es einen deutlichen Sicherheitsvorteil.

.Die Bibliothek "phpass" und ein Blick auf andere CMS/CMF
Seit 2004 gibt es die Bibliothek "Portable PHP password hashing framework"
footnote:[http://www.openwall.com/phpass/] geschrieben von Solar Designer <solar[at]openwall.com>
unter einer Public Domain Lizenz.
Diese Bibliothek reimplementiert als Kernmethode den in PHP verfügbaren CRYPT_BLOWFISH Hashing-Algorithmus.
Der Blowfish Algorithmus wurde 1993 (im Jahr 2010 ist er 17 Jahre alt) durch Bruce Schneier
entwickelt und beschrieben footnote:[http://www.schneier.com/paper-blowfish-fse.html].
Das Blowfish Verfahren ist nicht patentiert und lizenzfrei verfügbar. footnote:[http://www.schneier.com/blowfish.html]
Diese Open-Source Verfügbarkeit bewirkte eine rasche Verbreitung in der Open-Source Szene.
Blowfish bietet auch heute noch (2010) eine mit aktuellen Algorithmen vergleichbare Sicherheit und Geschwindigkeit.
Als weitere Fallbacks bietet phpass ein CRYPT_EXT_DES und ein MD5-basiertes Hashing.
Diese Bibliothek wird von Backpress/Wordpress
footnote:[http://backpress.automattic.com/browser/tags/1.0.2/includes/class.passwordhash.php]
Drupal und TYPO3
footnote:[http://typo3.org/extensions/repository/view/t3sec_saltedpw/current/, Typo3 Extension T3Sec_SaltedPW]
eingesetzt.

.Instanzierung

Durch Autoloading kann jederzeit auf die Klasse zugegriffen werden.
Auch eine Constructor Injection ist möglich.

[source, php]
---------------------------------------------------------------------
# systemweites autoloading
$security = new Clansuite_Security();

# Holen des Objekts aus dem Dependency Injector
$config = $this->injector->instantiate('Clansuite_Security');

# Automatisches holen bei Verwendung der Constructor Dependency Injection
public function __construct(Clansuite_Security $security)
---------------------------------------------------------------------

.Verwendung

*Die Methode build_salted_hash()*
Die Methode nimmt als ersten Parameter eine Zeichenkette entgegen und als zweiten Parameter die
Abkürzung eines Hashing-Algorithmus. Diese Zeichenkette wird am Anfang mit einer zufällige Zeichenkette versehen.
Dieses Voranstellen einer zufälligen Zeichenkette nennt man salzen (engl. salting).
Die neu entstandene Kombination aus Salz+Zeichenkette wird dann der Hashing Methode generate_hash() übergeben,
um von ihr einen Hash als Rückgabewert zu erhalten.

*Die Methode generate_hash()*
Die Methode generiert einen Hash aus einer Zeichenkette unter Verwendung eines Hashing-Algorithmus.
Dabei wird auf die PHP-Funktion hash() zurückgegriffen.
Somit stehen beispielsweise die Hashing-Algorithmen md5, sha1, sha256 zur Verfügung.
Als das Standardverfahren ist sha1 festgelegt.
Um eine komplette Liste der verfügbaren Hashing Algorithmen des Kommandos hash() zu erhalten,
 eignet sich die PHP-Kommandokombination print_r(hash_algos()); .
Falls hash() nicht verfügbar sein sollte, wird als Fallback auf die PHP-Kommandos md5() bzw. sha1() zurückgegriffen.
Falls sie die PHP Extension "skein" installiert haben und in der Konfiguration als
Hash-Algorithmus 'skein' festgelegt haben, dann wird ein 512-bit Skein-Hash erstellt.
Sie finden die PHP Extension auf Skein Webseite unter http://www.skein-hash.info/downloads.

*Die Methode generate_salt()*
Diese Methode erzeugt einen Zufallsstring der gewünschten Länge.
Der Zufallsstring besteht Zahlen, sowie Groß- und Kleinbuchstaben und den Sonderzeichen '.' und '/'.
Die "Zufälligkeit" von Zeichen wird mittels mt_srand() and mt_rand() erzeugt.

==== Clansuite_Session

Das PHP Sessionhandling ist ein sicherheitskritischer Bereich. Die normalen PHP Sessions sind ungeschützt.

.Sicherung von Session-Cookie

a) Sicherung von Session-Cookies mittels SSL und Secure Flag
Wenn Clansuite mit SSL verwendet wird, ist das Cookie "secure" flag zu
setzen. Dies sorgt dafür, dass der Cookie nicht unverschlüsselt gesendet wird, sondern so verschlüsselt,
sodass niemand den Cookie stehlen kann.

b) Cookie HTTPONLY
Das Session-Cookie kann mittels der Konfigurationseinstellung "cookie_httpOnly" gegen XSS geschützt werden. In
diesem Fall werden Javascripte
wirksam davon ausgeschlossen die Session ID zu stehlen.

.Zufällige SessionID für jede Clansuite Installation
Falls zwei Clansuite Applikationen sich auf dem gleichen Server befinden und sich einen Sessionspace teilen,
ist es möglich das beide Applikationen gegenseitig Sicherheitslöcher in das Sessionhandling reißen. Es gibt
zwei Methoden um dies zu unterbinden: Erstens, wenn sie Clansuite_Session (DB) verwenden, legen Sie für jede
Installation eine Datenbank an. Installieren sie nicht zwei Clansuite Versionen (eine für ein Blog) die andere
für den Clan. Zweitens, wenns die Session im save_path abgespeichert wird, dann ist jeder Clansuite
Installation ein eigenes Sessionverzeichnis zu geben. So kommen die zwei Versionen sich nicht in die Quere.

.Niedrigen Session Timeout ansetzen (maxlifetime)
Je weniger Zeit ein Session Fenster hat, desto sicherer ist es.
Die Session Lifetime kann in der Clansuite Konfiguration eingestellt werden.

.Schutz vor Session Fixierung (Session Fixation)
Einer Session Fixation kann man nur durch Erneuerung der SessionID bei Änderung des Userstatus (login/logout)
begegnen. Die Erneuerung der Session erfolgt mittels Clansuite_Session::regenerateID().
Sie ist direkt mit der Login-Funktion verknüpft.

.Session Hijacking
Session Hijacking bedeutet, dass ein Dritter sich den Inhalt der Session zu eigen machen kann.
Häufig geschieht dies über Man-in-the-middle Attacken oder Sniffing/XSS.
Guten Schutz bietet nur die Verwendung von "cookie_httpOnly" und SSL-Verschlüsselung.

.Session Validation
Clansuite hat für die Sessionvalidierung den Filter Session Security.
Doch die Session Validierungsregeln, z. B. die Überprüfung, ob die Session von der gleichen IP oder
der Request vom gleichen User-Agent kommt, halten einem Session Hijacking nicht stand.
Zusätzlich bereiten Session-Überprüfungen eine Menge Probleme.
a) Man schließt bestimmte IPs aus.
Bei bestimmten Providern hat jeder Request eine neue IP (AOL). Stichwort: Proxy Farming.
b) User-Agent HTTP Header Checks
c) Accept Header Check
Aus vorgenannten Gründen wird vom Einsatz des Sessionfilters abgeraten.

.Instanzierung

.Verwendung

==== Clansuite_Upload

.Instanzierung

.Verwendung

==== Clansuite_Download

Die Klasse Clansuite_Download stellt die Methode send() bereit, mit der eine Datei an den Client gesendet werden kann.
Dabei ist es möglich die Downloadgeschwindigkeit zu beschränken und bestimmte Teilbereiche (ranged) auszuliefern, sowie
abgebrochene Downloads an alter Stelle wieder aufzunehmen (resume).
Die Beschränkung der Downloadgeschwindigkeit ist von diversen Downloadportalen bekannt, wo zwischen beschränktem, aber freiem Gast-Zugang
und unbeschränktem Mitgliederzugang, welcher dann oftmals kostenpflichtig ist, unterschieden wird.
Die Auslieferung von Teilbereichen einer Datei macht es möglich, gleichzeitig mehrere Connections zu öffnen und unterschiedliche Dateisegmente herunterzuladen.
Diese Funktionalität kommt Downloadmanagern sehr entgegen. Durch die Aufteilung in Segmente kann auch der Fortsetzungpunkt für einen abgebrochenen Dateitransfer bestimmt werden.
Die Klasse verwendet die PHP-Erweiterung fileinfo footnote:[http://php.net/manual/en/book.fileinfo.php]. Diese gehört seit PHP 5.3 zum Standardfunktionsumfang.

.Instanzierung und Verwendung

Die Klasse kann sowohl statisch als auch dynamisch eingesetzt werden.
Die Verwendung statischer Methoden wird empfohlen.

.Beispiel für die Verwendung von Clansuite_Download
[source, php]
---------------------------------------------------------------------
# Beide Beispiele senden die Datei "datei.zip" mit 10 KB/s an den Client

# dynamische Verwendung
$download = new Clansuite_Download();
$download->sendFile('datei.zip', 10);

# statische Verwendung
Clansuite_Download::send('datei.zip', 10);
---------------------------------------------------------------------