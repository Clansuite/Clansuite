////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc User Guide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find an AsciiDoc Sheet Cheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 5 - Das Framework und die einzelnen Core-Komponenten

In diesem Kapitel werden die einzelnen Bestandteile des Clansuite Frameworks erläutert. Dabei ist jeder
Komponente des Systems ein eigener Abschnitt gewidmet. Du findest hier auch Definitionen und Erklärungen zu den
verwendeten Entwurfsmustern und zum allgemeinen Systemaufbau, insbesondere zur Model-View-Controller
Architektur (MVC) des Systems.

=== Das Clansuite CMS und das Clansuite Framework

Das Clansuite CMS basiert auf dem Clansuite Framework. Wir schreiben unser eigenes Framework, um den Aufwand
zu minimieren, ständig neuen Code für das CMS entwickeln zu müssen. Die Verwendung des Frameworks minimiert
die Anzahl der Codezeilen die geschrieben werden müssen, um bestimmte Ziele mit dem CMS zu erreichen. Viele
Methoden werden einfach zur "standardisierten" Verwendung bereitgestellt. Das Clansuite Framework dient also
dazu, die Standardaufgaben, die ein jedes CMS erledigen muss, vor die Klammern zu ziehen. Das CMS Clansuite
ist als nutzerfreundliche fertige Anwendung gedacht, die lediglich konfiguriert werden muss. Dabei werden
die einzelnen CMS Dienste werden durch Module bereitgestellt. Es ist für Erweiterungen und Plugins offen.
Das Framework vereinfacht also die Entwicklung und gibt auch dem CMS eine bestimmte Struktur und Festigkeit.

.Input-Transformation-Output (ITO) oder Eingabe-Verarbeitung-Ausgabe (EVA-Prinzip)
Die Hauptaufgabe einer Webapplikation liegt darin, einen gegebenen Input in einen Output zu transformieren.
Der gegebenen Input ist dabei regelmäßig eine URL. Der zu erzeugende Ouput ist regelmäßig der vom Webbrowser
zu interpretierende und darzustellende Quelltext, beispielsweise im Format XHTML.

.Das Input-Transformation-Output Prinzip
["graphviz", "chapter05_image01_ito.png", alt="Input-Transformation-Output"]
---------------------------------------------------------------------
digraph G
{
    rankdir=LR;
    Input->Transformation->Output;
}
---------------------------------------------------------------------

.MVC-Muster und die Schichten einer Applikation
Das Clansuite Framework ist dabei als ein einfaches und klassisches Model-View-Controller (auch MVC genannt)
Framework konzipiert. Unter dem Model-View-Controller Aufbau versteht man den Einsatz von bestimmten
Entwurfsmustern (Design Patterns), um eine Applikation in Schichten (auch Layers oder Tiers) zu trennen.
Dieses Muster wurde entwickelt, um die Entwicklung im Bereich der Präsentationsschicht zu verbessern.

Das Model repräsentiert die Datenschicht. Regelmäßig wird innerhalb des Models eine Datenquelle angesteuert
und ihre Daten zurückgeliefert. Die Datenquelle kann dabei eine Datenbank und ihre Tabellen oder eine XML-
oder gar Textdatei sein.

Der View repräsentiert die Präsentationsschicht. Die Aufgabe der Präsentationsschicht ist es, die Daten,
welche sie vom Model bzw. Controller angereicht bekommt, aufzubereiten und auf eine bestimmte Ausgabeart
darzustellen. Zumeist arbeitet die Präsentationsschicht dabei mit sogenannten Ansichten (Views) die aus
Vorlagen (Templates) bestehen. Das View Objekt lädt dann das vom Controller zugewiesene Template und gibt es
aus. Als Ausgabeart kommt z. B. die Einbettung der Daten in XHTML-Quellcode Vorlagen in Betracht. Aber auch
eine Ausgabe der Daten im Format PDF oder RSS ist Aufgabe der Präsentationsschicht.

Der Controller ist für die Annahme einer Anfrage an die Webapplikation und damit für die Geschäftslogik
zuständig. Er untersucht die eingehenden Daten, welche regelmäßig in Form einer URI vorliegen, daraufhin,
welche Ansicht der Präsentationschicht mit Daten bestückt werden muss. Dabei können Controller hierarchisch
verbunden sein. Es entscheidet der erste Controller, welcher nachfolgende Controller für die Ansicht und ihre
Daten zuständig ist. Der Einstiegspunkt in die Webapplikation ist dabei zumeist die zentrale Datei index.php.
Die Datei ruft regelmäßig den Frontcontroller, also den Einstiegscontroller der Applikation auf, der einen
Subcontroller, zumeist einen Modulecontroller oder direkt einen Actioncontroller aufruft. Der Modulecontroller
repräsentiert die Geschäftslogik für alle Kommandos eines Moduls, also ein ganzes Kommandopaket. Der
Actioncontroller repräsentiert die Geschäftslogik für ein einzelnes Kommando innerhalb einer Applikation. Der
Frameworkaufbau von Clansuite untergliedert sich demnach in Komponenten der Präsentationschicht
(Frontcontroller mit Interception-Filtern, Eventhandler, sowie Template-View und Viewhelper Muster), der
Datenschicht (Active- Record Muster und objektrelationales Mapping mittels Doctrine) und der Geschäftslogik.
Das besondere Kennzeichen der Schichtenarchitektur ist die Tatsache, dass das Model weder die Views noch den
Controller kennt. Die Schichtentrennung ist wünschenswert, um die Hauptaufgaben einer Applikation austauschbar
zu machen und getrennt voneinander bearbeiten zu können. Hinzu tritt die Tatsache, dass es sich beim MVC-
Muster um eine Konvention, genauer um ein Ordnungsverfahren handelt, um die Arbeit mit komplexen Anwendungen
zu erleichtern und beherrschbar zu machen. Bedenkt man, dass Softwaresysteme regelmäßig an geänderte
Anforderungen angepasst werden müssen, dann ist der Siegeszug des MVC-Musters nicht verwunderlich. Die
Applikationsschichten sind getrennt voneinander wartbar, veränderbar, ergänzbar und austauschbar. Insbesondere
können die Schichten gleichzeitig und unabhängig voneinander bearbeitet werden.
Dies sichert die benötigte Weiterentwickelbarkeit (Evolvability).

.Das Model-View-Controller Entwurfsmuster
["graphviz", "chapter05_image02_mvc.png", alt="Model-View-Controller"]
---------------------------------------------------------------------
digraph G
{
    rankdir=LR;
    Input->Controller;
    Controller->Model;
    Model->Controller;
    Controller->View;
    View->Controller;
    Controller->Output;

    Input [shape=Mdiamond]
    Output [shape=Msquare]
}
---------------------------------------------------------------------

.Die Hilfskomponenten
Beim Framework sind neben den Mustern zur Umsetzung des MVC-Patterns noch die jeweiligen Hilfskomponenten zu
nennen. Für jeden MVC Bereich gibt es eigene Hilfskomponenten. Die Hilfskomponenten im Bereich des Controllers
sind zumeist Wrapperklassen, die Zugriffsmethoden auf fremde Bibliotheken bereitstellen. Ein Beispiel hierfür
wäre die Klasse Clansuite_Mailer, welche den Zugriff auf die Bibliothek SwiftMailer ermöglicht. Das Versenden
von Mails ist eine wesentliche, sich wiederholende Aufgabe. Der Mailer ist dafür verantwortlich, die
notwendigen Methoden zum Versenden von E-Mails bereitzustellen. Nicht jedes CMS Modul sollte aber dies
Funktionalität neu implementieren müssen, wenn das Versenden von E-Mails benötigt wird, daher wurde die
Funktionalität (hier Controller-Logik) in die Hilfskomponente ausgelagert. Hilfskomponenten kommen dabei aber
nicht nur im Bereich der Controller-Logik, sondern auch im Bereich des Views vor. Hier nennt man sie
Viewhelper. Die Viewhelper enthalten, Sie ahnen es bereits, wiederholend einsetzbare Präsentations-Logik. Der
Viewhelper "date" wird Sie beispielsweise dabei unterstüzen, den Datumsstring in das richtige Datumsformat
umzuwandeln und anzuzeigen. Im Bereich des Models stehen Behaviors und Event-Callbacks über Doctrine zur
Verfügung. Mit Behaviors ist es möglich, zwischen zwei oder mehreren Modellen gemeinsame Funktionalitäten
bereitzustellen. Mit Event-Callbacks ist es möglich, sich an den Moment, genauer das Ereignis, der Datenablage
dranzuhängen und gleichzeitig bestimmte andere Dinge auszulösen. Beispielsweise könnte man an das Ereignis
afterDelete($userid) das Loggen der Löschung eines Usersaccounts anhängen.

.Die MVC-Struktur im Überblick
["graphviz", "chapter05_image03_mvcstructure.png", alt="Clansuite MVC Structure"]
---------------------------------------------------------------------
digraph G
{
    Input->FrontControllerResolver;

    subgraph cluster_0 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Doctrine DBAL/ORM"
        Model->ModelHelper->Model;
    }

    subgraph cluster_1 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Render Engines"
        View->Layouttemplate->Subtemplates->Layouttemplate;
        View->ViewHelper->View;
    }

    subgraph cluster_2 {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        label = "Controllers"
        FrontControllerResolver->FrontController;
        FrontController->ModuleControllerResolver->ModuleController;
        ModuleController->Model->ModuleController;
        ModuleController->ComponentHelper->ModuleController;
    }

    ModuleController->View;
    ModuleController->Output;

    Input [shape=Mdiamond]
    Output [shape=Msquare]
}
---------------------------------------------------------------------

.Der Applikationsfluss im Überblick
Eine Anforderungen an die Applikation nach dem MVC-Modell kann in fünf grundlegende Schritte unterteilt werden:

1. Ausgangspunkt ist der Empfang einer URL vom Client.
2. Das Resolver- oder Routingsystem analysiert diese URL und identifiziert den Controllernamen. und sucht nun anhand des
   Controllernamens das richtige Controllerobjekt.
3. Aufrufen der richtigen Controllermethode auf dem richtigen Controllerobjekt.
4. Auswählen der richtigen Ansicht und Holen der Modelldaten, die von der Controllermethode
   zu dieser Ansicht generiert werden.
5. Das Rendern der Ansicht.


=== Architektur und Design des Frameworks

==== Dependency Injection

===== Constructor Injection

===== Setter based Injection

=== Die Komponenten des Frameworks

==== Clansuite_HttpRequest

Die Klasse Clansuite_HttpRequest abstrahiert den Zugriff auf die Daten einer HTTP-Anfrage. Unter einer HTTP-
Anfrage versteht man den gesamten eingehenden Datenstrom (auch Input genannt) einer Anwendung. Bei einer HTTP-
Anfrage sind die Daten grundsätzlich über die superglobalen Variablen ($_REQUEST, $_POST, $_GET, $_COOKIE,
$_SERVER, $_FILES und $_ENV) zu erreichen. Diese Variablen werden allerdings von PHP unbereinigt und als
konkrete Implementierung bereitgestellt. Die Hauptaufgabe der Klasse Clansuite_HttpRequest besteht daher in
der Bereinigung der superglobalen Variablen $_REQUEST, $_POST, $_GET, $_COOKIE, $_SERVER, $_FILES, $_ENV und
dem Anbieten von Methoden zum Abruf der bereinigten Arrays. Die eingehenden Daten werden nicht direkt aus der
PHP- Umgebung, sondern über einen Umweg, nämlich aus dem HttpRequest Objekt geholt. Ein direkter Zugriff auf
die unbereinigten globalen Variablen (raw data) ist weiterhin möglich, sollte aber aus Sicherheitsgründen
vermieden werden. Eine weitere Aufgabe der Klasse besteht darin, die Effekte des "magic quoting" zu
beseitigen.

.Sicherheit mittels Clansuite_Doorkeeper
Des weiteren wird mittels der Klasse Clansuite_Doorkeeper (Türsteher) versucht Einbruchsversuche in die
Webanwendung zu erkennen und potentiellen Eindringlingen den Zugang zum System zu verweigern. Als System zur
Einbruchserkennugn wird das PHP Intrusion Detection System (PHPIDS) eingesetzt. PHPIDS wird seit Mai 2007 von
Mario Heiderich, Christan Matthies und Lars Strojny entwickelt. Es untersucht die Benutzereingaben auf
schadhafte Zeichen, Zeichenketten oder Skriptanteile. Erkannt werden XSS-Angriffe (Cross-Side-Scripting), SQL-
Injektionsversuche (SQLI), Remote File Inclusions, Remote File Executions (RFE) und LDAP-Injektionen.

.Bereitstellung der REST-Funktionalität
Eine weitere wesentliche Aufgabe ist die Bereitstellung der REST-Funktionalität. Die Abkürzung REST steht für
den Fachbegriff Representational State Transfer. REST ist ein Softwarearchitekturstil, welcher ein
resourcenorientiertes Denken forciert und für verteilte Applikationen entwickelt wurde. Es ist absichtlich
sehr einfach gehalten und basiert nur auf wenigen Grundprinzipien und wohldefinierten Methoden. Der Begriff
wurde durch die Dissertation von Roy Fielding aus dem Jahr 2000 eingeführt. Fielding ist einer der
Hauptautoren der Spezifikation des HTTP-Protokolls. Er ruft nochmals in Errinerung was die bestehende
Mechanismen und Protokolle des WWW (z. B. HTTP) teilweise schon definieren. REST ist neben den Alternativen
XML-RPC und SOAP eine Methode zur Umsetzung von Webservices und damit ein
Schlüsselwort des Web2.0.

.Rest-Grundprinzipien
Nachfolgend werden die Grundprinzipien von REST dargestellt.

1 Alles ist eine Resource::
    Eines dieser Prinzipien lautet "Alles ist eine Resource". Resource ist dabei jede Datenquelle.
    Einige werden hier eine Ähnlichkeit zum Linux-Prinzip "Alles ist eine Datei." feststellen.

2 Name (URI)::
    Jede Resource hat einen eindeutigen Namen.

3 Links::
    Jede Resource ist mittels eines Hyperlinks ansprechbar.

4 Verben (CRUD)::
    Die Methoden von REST sind einfache und selbstverständliche Verben.
    Für den Zugriff auf eine Ressource stehen die folgenden Methoden zur Verfügung:
    Create (POST), Read (GET), Update (PUT), Delete (DELETE).

5 Representation::
    Resourcen können mehrere Representationen haben.
    So kann die Ressource "Benutzerliste" sowohl in HTML, XHTML, CSV oder PDF repräsentiert werden.

6 Zustandslose Kommunikation (Skalierbarkeit)::
    Die Kommunikation mit dem Server einer Ressource beschränkt sich jeweils auf eine einzelne Anfrage. Der Server
    erwartet also keinen Kommunikationsvorgang bei dem Daten einer vorherigen Anfrage zwischengespeichert werden
    müssen. Letzteres würde dazu führen, dass mit steigender Anzahl an Anfragen die Serverlast steigt, da für
    jeden Client die Daten zwischen zwei oder mehreren Anfragen vorgehalten werden müssen. Berücksichtigt man nun
    die darunterliegenden zustandslosen Protokolle, wie HTTP und und fördert die Entdeckung und Verwendung der
    Resourcen. Führt dies dazu, dass wesentlich mehr Clients auf den Server zugreifen können, da die
    Serverresourcen geschont werden. Eine zustandslose Kommunikation erhöht also die Skalierbarkeit.

7 Schichtenaufbau::
    REST ist in Schichten aufgebaut. Dabei kann eine beliebige Anzahl an Zwischenebenen oder intelligenten
    Zwischendiensten, wie z. B. Caches, Proxies oder Gateways eingesetzt werden.

footnote:[Fielding, Roy Thomas: Architectural Styles and the Design of Network-based Software Architectures.
PhD Thesis, University of California, Irvine, 2000, http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm]
footnote:[Atom Publishing Protocol (RFC5023), http://www.ietf.org/rfc/rfc5023.txt]
footnote:[HTTP/1.1 Specifiction (RFC 2616), http://www.w3.org/Protocols/rfc2616/rfc2616.html]
footnote:[Yahoo! Group: rest-discuss, http://tech.groups.yahoo.com/group/rest-discuss/]
footnote:[http://restpatterns.org/]
footnote:[Alan Dean, http://www.simplewebservices.org/]
footnote:[Stefan Tilkov, http://rest-http.info/, Webseite zum Buch "REST und HTTP".]

.Das Clansuite_HttpRequest Objekt
["graphviz", "chapter05_image04_httprequest.png", alt="Clansuite HttpRequest Object"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    Input->struct1:webserver;
    struct1:php->struct2:httprequest->Controller;
    Controller->struct2:httprequest;

    struct1 [label="<webserver> Webserverumgebung  | {<php> PHP | { ENV | SERVER | GET | POST | REQUEST | COOKIE } }"];

    struct2 [label="<httprequest> HttpRequest | PHP Intrusion Detection System | { ENV | SERVER | GET | POST | REQUEST | COOKIE }"];

    Input [shape=Mdiamond]
}
---------------------------------------------------------------------

.Instanzierung

Die Klasse wird bei Systeminitialisierung dem Dependency Injector übergeben und steht sodann in dessen
Registry zum Abruf bereit.

Das HttpRequest Objekt kann auf zwei Arten geholt werden. Erstens ist ein systemweiter Zugriff auf das Objekt
durch den Zugriff auf den Dependency Injector gegeben.

[source, php]
---------------------------------------------------------------------
# Holen des Objekts HttpRequest aus dem Dependecy Injector
$request = $this->injector->instantiate('Clansuite_HttpRequest');
---------------------------------------------------------------------

Zweitens kann in einer Klasse sind die sich vom Modulecontroller ableitet (das wird regelmäßig ein
ActionController sein) das Objekt mittels der Methode this->getHttpRequest() des ModuleControllers geholt
werden. Diese Methode ist eine Befehlsabkürzung (engl. auch Shortcut, Proxy oder Convenience Methode genannt).

[source, php]
---------------------------------------------------------------------
# Holen des Objekts HttpRequest innerhalb einer Kindklasse des ModuleControllers
$request = $this->getHttpRequest();
---------------------------------------------------------------------

.Verwendung

[source, php]
---------------------------------------------------------------------
# Holen des Objekts für einmalige Verwendung und holen des Parameters "stadt" (Method Chaining/Fluent Interface)
$stadt = $this->getHttpRequest()->getParameter('stadt');

# Holen des Objekts HttpRequest (für mehrmalige Verwendung)
$request = $this->getHttpRequest();

# Holen des Parameters 'news_category_form' aus dem Request Objekt.
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form');

# Holen des Parameters 'news_category_form' aus dem Request Objekt unter Angabe des Arraynames "REQUEST".
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form', 'REQUEST');

# Holen des Parameters 'news_category_form' aus dem Request Objekt unter Angabe des Shortcuts "R" für den Arraynamen.
# Der Parameter wird aus dem Array $request_parameters des Request Objekts geholt.
$form = $request->getParameter('news_category_form', 'R');

# Holen des Parameters 'hausnummer' aus dem Request Objekt.
# Der Parameter wird mittels Shortcut "G" aus dem Array $get_parameters des Request Objekts geholt.
$haus_nr = $request->getParameter('hausnummer', 'G');

# Holen des Parameters ['news_form_categories]['cat_id'] unter Verwendung von ArrayAccess.
$cat_id = $request['news_form_categories]['cat_id];
---------------------------------------------------------------------

Hinweis: der Zugriff auf mehrdimensionale Arrays wird durch die Verwendung von ArrayAccess erheblich
vereinfacht. ArrayAccess bedeutet, dass ein Objekt und seine Eigenschaften auf die gleiche Art und Weise
angesprochen werden können, wie ein Array. So können auch Unterarrays und deren Schlüssel einfach angesprochen
werden.
Bei Übergabe von mehrdimensionalen Formulardaten empfiehlt sich die Verwendung von ArrayAccess besonders.

[source, php]
---------------------------------------------------------------------
# Das HTML-Formular beinhaltet ein Name Attribut mit mehrdimensionalem Aufbau.
# Dadurch werden die Daten als mehrdimensionales Array an den Server geschickt.
<input type="text" name="formular[1][variablename]" value="0"/><br />

# Das Array hat die folgende Struktur:
array( [formular] => array ( [1] => array( [variablenname] => 'wert' ) ) )

# Der Zugriff erfolgt über $request mittels ArrayAccess:
$variablenname = $request['formular']['1']['variablenname'];
---------------------------------------------------------------------

==== Clansuite_Doorkeeper

In unmittelbarem Zusammenhang mit den Sicherungs- und Bereinigungsfunktionen der HttpRequest-Klasse
steht die Klasse Clansuite_Doorkeeper.

.Instanzierung

Die Klasse wird innerhalb der HttpRequest-Klasse instanziert.

.Verwendung

Die Hauptmethode dieser Klasse ist runIDS(). Sie bewirkt die Initialisierung und den Start des Intrusion-
Detection-Systems (PHPIDS). Mehr über die Funktionsweise von PHPIDS erfahren sie im Kapitel 10.

==== Clansuite_HttpResponse

Die Klasse Clansuite_HttpResponse übernimmt die Funktion einer abstrakten Ausgabeklasse. Sie sendet die
notwendigen HTTP-Header, aktiviert die GZip-Kompression und gibt den gesamten Content ($body) an den Client
aus. Die Klasse ist für den Output zuständig.

.Instanzierung

.Verwendung

==== Clansuite_Frontcontroller

Clansuite wird durch Aufruf der Einstiegsdatei "index.php" gestartet.
Der Aufruf des Frontcontrollers erfolgt bei Clansuite nach der Initialisierung des Systems.
Der Frontcontroller nimmt die Anfrage (Request) entgegen und leitet sie an den entsprechenden 
Module-Controller bzw. Action-Controller weiter.
footnote:[http://www.martinfowler.com/eaaCatalog/frontController.html, Martin Fowler - FrontController im eaaCatalog]
footnote:[http://java.sun.com/blueprints/corej2eepatterns/Patterns/FrontController.html, J2EE Pattern FrontController]

.Ein einfacher Frontcontroller
["graphviz", "chapter05_image05_simplefrontcontroller.png", alt="Clansuite Simple Frontcontroller Workflow"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]
    HttpRequest->struct1:FC;    
    struct1:pR->ModuleController->ActionController->HttpResponse;
    struct1 [label="<FC> FrontController | { <pR> processRequest }"]
}
---------------------------------------------------------------------

.Was ist ein ModuleController bzw. ApplicationController?
Bei Clansuite nennen sich ApplicationController ModuleController.
Sie sind zuständig für einen kompletten Teilbereich des CMS.
Beispielsweise das Modul zur Verwaltung von Artikeln (News).
footnote:[http://www.martinfowler.com/eaaCatalog/applicationController.html]

.Was ist ein ActionController?
ActionController ist ein Kommando der Applikation.
Beispielsweise das Kommando action_show() im Modul News.
Wird dieses Kommando ausgeführt, so bewirkt es die Anzeige aller gespeicherten Artikel des News-Moduls.

Clansuite setzt nicht nur einen einfachen FrontController ein.
Der FrontController, mit seiner Hauptmethode processRequest(), wird durch Vor- und Nachfilter erweitert.

.Der mit Interception-Filtern erweiterte Frontcontroller
["graphviz", "chapter05_image06_frontcontrollerwithfilters.png", alt="Clansuite Frontcontroller with Interception Filters"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]

    HttpRequest->struct1:FC;
    struct1:pR->HttpResponse;

    subgraph cluster_0
    {
        style=filled;
        color=lightgrey;
        node [style=filled, color=white];
        struct1 [label="<FC> FrontController | { <preF> Vorfilter | <pR> processRequest | <postF> Nachfilter }"]
   }
}
---------------------------------------------------------------------

.Start des Clansutie Frontcontrollers
["graphviz", "chapter05_image05_startfrontcontroller.png", alt="Clansuite Frontcontroller Start"]
---------------------------------------------------------------------
digraph G
{
    compound="true";
    remincross="true";
    rankdir=LR
    graph [size="10.3,5.3", ranksep=0.5, nodesep=0.1, overlap=false, start=1]
    node  [shape=Mrecord, color="#BBBBBB"]
    node  [fontname=Verdana, fontsize=12, height=0.02, width=0.02]
    edge  [color="#31CEF0", len=0.4]
    edge  [fontname=Arial, fontsize=11, fontcolor="#31CEF0"]
    
    struct1 [label="<FC> FrontController | HttpRequest | HttpResponse | DependencyInjector | { { Prefilter | <preF> addPreFilters } | <pR> processRequest | { Postfilter | <postF> addPostFilters } }"]
}
---------------------------------------------------------------------

Dieses Bild zeigt das Frontcontroller Objekt nach dem Aufruf der Methode Clansuite_CMS::execute_Frontcontroller() 
innerhalb von /bootstrap/clansuite.application.php.

Dem Frontcontroller werden der ModuleControllerResolver und der ActionControllerResolver,
sowie der Dependency Injector übergeben.
Die in einem Konfigurationsarray befindlichen Vor- und Nachfilter werden dem Frontcontroller
mittels der Methoden addPreFilter() und addPostFilter() hinzugefügt.
Durch Aufruf der Methode processRequest($request, $response) werden Request und Response Objekt
an den Frontcontroller übergeben. Die weitere Bearbeitung des Requests obliegt nun dem Frontcontroller.

.Der Ablauf im Frontcontroller - Clansuite_Frontcontroller::processRequest()
[source, txt]
---------------------------------------------------------------------
1. Den richtigen ModuleController ermitteln
   Dazu Clansuite_ControllerResolver befragen
2. Vorfilter abarbeiten
3. Dependency Injector an den ModuleController weitergeben
#. Hinzufügen eines ActionControllers mit dem ModuleDecorator
4. Aufruf des ModuleControllers
5. Aufruf des ActionControllers
6. Nachfilter abarbeiten
#7. fetches view / implicit getRenderEngine
#8. assign view to response / implicit getTemplate
9. Ausgabe
---------------------------------------------------------------------

Das Schema verdeutlich, wie die Methode processRequest() des Frontcontroller vorgeht.
Dabei geht es zunächst darum, aus dem eingehenden Request den richtigen ModuleController herauszufinden.
Dazu dient das ModuleControllerResolver Objekt.
Damit im ModuleController die Kernkomponenten zur Verfügung stehen, wird der
DI an den Modulecontroller weitergegeben (3).

Danach geht um den Aufruf des ModuleControllers (4) und des ActionControllers (5).
Der ActionController wird wiederrum mittels des ActionControllerResolvers ermittelt.

Dieser wird umlagert von der Ausführung der Vor- und Nachfilter.
Die Abarbeitung der Vorfilter (2) bewirkt möglicherweise eine Modifikation des Request Objekts.
Die Abarbeitung der Nachfilter (6) bewirkt möglicherweise eine Modifikation der Ausgabe
bevor sie ins Response Objekt gegeben wird.

Der ActionController bestimmt die Ausgabeengine und übergibt die Daten die ausgegeben werden sollen.
Um die Ausgabe zu bewirken (9), ruft der Frontcontroller die Methode flush() des HttpResponse Objekts auf.

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Filtermanager

Der Filtermanager ist eng mit dem Frontcontroller verwoben. Jedem Aufruf der Hauptmethode processRequest() des
Frontcontrollers können ein oder mehrere Vorfilter vorgeschaltet oder ein oder mehrere Nachfilter
nachgeschaltet werden. Um diese Funktionalität im Frontcontroller abzubilden wurden die zwei Arrays
$preFilters und $postFilters erstellt, welche jeweils eine Instanz des Filtermanager Objekts enthalten. Der
Filtermanager stellt nur sehr wenige Methoden bereit. Hauptsächlich geht es darum Filter zu registrieren und
auszuführen. Zum einen stellt er die Methode addFilter() bereit. Mit ihr lassen sich neue Filter hinzuzufügen.
Sie akzeptiert Objekte, welche das Filter Interface implementieren, und somit vom Typ Filter sind. Die
Hauptmethode des Filtermanagers ist processFilters(). Sie iteriert über alle registrierten Filter und führt
sie aus. Die Iteration folgt dabei der Reihenfolge der Registrierung.

.Instanzierung

.Verwendung

.Entwurfsmuster

*Frontcontroller*
Die Klasse Clansuite_Filtermanager ergänzt den Frontcontroller.
Der Frontcontroller kann eine Anfrage nur an den ModuleController und weitere Untercontroller weiterreichen,
um sie zu beantworten. Neue Funktionen könnten nur durch Änderung eines bestehenden oder hinzufügen eines neuen Controllers geschaffen werden.

*Interception-Filters*
Das Entwurfsmuster Intercepting-Filter hilft weiter.
footnote:[http://java.sun.com/blueprints/corej2eepatterns/Patterns/InterceptingFilter.html]
Damit lässt sich die Hauptmethode processRequest() mit einem
Vorprozess und einem Nachprozess umhüllen. Ein Vorprozess ist in der Lage die Anfrage zu verändern.
Ein Nachprozess ist in der Lage die Ausgabe zu beeinflussen. Dadurch können beliebig viele Filter
hinzugefügt oder wieder entfernt werden, ohne den Code des Frontcontrollers ändern zu müssen.

Beim Intercepting-Filter-Musters implementiert jeder Filter das Filterinterface.
Die Filter sind wiederverwendbar, sequenziell aufrufbar und lose an die Geschäftslogik und andere Filter gekoppelt.
In der Java-Welt gibt es seit Version 2.3 der Servlet Spezifikation, ein Standardinterface Filter footnote:[http://java.sun.com/products/servlet/Filters.html].
Eine Intercepting-Filter-Implementation als Teil der PHP-SPL sucht man leider vergeblich.

===== Das Filter Interface

Jeder Filter implementiert das Filter Interface (implements Clansuite_Filter_Interface).
Damit wird sichergestellt, dass der konkrete Filter alle Methoden eines abstrakten Filters bereitstellt.
Dazu gehört inbesondere das Vorhandensein der Hauptmethode executeFilter().

===== Übersicht zu den Filtern

.Vorfilter

1. Theme_via_get
2. Language_via_get
3. Statistic
4. Startup_checks
5. Set_modulelanguage
6. Maintenance
7. Ajax Request
8. Get User
9. Permissions
10. Php_debug_console
11. Session security
12. Process cronjobs

.Nachfilter

1. Html Tidy
2. Smarty Moves

TIP: Die Erstellung eines Filters, der den Output komprimieren soll ist nicht erforderlich. Diese Aufgabe wird durch die Klasse Http_Response gehandhabt.

==== Clansuite_Configuration

.Instanzierung

.Verwendung

.Entwurfsmuster

===== Die Configuration-Adapter

====== Configuration: YAML

.Allgemeines zum YAML-Format

Das YAML Konfigurationsformat ist relativ minimalistisch und basiert auf Textdateien.
Die offiziellen Webseite definiert YAML (YAML Ain't Markup Language), als einen menschenlesbaren,
programiersprachenübergreifenden Standard zur Datenserialisierung.
Es wurde entwickelt, um die Lesbarkeitsschwierigkeiten aufgrund von Klammerung und Verschachtelung
bei PHP-Arrays und anderen Ausdrucksmitteln für Konfiguration zu umgehen.
Ziel war eine Konfigurationsprache zu schreiben, die auch für Nicht-Programmierer lesbar und einfach einzusetzen ist.
Die offizielle Webseite ist http://yaml.org/.
Die Spezifikation von YAML Aint Markup Language vor finden sie unter http://www.yaml.org/spec/1.2/spec.html.
Seit dem 1.Oktober 2009 liegt nunmehr die Version 1.2 der Spec vor.

Beim YAML-Format wird durch Einrückungen des Text eine Struktur erzeugt.
Um eine Textdatei des YAML-Formats zu lesen und die in ihr enthaltenen Zeichenketten wieder
in eine Arraystruktur mit Schlüsseln und Werten zu verwandeln ist ein Parser notwendig.
Der YAML-Parser wertet dabei insbesondere die zur Strukturierung des Konfigurationstextes dienenden Leerzeichen aus.

.Vergleich der Konfiguration mittels PHP-Array und YAML
[source, php]
---------------------------------------------------------------------
# definition als php-array
$configuration = array(
                        'konfigurationssektion' => array(
                                                            'element1' => 'wert1',
                                                            'element2' => 'wert2',
                                                            'element3' => 'wert3'
                                                        )
                      );

# definition als yaml

konfigurationssektion:
  element1: wert1
  element2: wert2
  element3: wert3
---------------------------------------------------------------------

Das YAML-Format wurde in der PHP-Welt insbesondere mit Aufkommen des PHP-Frameworks Symfony sehr populär, wo es standardmäßig eingesetzt wird.
Der dort entstandene Parser implementiert einen Großteil der YAML 1.1 Spezifikation und wird als eigenständige
Bibliothek sfYaml weiterentwickelt. Fabien Potencier der Symfony-Gründer wird nicht müde, diese Klasse und das Format zu bewerben.

Ein Serialisierungsformat das auf YAML beruht ist JSON.

TIP: Wer YAML sagt, meint auch oft das von Dirk Jesse entwickelte (X)HTML/CSS Framework mit dem Namen "Yet Antoher Multicolumn Layout".
Es ist ein sehr komfortables Layoutgerüst unter CC-A 2.0 Lizenz. Sie finden das YAM-Layoutprojekt unter http://www.yaml.de/ und
weitere Projekte des Autors unter http://www.highresolution.info/webdev/.

.Arbeitsweise des Konfigurationsadapters YAML

Der Konfigurationsadapter YAML erweitert die Basisklasse Clansuite_Config_Base und implementiert das ArrayAccess Interface.
Die beiden Hauptmethoden sind readConfig() und writeConfig(). Nach erfolgreichem readConfig() kann ein Zugriff per ArrayAccess erfolgen.
Es ist ein Wrapper der zwei Parser-Bibliotheken umspannt. Primär untersützt der Wrapper die in C-geschriebene PHP-Extension SYCK.
Diese ist über PECL verfügbar. Sollte diese PHP-Extension nicht verfügbar sein, so wird sekundär, auf die PHP-Bibliothek SPYC zurückgegriffen.
SPYC muss dazu in das Verzeichnis /libraries/spyc/ installiert werden.

====== Configuration: DB

====== Configuration: INI

====== Configuration: XML

==== Clansuite_Eventhandler

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Renderer

Für die Präsentationsschicht ist die Klasse Clansuite_Renderer zuständig. Diese ist Bestandteil des Applikationskerns.

Jeder Rückgabewert des Systems ist ein Output und wird über die Response-Klasse abgewickelt.
Die Contentzuweisung an die Response-Klasse wird durch eine Ausgabevorbereitungs-Methode veranlasst.
Diese setzt regelmäßig eine bestimmte RenderEngine ein, um den Output aufzubereiten.
RenderEngines umfassen dabei Ausgabeformate und TemplateEngines.
Hinzu kommt die Ausgabe über den HTTP-Header.

Folgende Ausgabeformate werden zur Zeit von Clansuite unterstützt:
CVS, JSON, PDF, Serialized.

Folgende Template-Engines werden unterstützt:
PHPTAL, Smarty, XSLT, Xtemplate.
Die standardmäßige Template-Engine ist Smarty.

Desweiteren ist es möglich Einfluß auf den HTTP-Header zu nehmen, um Daten zu senden.
Dies wird beispielseweise beim Logger Firebug so gemacht.

.Instanzierung

.Verwendung

.Entwurfsmuster

Das zugrundeliegende Entwurfsmuser für das Ausgabeverhalten von Clansuite nennt sich Two-Step-View.
Dabei werden zuerst Inhalte gerendert und diese danach in das Layout eingesetzt.
Dieses zweischrittige Verfahren ermöglicht, dass zusätzliche Elemente wie JavaScript und CSS in das Layout in Abhängigkeit vom Inhalt eingebunden werden können.

===== Die RenderEngine Adapter

====== Renderer: CVS

Der Renderer CVS nimmt Daten auf und gibt sie in der Form als komma-getrennte Werte zurück.
CVS steht für die Abkürzung für Comma-Separated Values und ist ein Dateiformat (.csv).
Es wird in der Spezifikation RFC 4180 footnote:[http://tools.ietf.org/html/rfc4180] näher beschrieben,
aber ein Standard exisitert nicht. Gerade dies macht das Wiedereinlesen einer CVS-Datenstruktur
relativ schwer, da jeder auf seine Weise strukturieren kann.

====== Renderer: JSON

Der JSON-Renderer JSON nimmt Daten auf und sie JSON serialisiert zurück.
Die Serialisierung erfolgt mittels der PHP Extension JSON, die nunmehr seit PHP-Version 5.2.1 standardmäßig vorhanden ist.

.Allgemeines zu JSON (JavaScript Object Notation)
JSON steht für JavaScript Object Notation und ist ein Datenaustauschformat.
Es ist eine Untergruppe des YAML-Formats und beschrieben in RFC 4627 footnote:[http://www.ietf.org/rfc/rfc4627.txt?number=4627].
Populär wurde es durch die Verbindung und Nutzung mit Ajax. Zwar kommt auch XML als ein Tauschmittel für Ajax in Betracht, doch sind XML-Baumstrukturen nur schwer lesbar und größer.
JSON kann eine Vielzahl von Datenstrukturelementen aufnehmen und abbilden.
Das entstehende Objekt eignet sich zum Transport und die enthaltenen Daten können einfach addressiert werden.

TIP: Ein oft gemachter Fehler ist, JSON mit einem JavaScript Array gleichzusetzen. Der feine Unterschied besteht darin,
dass JSON eine Objekt-Notation ist, die wie ein Array addressiert werden kann.

Es gibt in der PHP-Welt zahlreiche Klassen um JSON zu parsen.
Aber ist nicht verwunderlich ist, dass der PHP eigene Parser schneller ist, als alle in PHP geschriebenen Parser.
Schließlich ist er in C implementiert. Ein Vergleich zahlreicher Parser-Klassen bestätigt diesen Fakt.
footnote:[http://gggeek.altervista.org/sw/article_20061113.html]
footnote:[http://gggeek.altervista.org/sw/article_20070425.html]

====== Renderer: PDF

====== Renderer: PHP

====== Renderer: PHPTAL

====== Renderer: Serialized

====== Renderer: Smarty

====== Renderer: XSLT

====== Renderer: Xtemplate

==== Clansuite_Cache

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Die Cache-Adapter

===== Cache: APC

===== Cache: eAccelerator

===== Cache: File

===== Cache: Memcached

===== Cache: xcache

==== Clansuite_Cronjobs

===== Allgemeines

Die Klasse Clansuite_Cronjobs (auch Pseudocron genannt) ermöglicht eine intervallgebundene Ausführung von
selbst bestimmbaren Kommandos. Beispielsweise kann man wöchentlich die Datenbank sichern, stündlich Feeds
aktualisieren oder täglich den Template-Cache leeren oder die Sitemap neu generieren lassen. Dabei kann jedes
PHP-Skript ausgeführt werden, wobei das Ausführungsintervall periodisch, also wiederkehrend oder zeitgesteuert
sein kann. Die ausgeführten Cronjobs werden in einem Log gespeichert. Aus einem Cronjob können Nachrichten ins
Log gespeichert werden. Unter Crontab versteht man die Cron-Tabelle. Sie enthält die Zeitangaben und die
auszuführenden Kommandos. Die Notation eines Cronjob in der Crontab erfolgt im Unix Cron Syntax.

Ein zulässiger Crontabeintrag könnte wiefolgt aussehen:

[source, txt]
---------------------------------------------------------------------
2   1,15    *   *   beispiel.cronjob.php
---------------------------------------------------------------------
Dieser Eintrag hätte zur Folge, das "beispiel.cronjob.php" um 2 Uhr am ersten und fünfzehnten jedes
Monats ausgeführt werden.

.PHP5-Portierung von pseudo-cron v1.3
Clansuite_Cronjobs ist ein Fork, genauer eine PHP5-Portierung, der
bekannten PHP-Klasse pseudo-cron von Kai Blankenhorn (http://www.bitfolge.de/pseudocron). Die letzte Version,
pseudo-cron v1.3, wurde am 15.06.2004 veröffentlicht. Die Veröffentlichung der PHP5 Portierung erfolgte am
10.05.2008 als Minor-Release mit der Versionsnummer v1.4. Dabei wurden die globalen Variablen entfernt, sowie
Handler für datei- sowie datenbankbasiertes Crontab-Scheduling hinzugefügt.

===== Möglichkeiten des Cronjob Triggerings

Es gibt mehrere Möglichkeiten Cronjobs zu triggern.

.Die Vorfilter Methode
Beispielsweise kann eine Kontrolle auf anstehende Cronjobs als ein Vorfilter des Systems angelegt werden.

.Die Image-Tag Methode
Der Cronjob kann auch über den HTML Tag <img> ausgelöst werden. Beide Möglichkeiten hätten zur Folge, dass
jeder Webseitenbesuch auch eine Prüfung des Crontabs auf anstehende Aufgaben auslöst.

.Die Kopplung an den "echten" Cronjob des Betriebssystems
Im Gegensatz zum normalen, betriebssystemgesteuerten Cronjob ist mit Clansuite_Cronjob jedoch keine exakte
zeitliche Ausführung der Kommandos möglich, da das Cronjobsystem immer an Ereignisse der Webanwendung geknüpft
ist. Finden keine Ereignisse statt, werden die Cronjobs auch nicht ausgeführt. Wenn Sie beispielsweise einen
stündlichen Cronjob registriert haben, der aktuelle News einholt und sie in ihrer Newsdatenbank speichert,
jedoch im Zeitraum von 23Uhr bis 7Uhr keinen Besucher auf ihrer Webseite, dann wird der Cronjob erst wieder
durch den Besucher nach um 7Uhr getriggert. Ihnen entgeht dabei die Newsaktualisierung zwischen 23Uhr und
7Uhr. Um sich einer exakten zeitlichen Ausführung anzunähern, kann man die Ausführung der Clansuite_Cronjobs
an die Cronjobs des Betriebssystem koppeln. Dazu fügt man einfach den Aufruf der Clansuite_Cronjob in die
Crontab des Betriebssystems ein (crontab -e).

[source, txt]
---------------------------------------------------------------------
* * * * * php /srv/www/clansuite/cronjobs.php
---------------------------------------------------------------------

.Instanzierung

.Verwendung

Innerhalb eines Cronjobs kann mittels der Methode logMessage("Ihre Nachricht"); eine Nachricht in das Cronjob-
Logbuch geschrieben werden.

===== Übersicht zu Crontab und Cronjobs

.Die Crontab Datei

Die Crontab Datei entspricht der

==== Clansuite_Eventhandler

. Intanzierung

.Verwendung

===== Übersicht zu Eventhandlern

.Hooks im Bereich Benutzerregistrierung, Login, Logout

onRegisterAccount
wenn neuer Useraccount angelegt wird (Daten können bei fremdem System eingetragen werden)

onAccountActivation
wenn ein neuer Useraccount aktiviert wird

beforeLoginValidation
bevor die Prüfung der Eingaben erfolgt, kann ein fremdes System damit befragt werden (Bridges)

afterLogin
nach einem erfolgreichen Login

afterLogout
nach einem erfolgreichen Logout

onDeleteAccount
bevor die Löschung eines Useraccounts durchgeführt wird (Daten können aus fremdem System ausgetragen werden)

resetPassword

.Hooks im Bereich Formulargenerierung und Formularhandling

.Hooks im Bereich Dateihandling

onDownload
nachdem eine Datei heruntergeladen wurde (Update des Downloadcounters in der Statistik)

==== Clansuite_Errorhandler

.Instanzierung

.Verwendung

==== Clansuite_Exceptionhandler

.Instanzierung

.Verwendung

==== Clansuite_Feed

.Instanzierung

.Verwendung

==== Clansuite_Form

Clansuite Forms verwendet Filter und Validatoren automatisch, wenn sie für ein Formelement definiert wurden.

.Schutz vor Cross Site Request Forgery (CSRF) durch Token (Shared-Secret)

Der Fachbegriff Cross-Site-Request Forgery (CSRF) lässt sich nur schwer in die deutsche Sprache übertragen.
Man kann darunter einen Angriff verstehen, bei dem durch einen untergeschobenen Aufruf auf eine Fremdseite
eine Datenveränderung innerhalb einer Webanwendung durchgeführt wird.
Dabei wird dem Angriffsopfer in seinem Webbrowser ein URL-Aufruf untergejubelt,
der einen veränderten HTTP-Request ausführt. Der veränderte Request führt nun die vom
Angreifer gewünschte Aktion aus. Dies hat regelmäßig Erfolg, wenn der Nutzer bei der Webanwendung angemeldet
ist und aus Bequemlichkeits- und Komfortgründen ein Cookie gespeichert hat. Eine bestehende Anmeldung oder
der Zugriff auf Cookie-Daten ist Voraussetzung für einen erfolgreichen Angriff.

Die Angriffsvektoren bei Cross Site Request Forgery (CSRF) sind regelmäßig das URL-Unterschieben und das
Cross-Site- Scripting (XSS).

Ein URL-Unterschieben kann auf vielfältige Art erfolgen. So beispielsweise durch
das Verteilen einer URL während eines IRC Chats oder durch Zusenden einer E-Mail.

Bei Cross-Site-Scripting (XSS) wird HTML-Code an die Webanwendung übermittelt.
Dies erfolgt häufig durch Ausnutzen von Sicherheitslücken im JavaScript-Bereich.
So kann beispielsweise jeder <img> oder <frame> Tag zum Nachladen von Angriffselementen eingesetzt werden.
Zuerst wird also ein HTML-Tag Element mittels JS eingeschleust, sodann wird die Seite vom Opfer aufgerufen.
Beim Aufruf wird der eingeschleuste Tag vom Browser interpretiert und der schadhafte Link aufgerufen.

Um sich davor zu schützen, verwendet man ein einfaches serverseitiges Verfahren. Ein Zugriff auf die
Applikations wird mittels eines Sicherheitstokens (Shared-Secret) erreicht. Der Sicherheitstoken wird als
verstecktes Feld zusätzlich zu jedem Formular hinzugefügt. Beim Übermitteln des Formulars wird automatisch
überprüft, ob der Sicherheitstoken des Formulars mit dem intern (in der UserSession) vorliegenden
übereinstimmt. Die eingehenden Daten sind valide, wenn der Token übereinstimmt.
Liegt kein Token vor oder stimmt er nicht überein, werden die eingehenden Daten des Requests verworfen.

.Verwendung

===== Entwurfsmuster

===== Übersicht zu den einzelnen Formelementen

==== Clansuite_Flashmessages

.Instanzierung

.Verwendung

==== Clansuite_Localization

.Instanzierung

.Verwendung

==== Clansuite_Logger

Die Klasse Clansuite_Logger dient dem Logging von Nachrichten und Fehlern, die sich während des
Applikationsablaufs erreignen.

.Instanzierung

[source, php]
---------------------------------------------------------------------
$logger = new Clansuite_Logger();
---------------------------------------------------------------------

.Verwendung

.a) Übergabe eines Strings als Loggername
[source, php]
---------------------------------------------------------------------
$logger->addLogger('firebug');
---------------------------------------------------------------------

.b) Übergabe eines Loggerobjekts
[source, php]
---------------------------------------------------------------------
$logger->addLoger(new Clansuite_Logger_Firebug);
---------------------------------------------------------------------

.c) Übergabe mehrerer Loggerobjekte
[source, php]
---------------------------------------------------------------------
$logger_array = array();
$logger_array[] = new Clansuite_Logger_Firebug();
$logger_array[] = new Clansuite_Logger_File();
$logger->addLoger($logger_array);
---------------------------------------------------------------------

===== Entwurfsmuster

Das Entwurfsmuster für diese Klasse ist ein Kompositum (auch compositum order composite genannt). Die Klasse
repräsentiert also eine Zusammenstellung eines oder mehrerer Logger. Ein neues Logger-Objekt wird dem
Kompositum mittels addLogger() hinzugefügt und mittels removeLogger() wieder entfernt.
Das Kompositum wird durch die Methode writeLog() ausgelöst.

====== Die Logger Adapter

Die folgenden Logger Adapter stehen für die Komposition zur Verfügung.

======= Logger: E-Mail

Der Logger E-Mail sendet die Lognachrichten via E-Mail.

======= Logger: File

Der Logger File schreibt die Lognachrichten in die Logdatei.

======= Logger: Firebug

Der Logger Firebug sendet die Lognachrichten in die Firebug Konsole des Firefox Webbrowsers.

==== Clansuite_Mailer

Die Klasse Clansuite_Mailer ist eine einfache Wrapper- und Initialisierungsklasse für SwiftMailer. SwiftMailer
wurde ursprünglich von Chris Corbyn entwickelt. Seit der Version 4.0.0 ist Fabien Potencier vom Symfony-Team
als weiterer Entwickler hinzugekommen.

Webseite des SwiftMailer Projekts: http://swiftmailer.org/

.Konfiguration

Clansuite_Mailer benötigt einige Konfigurationseinstellungen.
Diese sind in der clansuite.config.php im Abschnitt [email] zu finden.

Erforderlich sind:
[source, php]
---------------------------------------------------------------------
$config['email']['mailmethod']
$config['email']['mailerhost']
$config['email']['mailerport']
$config['email']['mailencryption']
---------------------------------------------------------------------

.Instanzierung

$mailer = new Clansuite_Mailer();

.Verwendung

[source, php]
---------------------------------------------------------------------
# Senden einer E-Mail mittels der Methode sendmail()
$mailer->sendmail($to_address, $from_address, $subject, $body);

# Holen des SwiftMailer Objekts aus dem Wrapper
$swiftmailer = $mailer->getMailer();
---------------------------------------------------------------------

.Entwurfsmuster

Wrapper.

==== Clansuite_Modulecontroller

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Route

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Trail

.Instanzierung

.Verwendung

.Entwurfsmuster

==== Clansuite_Security

Die Klasse Clansuite_Security stellt den Zugriff auf Streuwert-Methoden (hashing) bereit.
Die drei Methoden der Klasse ermöglichen eine Zeichenkette zu hashen, zu salzen und zu vergleichen.
Die Methode build_salted_hash() erstellt einen gesalzenen Hash.
Die Methode generate_hash() erstellt einen Hash einer Zeichenkette.
Die Methode generate_salt() erstellt eine zufällige Zeichenkette (genannt Salz).

.Allgemeines zum Thema-Hashing
Streuwert-Methoden oder Hashing-Methoden sind Funktionen zur Abbildung einer Zeichenkette auf eine
eindeutige (zumeist aus Buchstaben und Zahlen bestehende) Zeichenkette.

Man muss sich hierbei zwei Dinge vergegenwärtigen.
Erstens, dass Eindeutigkeit bedeutet, dass eine Ausgangszeichenkette immer genau einen Hash hat.

.Eindeutigkeit von Hashes
[source, php]
---------------------------------------------------------------------
Beispiel
$passwort_zeichenkette = 'meinPasswort';
$md5_hash_der_passwort_zeichenkette = md5($passwort_zeichenkette);
echo $md5_hash_der_passwort_zeichenkette; # = f14a298bc87fff2cd757f71054fdd94d
# Die Zeichenkette 'meinPasswort' entspricht dem MD5 Hash 'f14a298bc87fff2cd757f71054fdd94d'.
---------------------------------------------------------------------

Zweitens, dass ein Hash nicht umkehrbar ist. Man kann nicht von einem Hash auf die Ausgangszeichenkette schließen.
Die Unumkehrbarkeit von Hashes ist der Unterschied zur Verschlüsselung. Bei einer verschlüsselten Zeichenkette,
existiert ein Schlüssel und eine Methode, um sie in ihre Ausgangszeichenkette (regelmäßig den Klartext) umzuwandeln.

Das Hashing-Verfahren wird beispielsweise eingesetzt um zwei Dateien auf ihre Gleichheit zu überprüfen.
Anstatt nun einen zeichen- oder zeilenweisen Dateivergleich durchzuführen, wird für beide Dateien
ein Hash, also eine eindeutige Zeichenkette erzeugt. Man nennt diese Zeichenkette daher auch
Identifikator oder Fingerabdruck (engl. Fingerprint). Der Vergleich der Fingerabdrücke der beiden Dateien
gibt nun Auskunft über ihre Gleichheit oder Ungleichheit.

Im Bereich der Webanwendungssicherheit hat sich das Hashing für die Absicherung von Passwörtern als sinnvoll erwiesen.
Anstatt Benutzerpasswörter im Klartext in der Datenbank zu speichern werden sie nun gehashed abgespeichert.
Damit wird die Einsehbarkeit des Klartextes durch Administratoren oder Dritte, etwa
bei einem Datenbankeneinbruch oder -diebstahl, unterbunden. Der Angreifer erhält nun "nur" den Hash des Passworts.

.Vorteile von gesalzenden Hashes
Für gesalzende Hashes sprechen 2 Gründe:
Erstens wird ein Angriff mittels einer Streuwerttabelle relativ nutzlos.

Streuwerttabellen beinhaltet eine vorgenerierte Liste an Hashes für eine Vielzahl von Wörtern und Zeichenkombination.
Man versucht bei einem solchen Angriff durch einen Vergleich des Hashes in der Datenbank mit dem Hash in
der Hash-Tabelle auf das eingesetzte Wort zu schließen. Da eine solche Streuwerttabelle unter Umständen
mehrere Terabyte an Daten enthält, ist sie erstens kaum zu verarbeiten und zweitens würde ein
vergleichender Rückschluß sehr lange dauern.

Um die Menge an Daten einer Streuwerttabelle zu verkleinern und sie somit in kurzer Zeit durchsuchbar zu machen,
wurde eine spezielle Form einer solchen Streuwertabelle entwickelt.
Diese Datenstruktur nennt man Regenbogentabelle (engl. Rainbow-Tables) und wurde vom Schweizer Informatiker
Philippe Oechslin im Jahr 2003 entwickelt footnote:[http://lasecwww.epfl.ch/pub/lasec/doc/Oech03.pdf],
wobei der Ansatz schon im Jahr 1980 durch Martin Hellman
footnote:[M. E. Hellman. A cryptanalytic time-memory trade off. IEEE Transactions on
Information Theory, IT-26:401406, 1980] beschrieben wurde.
Bei Regenbogentabellen werden nicht alle Ausgangswerte und Hashes gespeichert, sondern der
Wert wird zuerst gehashed und anschließend reduziert. Die Reduktion erzeugt eine Zeichenkette
mit der Länge des Ausgangswerts und ist damit also ein mögliches Passwort.
Dieser Prozess der Reduktion wird mehrmals durchlaufen, um eine bestimmt Menge (eine Kette) an möglichen
Passwörtern zur Verfügung zu haben (= ein Spektralbereich des Regenbogens).
In die Regenbogentabelle wird regelmäßig nur der Ausgangswert und der letzte Hashwert gespeichert
(Start und Ende des Spektralbereichs bzw. der Kette).
Das Nachschlagen in einer solchen Regenbogentabelle ist zweischrittig.
Der erste Schritt ist die Bestimmung der Kette. Fällt ein Hash in den Spektralbereich,
dann berechnet man diese Kette (diesen Teil des Spektralbereichs) neu.
Dabei hat man soviele Chancen den Ausgangswert zu finden, wie diese Kette lang ist.

Daraus resultiert, dass unter Verwendung eines gesalzenen Hashes ein solcher Angriff
nur auf ein einzelnes Nutzerkonto ausgeführt werden kann, denn jeder Hash
ist aufgrund einer zufällige vorangestellten Zeichenkette erstellt worden.

Zweitens Dadurch wird ein Problem behoben, dass entsteht, wenn
mehrere Nutzerkonten das gleiche Passwort verwenden, also identische Hashes haben. Anstatt zwei identischer Hashes
wird durch den zufälligen Salzanteil nun jeweils ein unterschiedlicher Hash erzeugt.

.Nachteile von gesalzenen Hashes
Die Passworter können wegen der Zufälligkeit nicht angefordert werden. Man kann sie nur neu generieren.
Das mag einerseits einen Useability-Nachteil bedeuten, andererseits bietet es einen Sicherheitsvorteil.

.Die Bibliothek "phpass" und ein Blick auf andere CMS/CMF
Seit 2004 gibt es die Bibliothek "Portable PHP password hashing framework"
footnote:[http://www.openwall.com/phpass/] geschrieben von Solar Designer <solar[at]openwall.com>
unter einer Public Domain Lizenz.
Diese Bibliothek reimplementiert als Kernmethode den in PHP verfügbaren CRYPT_BLOWFISH Hashing-Algorithmus.
Der Blowfish Algorithmus wurde 1993 (im Jahr 2010 ist er 17 Jahre alt) durch Bruce Schneier
entwickelt und beschrieben footnote:[http://www.schneier.com/paper-blowfish-fse.html].
Das Blowfish Verfahren ist nicht patentiert und lizenzfrei verfügbar. footnote:[http://www.schneier.com/blowfish.html]
Diese Open-Source Verfügbarkeit bewirkte eine rasche Verbreitung in der Open-Source Szene.
Blowfish bietet auch heute noch (2010) eine mit aktuellen Algorithmen vergleichbare Sicherheit und Geschwindigkeit.
Als weitere Fallbacks bietet phpass ein CRYPT_EXT_DES und ein MD5-basiertes Hashing.
Diese Bibliothek wird von Backpress/Wordpress
footnote:[http://backpress.automattic.com/browser/tags/1.0.2/includes/class.passwordhash.php]
Drupal und TYPO3
footnote:[http://typo3.org/extensions/repository/view/t3sec_saltedpw/current/, Typo3 Extension T3Sec_SaltedPW]
eingesetzt.

.Instanzierung

Durch Autoloading kann jederzeit auf die Klasse zugegriffen werden.
Auch eine Constructor Injection ist möglich.

[source, php]
---------------------------------------------------------------------
# systemweites autoloading
$security = new Clansuite_Security();

# Holen des Objekts aus dem Dependency Injector
$config = $this->injector->instantiate('Clansuite_Security');

# Automatisches holen bei Verwendung der Constructor Dependency Injection
public function __construct(Clansuite_Security $security)
---------------------------------------------------------------------

.Verwendung

*Die Methode build_salted_hash()*
Die Methode nimmt als ersten Parameter eine Zeichenkette entgegen und als zweiten Parameter die
Abkürzung eines Hashing-Algorithmus. Diese Zeichenkette wird am Anfang mit einer zufällige Zeichenkette versehen.
Dieses Voranstellen einer zufälligen Zeichenkette nennt man salzen (engl. salting).
Die neu entstandene Kombination aus Salz+Zeichenkette wird dann der Hashing Methode generate_hash() übergeben,
um von ihr einen Hash als Rückgabewert zu erhalten.

*Die Methode generate_hash()*
Die Methode generiert einen Hash aus einer Zeichenkette unter Verwendung eines Hashing-Algorithmus.
Dabei wird auf die PHP-Funktion hash() zurückgegriffen.
Somit stehen beispielsweise die Hashing-Algorithmen md5, sha1, sha256 zur Verfügung.
Als das Standardverfahren ist sha1 festgelegt.
Um eine komplette Liste der verfügbaren Hashing Algorithmen des Kommandos hash() zu erhalten,
 eignet sich die PHP-Kommandokombination print_r(hash_algos()); .
Falls hash() nicht verfügbar sein sollte, wird als Fallback auf die PHP-Kommandos md5() bzw. sha1() zurückgegriffen.
Falls sie die PHP Extension "skein" installiert haben und in der Konfiguration als
Hash-Algorithmus 'skein' festgelegt haben, dann wird ein 512-bit Skein-Hash erstellt.
Sie finden die PHP Extension auf Skein Webseite unter http://www.skein-hash.info/downloads.

*Die Methode generate_salt()*
Diese Methode erzeugt einen Zufallsstring der gewünschten Länge.
Der Zufallsstring besteht Zahlen, sowie Groß- und Kleinbuchstaben und den Sonderzeichen '.' und '/'.
Die "Zufälligkeit" von Zeichen wird mittels mt_srand() and mt_rand() erzeugt.

.Entwurfsmuster

Kein Entwurfsmuster.

==== Clansuite_Session

Das PHP Sessionhandling ist ein sicherheitskritischer Bereich. Die normalen PHP Sessions sind ungeschützt.

.Sicherung von Session-Cookie

a) Sicherung von Session-Cookies mittels SSL und Secure Flag
Wenn Clansuite mit SSL verwendet wird, ist das Cookie "secure" flag zu
setzen. Dies sorgt dafür, dass der Cookie nicht unverschlüsselt gesendet wird, sondern so verschlüsselt,
sodass niemand den Cookie stehlen kann.

b) Cookie HTTPONLY
Das Session-Cookie kann mittels der Konfigurationseinstellung "cookie_httpOnly" gegen XSS geschützt werden. In
diesem Fall werden Javascripte
wirksam davon ausgeschlossen die Session ID zu stehlen.

.Zufällige SessionID für jede Clansuite Installation
Falls zwei Clansuite Applikationen sich auf dem gleichen Server befinden und sich einen Sessionspace teilen,
ist es möglich das beide Applikationen gegenseitig Sicherheitslöcher in das Sessionhandling reißen. Es gibt
zwei Methoden um dies zu unterbinden: Erstens, wenn sie Clansuite_Session (DB) verwenden, legen Sie für jede
Installation eine Datenbank an. Installieren sie nicht zwei Clansuite Versionen (eine für ein Blog) die andere
für den Clan. Zweitens, wenns die Session im save_path abgespeichert wird, dann ist jeder Clansuite
Installation ein eigenes Sessionverzeichnis zu geben. So kommen die zwei Versionen sich nicht in die Quere.

.Niedrigen Session Timeout ansetzen (maxlifetime)
Je weniger Zeit ein Session Fenster hat, desto sicherer ist es.
Die Session Lifetime kann in der Clansuite Konfiguration eingestellt werden.

.Schutz vor Session Fixierung (Session Fixation)
Einer Session Fixation kann man nur durch Erneuerung der SessionID bei Änderung des Userstatus (login/logout)
begegnen. Die Erneuerung der Session erfolgt mittels Clansuite_Session::regenerateID().
Sie ist direkt mit der Login-Funktion verknüpft.

.Session Hijacking
Session Hijacking bedeutet, dass ein Dritter sich den Inhalt der Session zu eigen machen kann.
Häufig geschieht dies über Man-in-the-middle Attacken oder Sniffing/XSS.
Guten Schutz bietet nur die Verwendung von "cookie_httpOnly" und SSL-Verschlüsselung.

.Session Validation
Clansuite hat für die Sessionvalidierung den Filter Session Security.
Doch die Session Validierungsregeln, z. B. die Überprüfung ob die Session von der gleichen IP oder
der Request vom gleichen User-Agent kommt, halten einem Session Hijacking nicht stand.
Zusätzlich bereitet eine Session Validation eine Menge Probleme.
a) Man schließt bestimmte IPs aus.
Bei bestimmten Providern hat jeder Request eine neue IP (AOL). Stichwort: Proxy Farming.
b) User-Agent HTTP Header Checks
c) Accept Header Check
Aus vorgenannten Gründen wird vom Einsatz des Sessionfilters abgeraten.

.Instanzierung

.Verwendung

==== Clansuite_Upload

.Instanzierung

.Verwendung