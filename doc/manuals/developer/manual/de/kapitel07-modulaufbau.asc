////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 7 - Der Aufbau eines Clansuite Moduls

Das Kapitel erläutert den Aufbau eines Clansuite Moduls.
Im ersten Abschnitt des Kapitels beschäftigen wir uns mit der Frage, was ein Clansuite Modul ausmacht.
Im zweiten Abschnitt gehen wir der Frage nach, was für Techniken uns die objektorientierte
Programmierung anbietet, um Module zu erstellen, miteinander zu verbinden und eine Applikation daraus aufzubauen.
Im dritten Abschnitt gehen wir einen Schritt weiter und fragen nach den konkreten Techniken und Hilfsmitteln
die das Clansuite Framework bereitstellt, um ein Modul schnell und einfach zu erstellen.
Das Kapitel schließt mit dem vierten Abschnitt, indem die Arbeit mit dem Clansuite_ModuleBuilder erklärt wird.

=== Was ist ein Clansuite Modul?

Ein Entwicklungsziel von Clansuite war, den Application Layer so zu gestalten, dass sich Module schnell und
einfach schreiben und anpassen lassen.

Module können als die Bausteine einer Applikation verstanden werden.
Wir wissen aber immernoch nicht, wie ein solcher Baustein beschaffen ist.
Um einer Beliebigkeit im Modulaufbau entgegenzuwirken, bedarf es einer genauen Definition, einer Konvention für Module.
Zunächst werden wir daher feste Regeln für ein Modul aufstellen.
Diese Regeln definieren also, wann etwas im Rahmen des Clansuite CMS ein Modul ist.

.Konventionen für ein Clansuite Modul
----
a) Verzeichnisstruktur
b) Dateien
c) Schnittstellen
d) Klassen
e) Basisklasse
f) Templates
g) Metainformationen
h) Übersetzung
----

==== Verzeichnisstruktur

Die Verzeichnisstruktur eines Moduls wiederspiegelt die MVC-Schichtentrennung.
Es gibt ein Verzeichnis für jeden Schichtenbereich (also "controller", "model" und "view").
Diese Verzeichnisstruktur wird erweitert, um das Verzeichnis mit den Übersetzungsdaten "languages".
Hier werden die Gettext-Lokalisierungsdaten abgelegt.
Optional ist das Verzeichnis "events", es dient zur Ablage der Ereignisobjekte eines Moduls .

[source,txt]
--------------------------------------------------------------------------------
clansuite                     Applikationsverzeichnis von Clansuite
 +--modules                   Wurzelverzeichnis aller Module.
     +--modulename            Verzeichnis eines Moduls.
         +--controller        Verzeichnis für die Geschäftslogik (engl. business logic).
             +--actions       Optionales Verzeichnis für die Ablage einzelner ActionController.
         +--events            Optionales Verzeichnis für die Ablage von Ereignisobjekten des Moduls.
         +--languages         Verzeichnis für die Lokalisierungsdaten des Moduls (Gettext).
         +--model             Verzeichnis für die Datenzugriffslogik.
             +--records       Verzeichnis für Doctrine Records
         +--view              Verzeichnis für die Präsentationslogik. Zumeist befinden sich dort Templates.
--------------------------------------------------------------------------------

=== Objektorientierte Techniken zur Erstellung von Modulen

Die Mechanismen der Objektorientierung sollen uns helfen, diese Module zu definieren und interagieren zu lassen.
Fraglich ist also, was für Techniken uns die objektorientierte Programmierung anbietet, um Module zu erstellen,
miteinander zu verbinden und eine Applikation daraus aufzubauen.

==== Vererbung und Bildung einer Klassenhierarchie

Zuerst können wir an die Vererbung denken. Klassen können von anderen Klassen erben.
Dadurch entsteht eine Klassenhierarchie.

.Basisklasse erweitern
Beispielsweise kann ein Modul eine bestehende Basisklasse für Module erweitern.
Sie wissen an dieser Stelle bereits, das jedes Clansuite_Module die Basisklasse Clansuite_Module_Controller erweitert.
Am Beispiel des News-Moduls sei die dabei entstehende Klassenhierarchie verdeutlicht:

[source,txt]
--------------------------------------------------------------------------------
Clansuite_Module_Controller (Basisklasse)
 |
 +--- Clansuite_Module_News (Erweiterung)
--------------------------------------------------------------------------------

Alle Methoden der Basisklasse auch in der Erweiterung zur Verfügung.
Oder anders formuliert, die Erweiterung bringt möglicherweise neue Eigenschaften und Methoden für die Basisklasse mit
oder überlädt bereits bestehende.

.Erweiterung einer Moduleklasse (Erweiterung der Erweiterung)
Des weiteren ist es möglich die Klasse zu erweitern, welche die Basisklasse erweitert.

[source,txt]
--------------------------------------------------------------------------------
Clansuite_Module_Controller (Basisklasse)
 |
 +--- Clansuite_Module_News (Erweiterung)
       |
       +--- Clansuite_Module_News_Extension (Erweiterung der Erweiterung)
--------------------------------------------------------------------------------

In der Klasse Clansuite_Module_News_Extension stehen alle Methoden und Eigenschaften der Erweiterung und der Basisklasse
zur Verfügung.

==== Dekorieren von Modulen

Beim Dekorieren von Modulen, sprich Klassen, werden diese zur Laufzeit um neue Funktionalitäten erweitert.
Anders formuliert: ein bestehendes Objekt wird mit neuen Eigenschaften oder Methoden umhüllt.

==== Dependency Injection

Zur Technik der Abhängigkeitsauflösung durch die verschiedenen Dependency Injection Methoden verweise ich auf
den Abschnitt "Lose Kopplung" im Kapitel 5.

=== Techniken das Clansuite Framework zur Erstellung von Clansuite Modulen

Im zweiten Abschnitt gehen wir der Frage nach, welche konkreten Techniken das Clansuite Framework bereitstellt,
um ein Modul zu entwickeln.

=== Hilfsmittel zur Erstellung von Clansuite Modulen

Dieser Abschnitt behandelt Techniken und Hilfsmittel zur Erstellung von Clansuite Modulen.

Im Vordergrund steht die Konzentration von Methoden und Eigenschaften
in der allgemeinen Klasse Clansuite_Module_Controller. Jeder Modulcontroller erweitert die Klasse
Clansuite_Module_Controller. Damit stehen die allgemeinen Methoden und Eigenschaften dieser Klasse jedem
Modulcontroller zur Verfügung. Unnötige Quelltextdopplung in den Modulen wird so vermieden und ein Modul,
sowie insbesondere eine Modulaction, besteht nur noch aus den wichtigsten Informationen.

Durch die Trennung in Applikationssschichten werden Datenbankenabfragen aus der Moduldatei in
das jeweilige Model des Moduls verlagert.
Dadurch kann das Model geändert werden, ohne die Moduldatei ändern zu müssen.

Ein Entwicklungsziel von Clansuite war, den Application Layer so zu gestalten, dass sich Module schnell und
einfach schreiben und anpassen lassen. Module können als die Bausteine einer Applikation verstanden werden.
Fraglich isy

Clansuite definiert Modularität wie folgt: Ein Modul ist eine Einheit von zusammengehöriger Funktionalität,
die

.Überblick über die Methoden und Eigenschaften von Clansuite_Module_Controller

.Methoden für den Umgang mit der Konfiguration

.Methoden für den Umgang mit dem Model

.Methoden für den Umgang mit dem View

.Das Verwaltungsmenü eines Moduls (modulenavigation)
Grundanliegen ist ein einheitliches Verwaltungsmenü für alle Module.
Die Menüstruktur innerhalb eines Moduls wird durch den Smarty Tag
{modulenavigation} eingebunden. Sie basiert auf der Beschreibungsdatei.
Dort werden einige feste Slots mit standardisierten Benennungen definiert.
Diese haben gleichbleibende Name wie "Overview", "Create", "Settings".
Es ist auch weiterhin möglich individuelle Navigationen für die Verwaltung eines Moduls zu verwenden.


Wird kein Template mittels setTemplate() gesetzt, wird der Methodenname automatisch als Templatename eingesetzt.
Eine Action namens "action_admin_show" hat daher das Template "action_admin_show.tpl".

[source, php]
---------------------------------------------------------------------
# Set Layout Template
$this->getView()->setTemplate('directory/index.tpl');

# Prepare the Output
$this->prepareOutput();
---------------------------------------------------------------------

=== Der Inhalt eines Modulverzechnisses

=== Info - Die Informationsdatei (modulename.info.php)

Jedes Modul verfügt über eine Metainformationsdatei. Die Metainformationen werden z. B. im Bereich der
Moduleverwaltung angezeigt, um das Modul korrekt zu identifizieren. Die "modulename.info.php" Datei stellt
Clansuite Metainformationen des Moduls zur Verfügung. Die Datei folgt der Dateinamenskonventions
"modulename"+".info.php". Das Dateiformat ist das normale .ini Format. Die Dateiendung ist aus
Sicherheitsgründen zwingend ".php". Die Einträge sind Schlüssel/Wert Paare. Sie werden durch das Zeichen
"=" getrennt. Wenn man die Werte in Anführungeszeichen (") setzt, dann ist es auch möglich Zeilenumbrüche
einzufügen. Es ist ebenfalls möglich Kommentare einzufügen. Dazu wird das Semikolon der zu kommentierenden
Zeile vorangestellt. Aus Sicherheitsgründen ist es ebenfalls wichtig, dass die ersten Zeilen der Konvention
entsprechen.

=== Routes - Die Routingdatei eines Moduls (modulename.routes.php)

Die Routingdatei namens "modulename.routes.php" enthält eine Auflösungstabelle für die URL Action Paare. Ein
solches Paar besteht auf Schlüsselseite aus einer URL und ihren Teilelementen, auf der Wertseite aus den
passende Methodenaufrufen des jeweiligen Modulcontrollers. Damit definieren Routes also sogenannte Resourcen-
Zielseiten. Diese Relationstabelle kann man sich wie eine Sitemap des Moduls vorstellen. Je Modul wird eine
URLs Auflösungstabelle geführt. Bei der Installation werden sie mit der Hauptauflösungstabelle des Systems
verschmolzen. So wird beim Systemstart eine einzige Definitionsdatei namens "clansuite.routes.php" für das
Routing geladen. Eine Veränderung des Modulroutings führt zu einer automatischen Anpassung des allgemeinen
Routings.

=== Events - Die Ereignisdefinitionsdatei eines Moduls (modulename.events.php)

Ein Modul kann Ereignisobjekte mitbringen. Um beim Durchlaufen der Applikation an den definierten Ereignisstellen
ein Ereignis auszulösen, müssen wir bereits beim Applikationsstart wissen, welche Ereignisobjekte eines
Moduls aktiviert sind und geladen werden müssen. Dazu wird die Ereignisdefinitionsdatei des Moduls herangezogen.
Die "modulename.events.php" Datei stellt dazu ein entsprechendes Konfigurationsarray bereit.

Um beim Applikationsstart nicht jedesmal alle Modulverzeichnisse zu durchlaufen, um einzelnen
Ereignisdefinitionsdateien zu laden, wird eine allgemeine Eventkonfigurationsdatei erstellt. Diese fast alle
verfügbaren und aktivierten Ereignisse alle Module zusammen. Sie wird ergänzt durch die vom Core mitgebrachten
Ereignisse. Diese zentrale Eventkonfigurationsdatei wird beim Systemstart geladen. Eine Veränderung der
Eventkonfiguration eines Moduls führt zu einer automatischen Anpassung der allgemeinen Eventkonfiguration.

=== Die Controllerdateien

Clansuite unterstützt zwei Arten von Controllern.
Einerseits Modulecontroller. Diese Dateien stellen eine Bündelung von ActionControllern dar.
Dieses Verfahren der Bündelung von ActionControllern wird auch vom Zend Framework eingesetzt.
Andererseits ActionController. Diese Dateien stellen einzelne Kommandos/Tasks dar.
Clansuite unterstützt zwei Arten von Controllern: Modulecontroller und Actioncontroller.
Modulecontroller sind Dateien, die eine Bündelung von Actioncontrollern beinhalten.
ActionController sind Dateien, welche ein einzelnes Kommandos bzw. eine Action beinhalten.

Es gibt eine Reihenfolge beim Suchen nach ActionControllern.
Zuerst wird immer der ModuleController nach dem ActionController durchsucht.
Sollte er nicht gefunden werden, wird nach einem einzelnen ActionController gesucht.
Sollte auch dieser nicht zur Verfügung stehen, wird eine Exception ausgelöst.

Wenn Sie im Debug und Development Modus des Systems sind, wird zu dieser Exception
der Schnellentwicklungslink angeboten. Damit können sie den nicht verfügbaren ActionController
erstellen.

=== Erweiterung eines Moduls zur Laufzeit (Module-Plugins)

Ein Modul kann zur Laufzeit des Programms durch den Moduledecorator um weitere Methoden ergänzt werden.

=== Erstellung von Modulen mit dem Clansuite Modulebuilder

In diesem Abschnitt wird der Clansuite Modulebuilder, ein Assistent (engl. wizard) für die Erstellung der
Modulstruktur eines Clansuite Moduls beschrieben. Diese Modulstruktur besteht aus bestimmten Verzeichnissen
und Dateien, die ein Clansuite Modul immer benötigt. Eine genaue Beschreibung der Anforderungen an ein
Clansuite Modul finden Sie im ersten Abschnitt dieses Kapitels. Der Assistent dient also dazu, den Entwickler
beim Einhalten dieser genauen Modulstruktur zu unterstützen und ihm einige wiederkehrende Tätigkeiten
abzunehmen.

Grundsätzlich läuft dieser Vorgang so ab, dass sie zunächst den Bauplan des Moduls beschreiben.
Die Beschreibung erfolgt dabei schrittweise unter Verwendung der grafischen Oberfläche des Clansuite_Builders.
Aus der Beschreibung wird dann automatisch ein Rahmen bzw. Gerippe für das Modul erstellt.
Dieser Modulrahmen ist bereits funktionstüchtig und kann anschließend manuell weiterentwickelt werden,
bis die von Ihnen angezielte Funktionalität vollständig bereitsteht.
Aus dem Modulrahmen entsteht so ein vollständiges funktionstüchtiges Modul.

==== Programmiertechnik und Entwurfsmuster

.Die Skeleton-Programmierung und die Schablonenmethode
Diese Art der Programmiertechnik nennt man auch Skeleton-Programmierung. Skeleton-Programmierung bezeichnet
ein Programmierungsverfahren, bei dem zunächst eine automatisch generierte Programmgrundstruktur erzeugt wird,
um später auf diese Grundstruktur zurückzugreifen und sie weiterzuentwickeln. Die automatisch generierte
Programmgrundstruktur setzt sich dabei zumeist aus Vorlagen zusammen. Im Bereich der objektorientierten
Programmierung wird für das Vorhalten von Vorlagenzumeist auf die Schablonenmethode (engl. Template-Method)
als Entwurfsmuster zurückgegriffen.

.Das Stumpf-Entwurfsmuster
Ein weiteres Entwurfsmuster welches im Zusammenhang mit Skeletons häufig eingesetzt wird, ist das Stumpf-
Muster (engl. stub). Im Bereich der Programmierung bezeichnet ein Stumpf den Anknüpfungspunkt für eine spätere
Entwicklung. Dabei ist ein Stumpf regelmäßig eine Vereinfachung. Wenn sie beispielsweise den Rückgabewert
einer Funktion aus Gründen der Vereinfachung festsetzen, dann können sie bereits mit der Methode arbeiten,
ohne etwa den Algorithmus zur Berechnung des Rückgabewerts implementieren zu müssen.

Ein konkretes Beispiel mag die Programmiermethode Stumpf erläutern. Sie wollen eine grafische Darstellung
Ihres Außenthermometers auf dem Bildschirm erzeugen. Derzeit haben sie allerdings keine Temperaturdaten
als Anknüpfungspunkt für eine Visualisierung zur Verfügung, weil sie die Datenstruktur der vom Thermometer
gelieferten Werte noch nicht kennen. Sie erhalten das entsprechende Handbuch mit der Spezifikation erst in
einigen Tagen. Um dieses Problem erstmal zu umgehen und zu einer Visualisierung zu gelangen, definieren
Sie eine Methode getThermometerTemperature(), die einen festen Temperaturwert von beispielsweise 18,5 Grad
Celsius zurückliefert. Auf diese Methode können sie nun in den Visualisierungsmethoden zurückgreifen, um eine
vorläufige Anzeige zu erhalten und die Darstellung schonmal auszuarbeiten.

Später steht Ihnen die Spezifikation der Datenstruktur des Thermometers zur Verfügung. Sie sind nun in Lage
die Datenstruktur zu verstehen und einen Parser dafür zu entwickeln. Damit verfügen Sie nun über dynamische
Temperaturdaten und können den festen Temperaturwert in getThermometerTemperature() durch einen Zugriff auf
den Temperaturwert innerhalb der geparsten Datenstruktur ersetzen. Die Programmiermethode Stumpf hat Ihnen
also geholfen, erstmal mit der Entwicklung fortzufahren und später daran anzuknüpfen.

.Das Mock-Objekt
Im Kontext von objektorientieren Design gibt es einen weiteren Begriff der eng mit der Stumpf-Methode verwandt
ist. Es ist das sogenannte Mock-Objekt. Ein Mock-Objekt ist eine Objekt-Attrappe, die Methoden und
Eigenschaften des echten Objekts lediglich vortäuschend bereitstellt und somit vorgibt das echte Objekt zu
sein. Mock-Objekte werden im Bereich der testgetriebenen Softwareentwicklung eingesetzt, um die Interaktion
eines Objekts mit seiner Umwelt zu testen. Dazu ist es erforderlich auch das innere des Objekts nachzubilden.
Nachgebildet werden zumeist die Kommunkationsschnittstellen des Objekts, die dann zum Testszenario
passende Werte zurückliefern. Mehr zu Mock-Objekten und testgetriebener Entwicklung erfahren Sie im Kapitel 14.