////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://docs.clansuite.com/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 8 - Der View - von Render-Engines, Themes und Templates

Der View stellt die Daten des Modells dar und nimmt Nutzeraktionen entgegen. Es ist das V in MVC. Es handelt
sich also um die Präsentationsschicht der Anwendung.

Wir wissen bereits, dass die Module im Idealfall so programmiert sind, dass sie Logik soweit wie möglich von
der Darstellung trennen. Ein Modul bezieht seine Daten aus der Datenbank. Anschließend werden sie eventuell
noch bearbeitet und dann für die Ausgabe vorbereitet. Dann werden diese Daten an die Präsentationsschicht
übergeben.
Demnach darf ein Modul im Logikbereich keine direkte HTML-Ausgabe bewirken.

Die Präsentationsschicht arbeitet daher mit Templates. Alle Ansichten eines Moduls werden daher durch
Template-Implementierungen ermöglicht. In der Realität gibt es einige wenige Ausnahmen. So werden bei
Clansuite die Exception- und Fehlerbehandlungsseiten, sowie stark verschachtelte Baumstrukturen nicht
vollständig als Templates implementiert. Bei ersteren könnte ein Fehler im Bereich des Views die Darstellung
des Fehlers behindern. Clansuite verwendet allerdings Templates, um die direkte Fehlerausgabe zu ergänzen. Mehr
dazu erfahren sie im Kapitel über das Fehler- und Exceptionhandling. Bei letzterem würde man die
Schleifenanweisung unnötig wiederholen: einmal für die Aufbereitung der Baumstrukturen
und einmal für die Darstellung im Template.

Ein lesenswerter Artikel über das Für und Wider Templateengines ist
http://articles.sitepoint.com/article/beyond-template-engine.

Für Entwickler gilt die Faustregel: Ein Modul ist dann gut geschrieben, wenn nur Templatedateien geändert
werden müssen, um die Ansichten vollständig zu verändern.

.Platzhalter
Im Bereich der Präsentationsschicht werden Platzhalter verwendet. Ein Platzhalter ist ein Zeichen oder eine
Zeichenkette, die stellvertretend für etwas steht. Es ist eine Positionsmarke für die später an dieser Stelle
anzuzeigenden Daten. Als Beispiel für Funktion und Nutzen von Platzhaltern, soll der Serienbrief dienen. Bei
einem Serienbrief wird ein Text an eine Vielzahl von Personen versandt. Dabei möchte man aber den Brieftext
nicht jedesmal neu schreiben müssen, nur weil sich im Briefkopf Name und Anschrift geändert haben. Regelmäßig
wird nun ein Platzhalter für die Adresse eingesetzt und die einzelnen Empfängeradressen in einer Datenbank
abgelegt. Beim Druck des Serienbriefs wird nun über die Empfängeradressen iteriert und diese werden in den
Briefkopf eingesetzt.

.Push-View und Pull-View Strategie
Grundsätzlich lassen sich zwei Wege unterscheiden, wie die anzuzeigenden Daten in den View gelangen.
Wir unterscheiden die "Push-View" von der "Pull-View" Strategie.
Beim Push View werden die anzuzeigenden Daten durch den Controller an den View übergeben.
Beim Pull View werden die anzuzeigenden Daten durch den View vom Model erfragt.
Clansuite setzt beide Varianten ein.

Vorrang hat die Push-View Strategie.
Dazu wird die allgemeine Geschäftslogik eines Moduls im ModuleController und ActionControllern implementiert.
Diese Geschäftslogik wird möglicherweise auf ein oder mehrere Models zurückgreifen, um Daten zu beziehen
und diese aufzubereiten. Danach werden die aufbereiteten Daten an den View übergeben.
Die Push-View Strategie hat Vorteile und Nachteile.
Nachteilig ist der Verlust an Flexibilität. Denn die Daten die gepushed werden sollen, müssen im Vorraus definiert werden.
Die Definition erfolgt durch Abruf der Daten über Geschäftslogik des Models und Übergabe an den View mittels
der Methode $view->assign(data).
Zum anderen vermittelt die Push-Strategie eine erhöhte Sicherheit, denn die Geschäftslogik entscheidet,
welche Daten angezeigt werden.

Nachranging ist das Pull-View Verfahren.
Dazu wird die allgemeine Geschäftslogik eines Moduls im ModuleController und ActionControllern implementiert.
Diese Geschäftslogik wird ein oder mehrere Model-Objekte holen.
Doch anstatt aus diesen Models Daten zu holen. Wird das Model einfach an den View übergeben.
Die Datenextraktion und Aufbereitung aus dem Model obliegt also nun dem View.

.Modultemplates
Ein Modul bringt regelmäßig Templates mit.
Diese kann man als Moduletheme bezeichnen.
Sie stellen die Basisausgabe des Moduls dar.
Das Verzeichnis der Templates ist "/modulename/templates".
Die Dateiendung der Templates ist ".tpl".

.Templatenamenskonvention
Templates haben eine Namenskonvention. Der jeweilige Actionname ist auch der Dateiname des Templates. Lautet
der Name der Action beispielsweise action_news_show(), so wird ein Template names action_news_show.tpl
erwartet. Die Templateautomatik wird im Bereich der Modullogik durch Verwendung der
Methode $this->prepareOutput() ausgelöst.
Abbedingen kann man sie durch explizites setzen eines anderen Templates mittels der Methode
setTemplate('meinAlternativesTemplate.tpl') innerhalb der jeweiligen Action.

[source, php]
---------------------------------------------------------------------
# Modulecontroller (/modules/demonstration/demonstration.module.php)
class Clansuite_Module_Demonstration extends Clansuite_Module_Controller implements Clansuite_Module_Interface
{
    # Actioncontroller namens "action_eine_demonstration"
    public function action_show()
    {
        $this->prepareOutput();
    }
}

# Das zugehörige Template der Methode Clansuite_Module_Demonstration->action_show() ist im Modulverzeichnis:
/modules/demonstration/templates/action_show.tpl
# Es wird geladen, wenn kein gleichnamiges Template im aktiven Theme gefunden wird.
---------------------------------------------------------------------

.Erstellen eines Modulethemes
Diese Modultemplates kann man als Vorlage verwenden, wenn sie eine andere Art der Ausgabe bevorzugen.
Das geht sehr einfach, indem sie die das Template-Verzeichnis des Moduls mit samt den Templates
in einen Themeordner kopieren und dem Ordner den Namen des Moduls geben.

=== Unterstützung von Render Engines

=== Ablaufplan bis zum View eines Widgets

[source, txt]
---------------------------------------------------------------------
Smarty->trigger_error('Error! Failed t...')
smarty_function_load_module(Array, Object(Smarty), Object(Smarty_Internal_Template))
call_user_func_array('smarty_function...', Array)
Smarty_Internal_Plugin_Handler->__call('load_module', Array)
Smarty_Internal_Plugin_Handler->load_module(Array, 'function')
include('D:\xampplite\ht...')
Smarty_Internal_Template->renderTemplate()
Smarty_Internal_Template->getRenderedTemplate()
Smarty->fetch('index.tpl')
Clansuite_Renderer_Smarty->render('action_show.tpl')
Clansuite_Module_Controller->prepareOutput()
Module_News->action_show()
Clansuite_Action_Controller_Resolver->processActionController(Object(Clansuite_HttpRequest), Object(Module_News))
Clansuite_Front_Controller->processRequest(Object(Clansuite_HttpRequest), Object(Clansuite_HttpResponse))
Clansuite_CMS::execute_Frontcontroller()
Clansuite_CMS::run()
---------------------------------------------------------------------

=== Ablaufplan bis zum Aufruf einer bestimmten RenderEngine am Beispiel von Smarty

[source, txt]
---------------------------------------------------------------------
Clansuite_CMS::run()
Clansuite_CMS::execute_Frontcontroller()
Clansuite_Front_Controller->processRequest( object(HttpRequest)[30], object(HttpResponse)[31] )

Module_Index->execute( object(HttpRequest)[30], object(HttpResponse)[31] )
ModuleController->processActionController( object(HttpRequest)[30] )
Module_Index->action_show( )
ModuleController->prepareOutput( )
ModuleController->getView( )
ModuleController->getRenderEngine( )

Clansuite_Renderer_Factory::getRenderer('smarty', Object(Phemto))
Clansuite_Renderer_Smarty->__construct(Object(Phemto), Object(Clansuite_Config))
Clansuite_Renderer_Smarty->initializeEngine()

Smarty_Internal_Template->renderTemplate()
Smarty_Internal_Template->getRenderedTemplate()
Smarty->fetch('index.tpl')

Clansuite_Renderer_Smarty->render('action_show.tpl')
---------------------------------------------------------------------

==== Viewhelper

Templates enthalten hauptsächlich HTML und Platzhalter. Jedoch gibt es auch in Templates bestimmte Stellen, an
denen wiederholend einsetzbare Präsentations-Logik nötig ist. Diese unterstützenden Funktionen der
Präsentations-Logik sind in sogenannten Viewhelpern enthalten. Das View-Helper-Pattern ergänzt also das MVC-
Pattern in der View-Schicht. Der Viewhelper "date" wird Sie beispielsweise dabei unterstüzen, den Datumsstring
in das richtige Datumsformat
umzuwandeln und anzuzeigen.

.Arten von Viewhelpern
Es gibt mehrere Arten von Viewhelpern. Zum einen gibt es die Block-Tag Viewhelper. Block-Tags benötigen immer
einen öffnenden und schließenden Tag. Beispielsweise benötigt der öffnende Tag <a> auch immer den schließenden
Tag </a>. Regelmäßig wird die Transformationsfunktion des Viewhelpers auf dem eingeschlossenen Inhalt
ausgeführt. Neben den Block-Tag Viewhelpern gibt es Tag Viewhelper und Platzhalter Modifizierer. Tag-
Viewhelper sind einfache Aufrufe von Funktionen der Präsentations-Logik. Beispielsweise wird der Tag-
Viewhelper {date} das Datum anzeigen. Modifizierer sind Annexfunktionen für Platzhalter. Sie führen ihre
Aufgabe direkt auf den Platzhalterdaten aus. Ein Beispiel für die Verwendung eines Modifizierer ist
{$name|@uppercase}. Hier wird der Inhalt der Variable $name der Modifierfunktion mit Namen "uppercase"
unterzogen. "Uppercase" sorgt dafür, das alle Zeichen in $name als Großbuchstaben formatiert ausgegeben werden.

.Verzeichnisse der Viewhelper
Die offiziellen Smarty Viewhelper befinden sich im Verzeichnis /libraries/smarty/plugins.
Sie werden bereits mit Smarty ausgeliefert.
Die Clansuite Viewhelper für Smarty befinden sich im Verzeichnis /core/viewhelper/smarty.
Es ist auch möglich, dass ein Modul ein Viewhelper-Plugin mitbringt.

Die oben genannten Pfade werden bei Initialisierung des Smarty Renderers
als Plugin-Verzeichnisse registriert. Damit kann aus jedem Verzeichnis neue Funktionalität geladen werden.
footnote:[http://www.smarty.net/manual/de/tips.componentized.templates.php, Smarty Handbuch - Template/Script Komponenten]

.Der Viewhelper zur Übersetzung innerhalb von Templates

Der Viewhelper {t} ermöglicht das Übersetzen von Zeichenketten innerhalb von Templates.
Module sollten immer darauf achten, übersetzbar zu sein; für Templates gilt dasselbe.
Leute, die Themes erstellen benötigen den blanken Text, um damit arbeiten zu können
und Übersetzer erwarten, dass sämtlicher Text durch die Funktion t() geschleust wurde.
Aus diesen Gründen wird die Verwendung von {t} {/t} in Templates zwingend empfohlen.

[source,php]
-----------------------------------------------------------------------
# Die Verwendung des Block-Tags {t} bewirkt die Übergabe des Textes an die Übersetzungsfunktion t().
{t}Der zu übersetzende Text.{/t}
-----------------------------------------------------------------------

.Konfigurationsdateien in der Präsentationsschicht

Diese Funktionalität kann mittels Smarty erreicht werden.
Smarty bietet dazu den Tag {$smarty.config}, um auf Konfigurations-Variablen zuzugreifen.
Geladen werden kann eine Konfigurationsdatei mit dem Tag {config_load file='beispiel.conf'}.
Die Konfigurationsvariablen referenziert man im Template mit umschliessenden
Raute-Zeichen {#Konfigurationseinstellung#}.
footnote:[http://www.smarty.net/manual/de/language.function.config.load.php]

An dieser Stelle sei auch ein Vergleich zu Typo3's TypoScript gestattet. TypoScript ist, entgegen dem Namen,
keine Skriptsprache, sondern eine Anzahl von Konfigurationseinstellungen die als Baumstrukturen abgelegt sind
und eine Veränderung der Präsentation bewirken. Im wesentlichen entspricht die Konfigurationsdatei dem INI
Format mit Sektionen und Untersektionen entspricht. Nichts anderes stellen die Konfigurationsdateien von
Smarty dar. Letztlich wird hier nochmals im Präsentationsbereich abstrahieren und die
Veränderungsnotwendigkeit der Templatedateien selbst eingeschränkt, indem man die Konfigurationsdatei bearbeitet.

=== Debugging im View

==== Smarty

.Der Befehl {debug}
Der Smarty Befehl {debug} kann eingesetzt werden, um den Umgebungsbereich eines Templates anzusehen.
Es öffnet sich die Smarty Debug Console und sie erhalten einen Überblick über eingebundene Templates
und die Übersicht über die Templatevariablen und ihren Inhalt.

.Der Modifier "firebug"
Der Modifier "firebug" kann an jede Variable angehängt werden, um die Ausgabe des Variableninhalts in die Firebug-Console zu bewirken.
Oft ist dies die bessere Debugginglösung, da die Ausgabe von Inhalten nicht durch Debugging-Ausgaben unterbrochen oder gestört wird.
[source,php]
-----------------------------------------------------------------------
{$variable|firebug} oder {$variable|@firebug}
-----------------------------------------------------------------------

=== Der Viewhelper Datagrid

Der Viewhelper Datagrid erzeugt den HTML Quelltext für eine Tabelle mit Navigations-, Sortierungs und Paginierungselementen.
Er vereinfacht die tabellarische Anzeige von Daten eines Models erheblich und trägt zu einer standardisierten Ausgabe bei.

==== ResultsPerPage einstellen

Um das Drop-Down Element "ResultsPerPage" anzupassen, kann die Methode setResultsPerPageItems() verwendet werden.

[source,php]
-----------------------------------------------------------------------
$datagrid->getRenderer()->setResultsPerPageItems(array ( 3, 5, 10, 25, 50));
-----------------------------------------------------------------------

==== Einzelne Anzeigemerkmale der Tabelle einstellen

Die Anzeigemerkmale können mittels der Methoden enableFeature(), disableFeature() einzeln ein- und ausgeschaltet werden.
Sie können sowohl einzelne, als auch gleich mehrere Merkmale ein- oder ausschalten.
Übergeben Sie den Methoden dazu entweder einen String oder ein Array mit mehreren Strings.

[source,php]
-----------------------------------------------------------------------
# Ausschalten eines Anzeigemerkmals mittels String
$datagrid->disableFeature('Label');

# Ausschalten mehrerer Anzeigemerkmale des Datagrids mittels Array
$datagrid->disableFeature(array('Label', 'Caption', 'Description'));
-----------------------------------------------------------------------