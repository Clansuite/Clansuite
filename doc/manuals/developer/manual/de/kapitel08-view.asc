////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 8 - Der View - von Render-Engines, Themes und Templates

Der View stellt die Daten des Modells dar und nimmt Nutzeraktionen entgegen. Es ist das V in MVC. Es handelt
sich also um die Präsentationsschicht der Anwendung.

Wir wissen bereits, dass die Module im Idealfall so programmiert sind, dass sie Logik soweit wie möglich von
der Darstellung trennen. Ein Modul bezieht seine Daten aus der Datenbank. Anschließend werden sie eventuell
noch bearbeitet und dann für die Ausgabe vorbereitet. Dann werden diese Daten an die Präsentationsschicht
übergeben.
Demnach darf ein Modul im Logikbereich keine direkte HTML-Ausgabe bewirken.

Die Präsentationsschicht arbeitet daher mit Templates. Alle Ansichten eines Moduls werden daher durch
Template-Implementierungen ermöglicht. In der Realität gibt es einige wenige Ausnahmen. So werden bei
Clansuite die Exception- und Fehlerbehandlungsseiten, sowie stark verschachtelte Baumstrukturen nicht
vollständig als Templates implementiert. Bei ersterem könnte ein Fehler im Bereich des Views die Darstellung
des Fehlers behindern. Clansuite verwendet allerdings Templates um die direkte Fehlerausgabe zu ergänzen. Mehr
dazu erfahren sie im Kapitel über das Fehler- und Exceptionhandling. Bei letzterem würde man die
Schleifenanweisung unnötig doppeln, einmal für die Aufbereitung der Baumstrukturen
und einmal für die Darstellung im Template.

Für Entwickler gilt die Faustregel: Ein Modul ist dann gut geschrieben, wenn nur Templatedateien geändert
werden müssen,
um die Ansichten vollständig zu verändern.

.Platzhalter
Im Bereich der Präsentationsschicht werden Platzhalter verwendet. Ein Platzhalter ist ein Zeichen oder eine
Zeichenkette, die stellvertretend für etwas steht. Es ist eine Positionsmarke für die später an dieser Stelle
anzuzeigenden Daten. Als Beispiel für Funktion und Nutzen von Platzhaltern, soll der Serienbrief dienen. Bei
einem Serienbrief wird ein Text an eine Vielzahl von Personen versandt. Dabei möchte man aber den Brieftext
nicht jedesmal neu schreiben müssen, nur weil sich im Briefkopf Name und Anschrift geändert haben. Regelmäßig
wird nun ein Platzhalter für die Adresse eingesetzt und die einzelnen Empfängeradressen in einer Datenbank
abgelegt.Beim Druck des Serienbriefs wird nun über die Empfängeradressen iteriert und diese werden in den
Briefkopf eingesetzt.

.Push und Pull View
Grundsätzlich lassen sich zwei Wege unterscheiden, wie die anzuzeigenden Daten in den View gelangen.
Wir unterscheiden "Push View" von "Pull View".
Beim Push View werden die anzuzeigenden Daten durch den Controller an den View übergeben.
Beim Pull View werden die anzuzeigenden Daten durch die Ansicht vom Modell erfragt.
Clansuite setzt beide Varianten ein.

.Modultemplates
Ein Module bringt regelmäßig Templates mit.
Diese kann man als Moduletheme bezeichnen.
Sie stellen die Basisausgabe des Moduls dar.
Das Verzeichnis der Templates ist "/modulename/templates".
Die Dateiendung der Templates ist ".tpl".

.Templatenamenskonvention
Templates haben eine Namenskonvention. Der jeweilige Actionname ist auch der Dateiname des Templates. Lautet
der Name der Action beispielsweise action_news_show(), so wird ein Template names action_news_show.tpl
erwartet. Die Templateautomatik wird im Bereich der Modullogik durch Verwendung der
Methode $this->prepareOutput() ausgelöst.
Abbedingen kann man sie durch explizites setzen eines anderen Templates mittels der Methode
setTemplate('meinAlternativesTemplate.tpl') innerhalb der jeweiligen Action.

.Erstellen eines Modulethemes
Diese Modultemplates kann man als Vorlage verwenden, wenn sie eine andere Art der Ausgabe bevorzugen.
Das geht sehr einfach, indem sie die das Template-Verzeichnis des Moduls mit samt den Templates
in einen Themeordner kopieren und dem Ordner den Namen des Moduls geben.

=== Unterstützung von Render Engines

=== Ablaufplan bis zum View eines Widgets

[source, txt]
---------------------------------------------------------------------
Smarty->trigger_error('Error! Failed t...')
smarty_function_load_module(Array, Object(Smarty), Object(Smarty_Internal_Template))
call_user_func_array('smarty_function...', Array)
Smarty_Internal_Plugin_Handler->__call('load_module', Array)
Smarty_Internal_Plugin_Handler->load_module(Array, 'function')
include('D:\xampplite\ht...')
Smarty_Internal_Template->renderTemplate()
Smarty_Internal_Template->getRenderedTemplate()
Smarty->fetch('index.tpl')
Clansuite_Renderer_Smarty->render('action_show.tpl')
Clansuite_ModuleController->prepareOutput()
Module_News->action_show()
Clansuite_ActionController_Resolver->processActionController(Object(Clansuite_HttpRequest), Object(Module_News))
Clansuite_FrontController->processRequest(Object(Clansuite_HttpRequest), Object(Clansuite_HttpResponse))
Clansuite_CMS::execute_Frontcontroller()
Clansuite_CMS::run()
---------------------------------------------------------------------

=== Ablaufplan bis zum Aufruf einer bestimmten RenderEngine am Beispiel von Smarty

[source, txt]
---------------------------------------------------------------------
Clansuite_CMS::run()
Clansuite_CMS::execute_Frontcontroller()
Clansuite_FrontController->processRequest( object(HttpRequest)[30], object(HttpResponse)[31] )

Module_Index->execute( object(HttpRequest)[30], object(HttpResponse)[31] )
ModuleController->processActionController( object(HttpRequest)[30] )
Module_Index->action_show( )
ModuleController->prepareOutput( )
ModuleController->getView( )
ModuleController->getRenderEngine( )

Clansuite_Renderer_Factory::getRenderer('smarty', Object(Phemto))
Clansuite_Renderer_Smarty->__construct(Object(Phemto), Object(Clansuite_Config))
Clansuite_Renderer_Smarty->initializeEngine()

Smarty_Internal_Template->renderTemplate()
Smarty_Internal_Template->getRenderedTemplate()
Smarty->fetch('index.tpl')

Clansuite_Renderer_Smarty->render('action_show.tpl')
---------------------------------------------------------------------

==== Viewhelper

Templates enthalten hauptsächlich HTML und Platzhalter. Jedoch gibt es auch in Templates bestimmte Stellen, an
denen wiederholend einsetzbare Präsentations-Logik nötig ist. Diese unterstützenden Funktionen der
Präsentations-Logik sind in sogenannten Viewhelpern enthalten. Das View-Helper-Pattern ergänzt also das MVC-
Pattern in der View-Schicht. Der Viewhelper "date" wird Sie beispielsweise dabei unterstüzen, den Datumsstring
in das richtige Datumsformat
umzuwandeln und anzuzeigen.

.Arten von Viewhelpern
Es gibt mehrere Arten von Viewhelpern. Zum einen gibt es die Block-Tag Viewhelper. Block-Tags benötigen immer
einen öffnenden und schließenden Tag. Beispielsweise benötigt der öffnende Tag <a> auch immer den schließenden
Tag </a>. Regelmäßig wird die Transformationsfunktion des Viewhelpers auf dem eingeschlossenen Inhalt
ausgeführt. Neben den Block-Tag Viewhelpern gibt es Tag Viewhelper und Platzhalter Modifizierer. Tag-
Viewhelper sind einfache Aufrufe von Funktionen der Präsentations-Logik. Beispielsweise wird der Tag-
Viewhelper {date} das Datum anzeigen. Modifizierer sind Annexfunktionen für Platzhalter. Sie führen ihre
Aufgabe direkt auf den Platzhalterdaten aus. Ein Beispiel für die Verwendung eines Modifizierer ist
{$name|@uppercase}. Hier wird der Inhalt der Variable $name der Modifierfunktion mit Namen "uppercase"
unterzogen. "Uppercase" sorgt dafür, das alle Zeichen in $name als Großbuchstaben formatiert ausgegeben werden.

.Verzeichnisse der Viewhelper
Die offiziellen Smarty Viewhelper befinden sich im Verzeichnis /libraries/smarty/plugins.
Sie werden bereits mit Smarty ausgeliefert.
Die Clansuite Viewhelper für Smarty befinden sich im Verzeichnis /core/viewhelper/smarty.
Es ist auch möglich, dass ein Modul ein Viewhelper-Plugin mitbringt.

Die oben genannten Pfade werden bei Initialisierung des Smarty Renderers 
als Plugin-Verzeichnisse registriert. Damit kann aus jedem Verzeichnis neue Funktionalität geladen werden.
footnote:[http://www.smarty.net/manual/de/tips.componentized.templates.php, Smarty Handbuch - Template/Script Komponenten]

.Der Viewhelper zur Übersetzung innerhalb von Templates

Der Viewhelper {t} ermöglicht das Übersetzen von Zeichenketten innerhalb von Templates.
Module sollten immer darauf achten, übersetzbar zu sein; für Templates gilt dasselbe.
Leute, die Themes erstellen benötigen den blanken Text, um damit arbeiten zu können
und Übersetzer erwarten, dass sämtlicher Text durch die Funktion t() geschleust wurde.
Aus diesen Gründen wird die Verwendung von t() in Templates zwingend empfohlen.

.Konfigurationsdateien in der Präsentationsschicht

Diese Funktionalität kann mittels Smarty erreicht werden.
Smarty bietet dazu den Tag {$smarty.config}, um auf Konfigurations-Variablen zuzugreifen.
Geladen werden kann eine Konfigurationsdatei mit dem Tag {config_load file='beispiel.conf'}.
Die Konfigurationsvariablen referenziert man im Template mit umschliessenden
Raute-Zeichen {#Konfigurationseinstellung#}.
footnote:[http://www.smarty.net/manual/de/language.function.config.load.php]

An dieser Stelle sei auch ein Vergleich zu Typo3's TypoScript gestattet. TypoScript ist, entgegen dem Namen,
keine Skriptsprache, sondern eine Anzahl von Konfigurationseinstellungen die als Baumstrukturen abgelegt sind
und eine Veränderung der Präsentation bewirken. Im wesentlichen entspricht die Konfigurationsdatei dem INI
Format mit Sektionen und Untersektionen entspricht. Nichts anderes stellen die Konfigurationsdateien von
Smarty dar. Letztlich wird hier nochmals im Präsentationsbereich abstrahieren und die
Veränderungsnotwendigkeit der Templatedateien selbst eingeschränkt, indem man die Konfigurationsdatei bearbeitet.