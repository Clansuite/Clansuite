////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 10 - Die Fehlersuche und die Behandlung von Fehlern und Ausnahmen

Das Kapitel beschäftigt sich mit Methoden und Werkzeugen der Fehlersuche (engl. debugging)
und der Behandlung von Fehlern und Ausnahmen (engl. Error-/Exceptionhandling).

=== Methoden und Werkzeuge zur Fehlersuche

Clansuite stellt eine Reihe von Debbuging Tools zur Verfügung, die dem Entwickler einen Einblick in einen
Problembereich eröffnen und somit beim lösen von Fehlern und entwickeln zur Seite stehen. Grundsätzlich kann
man die Aufgabe von Debugging Tools beschreiben, als das Bereitstellen von zusätzlichen Informationen, die bei
normaler Nutzung der Anwendung nicht eingesehen werden können. Sie erweitern also den Wahrnehmungsbereich des
Entwicklers. Die Erweiterung des Wahrnehmungsbereichs ist ebenfalls ein wichtiger Punkt im Bereich des Fehler-
und Exceptionshandlings. Ein abgeschaltete oder unterdrückte Fehlerbehandlung, bewirkt dass sich so mancher
Fehler unterhalb der Wahrnehmungsgrenze für den Entwickler bewegt. Für beide Bereiche gilt, dass sie jeweils
nur im Entwicklungsmodus eines Systems verfügbar sein sollten, da sie ansonsten Tür und Tor für eine
unbestimmte Vielzahl von Angriffen eröffnen.

Dies führt zur Feststellung das das Fehlerhandling teilweise automatisiert (durch die Sprache selbst erfolgt)
und teilweise durch den Entwickler gesteuert werden kann. Das Excpetionhandling und das Debugging sind
hingegen vollständig vom Entwickler steuerbar.

Die Problembereiche können dabei an mannigfaltigen Stellen auftreten, so z. B. im Bereich des
Zuweisungsgehalts einer Variablen oder einer Konstante oder bei komplexen mehrdimensionalen Arraystrukturen.
Man sollte meinen das eine Skript- bzw. Programmiersprache wie PHP5, die speziell als Sprache entwickelt
wurde, um Webanwendungen zu erstellen, ein funktional ausreichendes Angebot an Debuggingwerkzeugen
bereitstellt. Doch leider ist dies nicht der Fall. PHP bietet keine integrierten Debugging Werkzeuge. Das
Angebot im Bereich der Fehleranalyse ist spärlich und meiner Ansicht nach sträflich vernachlässigt worden.
Dies gilt sowohl für den Bereich des Highlevel-, wie auch des Lowlevel-Debuggings. Mit Highlevel-Debugging
bezeichne ich die Verwendung von PHP Umgebungserweiterungen, die einen tieferen Einblick in die Vorgänge des
Systems ermöglichen. Zu diesen Highlevel-Tools gehört Beispielseweise das Debugger-Projekt "xdebug".
Mit Lowlevel-Debugging meine ich PHP Syntaxelemente, die es ermöglichen auf einfache Art und Weise
eine Fehleranalyse durchzuführen.

==== Einfache Debugging-Elemente des PHP Syntax

Als einfache Elemente des PHP Syntax, die sich zum Debuggen eignen, kommen die folgenden Funktionen in Betracht.
Verwenden Sie bitte "var_dump();" anstelle von "print_r();", um den Inhalt einer Variablen zu prüfen.
Hilfreich ist oft auch "var_export;". Sollte eine bestimmte Stelle in der Applikation zu debuggen sein,
kann wahlweise mit einem anschießenden "exit();" der Applikationslauf gestoppt werden.
Ebenso steht "die();" zur Verfügung.

==== Clansuite_Xdebug

Mich das Funktionsangebot von PHP im Bereich des Debugging nicht zufrieden gestellt. Clansuite setzt daher
eine eigene Debugging Klasse ein, um die Programmierung des Systems einfacher und komfortabler zu gestalten.
Die Klasse Clansuite_Xdebug stellt Start und Stop Methoden bereit, um mit dem Debugger "Xdebug" zu
interagieren. Diese Methoden setzen also eine installierte PHP Erweiterung "Xdebug" voraus. Grundsätzlich wird
für das Debugging XDebug empfohlen. Als Highlevel-Debugging Extension verschafft Xdebug, im Gegensatz zur
normalen Debugging-Anzeige, eine Steigerung der Übersichtlichkeit bei Fehler- und Debugdumps durch verbesserte
Darstellung der Debuginformationen. Mit Xdebug lassen sich sehr einfach Funktionsaufrufe nachverfolgen,
Abhängigkeiten erkennen und die Laufzeit von Codeabschnitten ermittlen. Wenn Sie den XDebug-Modus des Systems
aktiviert haben, ist zusätzlich der Befehl "clansuite_xdebug::printR($assoc_array);" verfügbar. Der eine
nochmals verbesserte Anzeige von Variablen und assoziativen Arrays bereitstellt.
Die Verwendung ist trivial und analog zum PHP-Kommando print_r().

Hint: Den XDebug-Modus können sie aktivieren, indem sie in der Konfiguration (/configuration/clansuite.config.php)
die Einstellung [error] xdebug = 1 setzen.

==== Konfigurationseinstellungen für das Debugging

Weitere hilfreiche Debugging Einstellungen sind:

[source, php]
---------------------------------------------------------------------
[error]
suppress_errors = 0
debug = 1
xdebug = 1
debug_popup = 0

[switches]
phpdebug = 1
---------------------------------------------------------------------

[source, php]
---------------------------------------------------------------------
# Verwendung der statischen Methode printR() der Klasse clansuite_xdebug
clansuite_xdebug::printR($assoc_array);
---------------------------------------------------------------------

==== Debugging im Bereich der Präsentationsschicht

Für die Fehleranalyse im Bereich der Präsentationsschicht stehen eigene Kommandos zur Verfügung.

Verwendet man Smarty als RenderEngine, dann eignen sich die folgenden drei, die Variablenausgabe
modifizierenden Smarty Befehle (Smarty Modifiers), um den Inhalt einer Variable oder eines Arrays angezeigt
zu bekommen.

[source, php]
---------------------------------------------------------------------
# Zeigt ein strukturiertes Array innerhalb des Templates.
{$array|@var_dump}

# Die Ausgabe mit dem Modifier @dump zeigt ein strukturiertes Array in einer Box innerhalb des Templates.
{$array|@dump}

# Der Modifer @dump kann auch auf mehrdimentsionale Arrays und deren Schlüssel angewandt werden.
{$array.subarray|@dump:schlüssel}

/**
 * Zeigt nur das Array an.
 * Die restlichen Ausgaben werden unterdrückt und das Programm zu Debbuging-Zwecken abgebrochen.
 */
{$array|@debug}
---------------------------------------------------------------------

=== Der Errorhandler

Die Behandlung von Programmfehlern erfolgt mittels der Klasse Clansuite_Errorhandler.

Zahlreiche Webanwendungen machen von der Möglichkeit gebrauch, das Errorhandling an den Exceptionhandler zu
übertragen. Dies führt zu einer Vereinfachung des Systems, da nicht mehr zwei Handler-Klassen gepflegt werden
müssen. Clansuite nutzt diese Möglichkeit nicht. Dies hat zwei Gründe. Zum einen müsste der Exceptionhandler
intern prüfen, ob ein Error die Exception ausgelöst hat, womit eigentlich Logik des Errorhandlers in den
Exceptionhandler verschoben wird. Zum anderen soll es bei Clansuite möglich sein, dem jeweiligen Handler
ein eigenes Aussehn und eigene Templates zu geben.

==== Fehlerbehandlung für strike Typen
Auch PHP in der Version 5.2+ hat immernoch ein großes Problem im Bereich Typen.
Die Sprache PHP kennt keine strikten Typen (engl. Strict Types). PHP ist eine schwach typisierte Sprache.
Der Typ einer Variablen wird durch den Kontext bei ihrer konkreten Verwendung bestimmt.
Demnach können Variablentypen während der Laufzeit einer Typänderung unterliegen.
Dies bezeichnet man als automatisches bzw. dynamisches Type-Casting oder Type-Juggling
footnote:[http://php.net/manual/en/language.types.type-juggling.php]).
Es ist es möglich Variablen zu verwenden, ohne sie vorher zu deklarieren.

PHP stellt eine Möglichkeit bereit, um festzustellen, ob eine Variable initialisert wurde.
So lässt sich der Level der Fehlerberichterstattung mittels der Methode error_reporting() auf E_NOTICE setzen.
Nicht initialsierte Variablen werden dann als Fehler des Typs Notice angezeigt und man erhält zumindest einen Hinweis.
Clansuite wird seit Anfang der Entwicklung mit dem Fehlerberichterstattungslevel E_STRICT and E_NOTICE entwickelt.
Eine Alternative dazu, wäre der Einsatz eines externen Quelltext-Prüfwerkzeugs wie PHP Lint,
um diese Fehler hervorzuheben. Einige Editoren/IDEs integrieren ein solches Prüfwerkzeug bereits.

Die Verwendung von strikten Typen hingegen bringt einige Vorteile mit sich.
Fehler treten schneller hervor und die Ausdrucksstärke der Variablenverwendung in Funktionen und Methoden wird erhöht.
Beispielsweise kennt PERL ein "use strict", doch ein solches fehlt bei PHP noch immer.

.Die Weiterentwicklung von PHP im Hinblick auf die Unterstützung striker Typen
Gegenwärtig wird sowohl auf der PHP-Mailingliste als auch im PHP-Wiki über die Unterstützung
strikter Typen diskutiert. Lukas Smith hat am 03.06.2009 eine PHP-RFC zum Thema "Typechecking"
footnote:[http://wiki.php.net/rfc/typechecking, PHP RFC Typechecking Vorschlag von Lukas Smith]
verfasst, sein Entwurf ist unter http://wiki.php.net/rfc/typecheckingstrictandweak abrufbar.
Ein weiterer Vorschlag footnote:[http://wiki.php.net/rfc/typecheckingstrictonly, PHP RFC
Typechecking Vorschlag von Ilia Alshanetsky] von Ilia Alshanetsky
zum Thema Typechecking befasst sich mit der Ergänzung der Reflection-Erweiterung
um typdefinierende ReflectionParameter Methoden. Er führt zum Beispiel Methoden
wie ReflectionParameter::isInt() oder ReflectionParameter::isBool() zur Typprüfung mittels Reflektion ein.

==== Die Clansuite Errorcodes

Um Fehler auszulösen kann der PHP-Befehl trigger_error() eingesetzt werden.
Statt der Verwendung von Errors bitte Exceptions verwenden.

[source, txt]
---------------------------------------------------------------------
E_USER_WARNING
E_USER_NOTICE
E_USER_ERROR
---------------------------------------------------------------------

=== Der Exceptionhandler

Die Exceptionbehandlung ist ähnlich der Behandlung von Errors. Die Klasse Clansuite_Exception erweitert die
normale PHP Exception Klasse. footnote:[http://php.net/exceptions, PHP Handbuch - Kapitel Exceptions] Die
Erweiterung besteht dabei einerseits in verbesserter Darstellung der Exceptions, andererseits in dem
automatischen auffangen aller nicht abgefangenen Exceptions, z.B. denen fremder Bibliotheken.

Kern der Klasse ist die Methode yellowScreenOfDeath(), mit der eine Darstellungsmethode für Exceptions
eingeführt wird. Sie zeigt Exceptionmessage und Code, sowie die Ausgabe der nicht abgefangenen Exception an.
Erweitert wird die Anzeige durch Debuginformationen, wie z.B. dem Debug-Call-Stacktrace, welcher die zuletzt
ausgeführten Methodenaufrufe vor dem Exceptioneintritt aufführt und der Anzeige von Direktlinks zum Support
und zu den Handbüchern.

Mittels set_exception_handler wird ein systemweiter Exceptionhandler registriert. Er sorgt dafür, dass nicht
abgefangene Exceptions mittels dieser Darstellungsmethode anzeigt werden. Dies erfolgt bei Initialisierung des
Systems innerhalb der Methode initialize_Errorhandling() in der Datei "bootstrap/clansuite.application.php".
Dieser wirft durch Aufruf der Methode throwException() eine neue Clansuite_Exception.

==== Das Werfen von Exceptions

[source, php]
---------------------------------------------------------------------
# Hier wird eine normale Exception geworfen.
# Diese wird durch den Exception Handler gefangen und in eine Clansuite Exception umgewandelt.
throw new Exception('Meine Exception');

# Es wird eine Clansuite Exception mit der Exceptionnummer 60 geworfen.
# Sollte ein Exception Template für die Nummer 60 existieren, wird sein
# Inhalt innerhalb des Exception-Kontext dargestellt.
throw new Clansuite_Exception('Meine Exception', 60);

# Werfen einer Exception
Clansuite_Exception->throwException(),

# Verwendung bei Methoden, die einen Wert des Typs Boolean zurückliefern
someBooleanMethod() or throwException();

# Beispielsweise
isFileandReadable('filename.txt') or throwException('File not found or not readable!');
---------------------------------------------------------------------

==== Die Exceptionhandler Templates

Der Exceptionhandler bietet die Möglichkeit mit Exceptiontemplates zu arbeiten. Das sind Templates die zu
einer Exception einen ausführlicheren Beschreibungstext anbieten und somit den Kontext der Exception
erläutern, um den Fehler zu überwinden. Jeder Exception ist eine Identifikatonsnummer zugewiesen, anhand
dieser wird ein entsprechendes Template geladen.

Dabei unterscheiden wir zwei Arten von Exceptiontemplates. Zum einen normale Exceptiontemplates. Die angezeigt
werden, wenn das System im Debugmodus betrieben wird. Zum anderen Entwickler-Exceptiontemplates. Die angezeigt
werden, wenn das System im Debug- und Developermodus betrieben wird. Die Exceptionstemplates befinden sich im
Verzeichnis "themes\core\exceptions".

Der Unterschied zwischen der beiden Arten von Templates findet seinen Ausdruck in der Benennung der
Templatedateien. Der Dateiname normaler Exceptiontemplates lautet "exception-x.tpl". Der Dateiname von
Entwickler-Exceptiontemplates lautet "dev-exception-x.tpl". Hierbei steht das "x" jeweils für den
Exceptioncode, die eindeutige Identifikationsnummer. Wenn für einen Excpetioncode beide Templates existieren,
dann werden auch beide nacheinander innerhalb der Exceptionanzeige angezeigt.
Die Reihenfolge der Darstellung ist dabei Normaltemplate vor Entwicklertemplate.

==== Die Exceptionhandler Codes

Nachfolgende Tabelle schlüsselt die bisher vergebenen Exceptioncodes auf.
Eine entsprechende Datei befindet sich auch im Verzeichnis der Templates
/themes/core/exception/errorcodes.txt.

[source,txt]
---------------------------------------------------------------------
Exceptioncode    Exceptionname                                        Used in File               Method
----------------------------------------------------------------------------------------------------------------------
dev-1            Database Connection Information invalid              /core/doctrine.core.php    prepareDbConnection()
dev-2            Action Missing. Create now.
dev-3            Module Missing. Create now.
dev-4            Config Missing. Create now.                          /ini.config.php            readConfig()
----------------------------------------------------------------------------------------------------------------------
09               Smarty Template Directories do not exist.            startup_checks.filter.php
10               Smarty Template Directories not writable.            "

12               The copyright tag is missing.                        Smarty.renderer.php
                 {include file='copyright.tpl'}
                 in your layout/wrapper template file:
13               The header notice tag is missing.
                 {include file='clansuite_header_notice.tpl'}         "
14               The content variable {$content} must be within       "
                 the wrapper template
---------------------------------------------------------------------