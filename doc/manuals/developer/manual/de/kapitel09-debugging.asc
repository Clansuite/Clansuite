////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://docs.clansuite.com/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 9 - Die Fehlersuche und das Testen

Das Kapitel gliedert sich in zwei thematisch zusammenhängende Teile.
Der erste Abschnitt beschäftigt sich mit Methoden und Werkzeugen der Fehlersuche (engl. debugging) in Clansuite.
Bei der Fehlersuche geht es darum, den Ursprung eines Fehlers in der Software zu finden und zu beheben.
Der zweite Abschnitt beschäftigt sich mit einer speziellen Form der Fehlervorbeugung, dem Testen.
Beim Testen geht es darum, Fehler zu finden und es gar erst zu einem Fehler kommen zu lassen.

=== Methoden und Werkzeuge zur Fehlersuche

Clansuite stellt eine Reihe von Debugging Tools zur Verfügung, die dem Entwickler einen Einblick in einen
Problembereich eröffnen und somit beim Lösen von Fehlern und Entwickeln zur Seite stehen. Grundsätzlich kann
man die Aufgabe von Debugging Tools beschreiben, als das Bereitstellen von zusätzlichen Informationen, die bei
normaler Nutzung der Anwendung nicht eingesehen werden können. Sie erweitern also den Wahrnehmungsbereich des
Entwicklers. Die Erweiterung des Wahrnehmungsbereichs ist ebenfalls ein wichtiger Punkt im Bereich des Fehler-
und Exceptionshandlings. Eine abgeschaltete oder unterdrückte Fehlerbehandlung, bewirkt dass sich so mancher
Fehler unterhalb der Wahrnehmungsgrenze für den Entwickler bewegt. Für beide Bereiche gilt, dass sie jeweils
nur im Entwicklungsmodus eines Systems verfügbar sein sollten, da sie ansonsten Tür und Tor für eine
unbestimmte Vielzahl von Angriffen eröffnen.

Dies führt zur Feststellung das das Fehlerhandling teilweise automatisiert ist und teilweise durch den 
Entwickler gesteuert werden kann. So wird PHP automatisch einen Fehler werfen, wenn sie eine 
Syntaxregel misachten. Das Exceptionhandling und der Einsatz von Debugging-Befehlen sind
hingegen vollständig vom Entwickler steuerbar.

Die Problembereiche können dabei an mannigfaltigen Stellen auftreten, so z. B. im Bereich des
Zuweisungsgehalts einer Variablen oder einer Konstante oder bei komplexen mehrdimensionalen Arraystrukturen.
Man sollte meinen, dass eine Skript- bzw. Programmiersprache wie PHP5, die speziell als Sprache entwickelt
wurde, um Webanwendungen zu erstellen, ein funktional ausreichendes Angebot an Debuggingwerkzeugen
bereitstellt. Doch leider ist dies nicht der Fall. PHP bietet keine integrierten Debugging Werkzeuge. Das
Angebot im Bereich der Fehleranalyse ist spärlich und meiner Ansicht nach sträflich vernachlässigt worden.
Dies gilt sowohl für den Bereich des Highlevel-, wie auch des Lowlevel-Debuggings. Mit Highlevel-Debugging
bezeichne ich die Verwendung von PHP Umgebungserweiterungen, die einen tieferen Einblick in die Vorgänge des
Systems ermöglichen. Zu diesen Highlevel-Tools gehört Beispielseweise das Debugger-Projekt "xdebug". Mit
Lowlevel-Debugging meine ich PHP Syntaxelemente, die es ermöglichen auf einfache Art und Weise
eine Fehleranalyse durchzuführen.

==== Einfache Debugging-Elemente des PHP Syntax

Als einfache Elemente des PHP Syntax, die sich zum Debuggen eignen, kommen grundsätzlich die Ausgabefunktionen
"echo", "print", "print_r", "var_export", "var_dump" und die Abbruchfunktionen "exit" und "die" in Betracht.

Verwenden Sie bitte "var_dump();" anstelle von "print_r();", um den Inhalt einer Variablen zu prüfen.
Hilfreich ist oft auch "var_export();". Sollte eine bestimmte Stelle in der Applikation zu debuggen sein,
kann wahlweise mit einem anschießenden "exit();" oder einem "die();" der Applikationslauf gestoppt werden.

==== Erweitertes Debugging mit dem Clansuite_Logger

==== Erweitertes Debugging mit der FirePHP Debugkonsole

FirePHP ist eine Erweiterung für FireBug. Beides sind Addons für Firefox. Die Funktionsweise von FirePHP ist
trivial. Die anzuzeigenden Daten werden einer PHP Methode übergeben. Diese setzt sie in den Antwortheader (X-
FirePHP-Data). Dort werden sie von der FirePHP Erweiterung ausgelesen und in der FireBug-Konsole dargestellt.
Auf diese Art und Weise vermischt sich der Debugoutput nicht mit dem eigentlichen Seiteninhalt.

[source, txt]
---------------------------------------------------------------------
Das Firefox Addon FireBug erhalten sie unter
https://addons.mozilla.org/en-US/firefox/addon/1843

Das Firefox Addon FirePHP erhalten sie unter
https://addons.mozilla.org/en-US/firefox/addon/6149
---------------------------------------------------------------------

Methode 1 - Direkte Verwendung der FirePHP Klasse

[source, php]
---------------------------------------------------------------------
# Laden der FirePHP Klasse
require ROOT_LIBRARIES.'firephp/FirePHP.class.php');
# Instanzierung über Singleton
$firephp = FirePHP::getInstance(true);

# Loggen in die Konsole
$firephp->log('Hello World');
$firephp->dump('Key', 'Value');
$firephp->fb('Schreiben in die Konsole');
---------------------------------------------------------------------

Methode 2 - Indirekte Verwendung über die Methode Clansuite_Xdebug::firebug()

Wenn Sie Clansuite_Debug verwenden, dann können Sie sich die Zeilen zur Initalisierung von FirePHP sparen,
denn die statische Methode Clansuite_Debug::firebug() erledigt dies für Sie. Die Methode übergibt der Konsole
ebenfalls den Ort an dem sie eingesetzt wird. Dies erleichtert das Wiederfinden der Debugging-Position im Quellcode.

[source, php]
---------------------------------------------------------------------
# Gibt den Inhalt von $variable in der FireBug Konsole aus und verwendet dabei das Kommando log().
Clansuite_Debug::firebug($variable);

# Folgende String-Werte sind als zweiter Parameter verwendbar: info, log, warn, error.
# Gibt den Inhalt von $variable in der FireBug Konsole aus und verwendet dabei das Kommando error().
Clansuite_Debug::firebug($variable, 'error');
---------------------------------------------------------------------

TIP: Setzen Sie Codevervollständigung ein, um dieses oft benötigte Kommando nicht ständig tippen zu müssen.
Ich schlage Ihnen die Verwendung der Zeichenkette "fbg" für den Textschnippsel "Clansuite_Debug::firebug($variable);"
vor. So brauchen Sie nur noch den Variablennamen ersetzen und sparen sich Zeit und Tipparbeit. 

==== Clansuite_Debug und Clansuite_Xdebug

Mich hat das Funktionsangebot von PHP im Bereich des Debugging nicht zufrieden gestellt. Clansuite setzt daher
eine eigene Debugging Klasse ein, um die Programmierung des Systems einfacher und komfortabler zu gestalten.
Es gibt die Klasse Clansuite_Debug, welche verschiedene Hilfsfunktionen, wir printR()und firebug() bereitstellt.
Desweiteren gibt es die Klasse Clansuite_Xdebug. Sie stellt Start und Stop Methoden bereit, um mit dem Debugger
"Xdebug" zu interagieren. Diese Methoden setzen also eine installierte PHP Erweiterung "Xdebug" voraus.
Grundsätzlich empfehle ich für das Debugging XDebug. Als Highlevel-Debugging Extension verschafft Xdebug,
im Gegensatz zur normalen Debugging-Anzeige, eine Steigerung der Übersichtlichkeit bei Fehler- und Debugdumps
durch verbesserte Darstellung der Debuginformationen. Mit Xdebug lassen sich sehr einfach Funktionsaufrufe
nachverfolgen, Abhängigkeiten erkennen und die Laufzeit von Codeabschnitten ermittlen.

Hint: Den Debug-Modus können sie aktivieren, indem sie in der Konfiguration (/configuration/clansuite.config.php)
die Einstellung [error] debug = 1 setzen. Für den XDebug-Modus setzen sie [error] xdebug = 1.

===== Die Methode Clansuite_Debug::printR()

Wenn Sie den Debug-Modus des Systems aktiviert haben, ist zusätzlich der Befehl "Clansuite_Debug::printR($assoc_array);"
verfügbar. Der Befehlt hat drei Vorteile. Erstens verbessert er die Anzeige von Variablen und assoziativen
Arrays. Diese werden übersichtlich aufbereitet und farblich hervorgehoben. Zweitens zeigt er den genauen Ort
seiner Verwendung an. Somit ist ein schnelles Wiederfinden des Debug-Statements innerhalb des Quellcodes
gewährleistet. Dies ist insbesondere dann hilfreich, wenn sie mehrere Debug-Statements einsetzen. Drittens
wird die Applikation an dieser Stelle automatisch gestoppt. Ein Nachschieben der Anweisungen exit; oder die;
entfällt. Die Verwendung ist trivial und analog zum PHP-Kommando print_r().

==== Konfigurationseinstellungen für das Debugging

Weitere hilfreiche Debugging Einstellungen sind:

[source, php]
---------------------------------------------------------------------
[error]
suppress_errors = 0
debug = 1
xdebug = 1
debug_popup = 0

[switches]
phpdebug = 1
---------------------------------------------------------------------

[source, php]
---------------------------------------------------------------------
# Verwendung der statischen Methode printR() der Klasse Clansuite_Debug
Clansuite_Debug::printR($var);

# Verwendung der statischen Methode xd_varDump() der Klasse Clansuite_Xdebug
Clansuite_Xdebug::xd_varDump($var);
---------------------------------------------------------------------

==== Debugging im Bereich der Präsentationsschicht

Für die Fehleranalyse im Bereich der Präsentationsschicht stehen eigene Kommandos zur Verfügung.

Verwendet man Smarty als RenderEngine, dann eignen sich die folgenden drei, die Variablenausgabe modifizierenden Smarty Befehle
(Smarty Modifiers), um den Inhalt einer Variable oder eines Arrays angezeigt zu bekommen.

[source, php]
---------------------------------------------------------------------
# Zeigt ein strukturiertes Array innerhalb des Templates.
{$array|@var_dump}

# Die Ausgabe mit dem Modifier @dump zeigt ein strukturiertes Array in einer Box innerhalb des Templates.
{$array|@dump}

# Der Modifer @dump kann auch auf mehrdimentsionale Arrays und deren Schlüssel angewandt werden.
{$array.subarray|@dump:schlüssel}

/**
 * Zeigt nur das Array an.
 * Die restlichen Ausgaben werden unterdrückt und das Programm zu Debbuging-Zwecken abgebrochen.
 */
{$array|@debug}
---------------------------------------------------------------------

==== Profiling

===== Profiling mit XDebug

Das Profiling mit XDebug gestaltet sich sehr einfach.
XDebug protokolliert im Hintergrund die Funktionsaufrufe und die 
relevanten Daten der Systemumgebung (Speicherverbrauch, Zeit) in eine Logdatei.
Diese Logdatei kann anschließend mittels eines Analysewerkezugs wie 
wie KCachegrind oder Webgrind ausgewertet und visualisiert werden.
Grundlegende Voraussetzung ist, dass die PHP-Erweiterung XDebug geladen ist.
Als weitere Voraussetzung kommt das Aktivieren des XDebug Profilers hinzu.

Es gibt zwei Möglichkeiten den XDebug-Profiler zu aktivieren.
Einerseits kann man ihn dauerhaft aktivieren.
Hierfür setzt man in der php.ini die Einstellung "xdebug.profiler_enable = 1".
Alternativ dazu, kann man eine Aktivierung des Profilers über 
einen den GET/POST Requestparameter XDEBUG_PROFILE veranlassen,
beispielsweise durch den GET-Aufruf http://localhost/clansuite/index.php?XDEBUG_PROFILE.
Denn unter Umständen soll nicht jede Scriptausführung durch den Profiler 
mitgeloggt werden, denn dies verursacht schließlich zusätzliche Last.
Hierfür setzt man in der php.ini die Einstellung "xdebug.profiler_enable_trigger = 1".

===== Profiling mit XHProf

XHProf wurde ursprünglich als Profiler für Facebook entwickelt und im März 2009 als Open-Source verfügbar gemacht.
Facebook setzt XHProf im Rahmen der hauseigenen closed-source Monitoring-Lösung XHProfLive ein.
Es ist ein hierarchischer Profiler, der in C implementiert wurde und als Zend Extension zur Verfügung steht.

Der Profiler arbeitet auf Ebene der Funktionsaufrufe. Er misst deren Verarbeitungszeit (Wall Time), die CPU-Last und 
den Speicherverbrauch, sowie die Anzahl der Aufrufe pro Funktion.
Die während des Profilings gesammelten Daten sind über ein einfaches Webinterface (PHP) einsehbar.
Die Aufrufreihenfolge wird mittels eines Call-Graphen visualisiert. Die Visualisierung mittels Call-Graphen trägt dazu bei, 
den Überblick über größere Applikationen und Frameworks zu bewahren und ermöglicht so ein besseres Verstehen des Systems. 

PECL Projekt Webseite: http://pecl.php.net/package/xhprof
Github "facebook XHProf": http://github.com/facebook/xhprof
Github "XHProf GUI": https://github.com/preinheimer/xhprof
Webseite: http://mirror.facebook.net/facebook/xhprof/ 
Dokumentation: http://mirror.facebook.net/facebook/xhprof/doc.html

=== Das Testen

==== Warum eine Testsuite?

Wer vorher testet, muss später weniger Fehler beheben. Das Ziel des Testens ist Fehler zu entdecken.

Glenford J. Myers definiert das Testen wie folgt:
"Testen ist der Prozeß, ein Programm mit der Absicht auszuführen, Fehler zu finden.".
footnote:[Glenford J. Myers, Methodisches Testen von Programmen, 1995, Oldenburg Verlag]

==== Was ist eine Testsuite?

Eine Testsuite ist eine Sammlung von mehreren Tests. Diese Sammlung wird mittels eines Test-Werkzeugs
durchlaufen. Ein Test ist eine Funktionsüberprüfungen. Die Funktionsüberprüfung besteht immer aus zwei Teilen,
der Funktionsbeschreibungen und dem Aufruf der entsprechenden Funktion der Applikation.
Ein Test ist also ein Beispiel dafür, wie sich der Quellcode (später) verhalten soll.
Der Bericht nach einer Funktionsüberprüfung, das sogenannte Testprotokoll, gibt Auskunft darüber,
ob Clansuite die vom Test gewünschte Funktionen ordnungsgemäß bereitstellt.
Der zusammenfassende Bericht gibt nach Durchlaufen aller Funktionsüberprüfungen Auskunft über
alle identifizierten Fehlfunktionen. Man nennt ihn Testabdeckungsbericht (engl. Coverage-Report).
Die Suche nach den Defekten und die Analyse der Fehlfunktionen gehört nicht in den Bereich des Testens.

.Test-getriebene Entwicklung bzw. Negative Todo-Liste

Man kann Tests als negative Aufgaben- bzw. Todoliste verstehen und auch so einsetzen.
Dabei schreibt man zuerst den Test, definiert also was von Clansuite erwartet wird und welche Funktion von Clansuite erfüllt
werden soll. Lässt man den Test nun laufen, bekommt man logischerweise einen negativen Bericht für diesen
Test. Er wurde nicht erfolgreich durchlaufen. Nun schreibt man die eigentliche Funktion für Clansuite. Lässt
man den Test erneut laufen, wird er erfolgreich durchlaufen und man kann sicher sein, dass dieses Feature
funktioniert. Bei diesem Verfahren spricht man von "Test getriebener Entwicklung" (engl. Test-Driven-Development,
abgekürzt auch TDD). 

Das Verfahren lässt sich in die drei typische TDD-Schritte aufteilen:
1. Einen neuen Test schreiben [Neues Feature bzw. Neue Funktion beschreiben]
2. Den Test scheitern lassen [Failure]
3. Code schreiben, bis Test erfüllt ist [OK]

Um einen Bug, also einen Programmfehler, mittels TDD-Verfahren zu beseitigen, kann man folgendermaßen vorgehen:
1. Einen neuen Test schreiben, der den Bug entlarvt [Fehler wird beschrieben]
2. Der Test scheitert, weil der Bug existiert [Failure]
3. Bugfix-Code schreiben, bis der Test erfüllt und der Bug gefixt ist [OK]
Man spricht von "Test getriebenen Bugfixing".

.Regressionstests
An dieser Stelle ist es sinnvoll auch die sogenannten Regressionstests anzusprechen.
Unter einem Regressionstest versteht man die Wiederholung von Testfällen, um Verschlechterungen, 
also Brüche, in der Software zu finden. Regressionstests haben mehrere Voraussetzungen.
Zunächst ist ein testabgedecktes und erfolgreich getestetes Feature erforderlich.
Dann ist eine Veränderung erforderlich, die zu einem Bruch in der Software 
und somit des bereits erfolgreich bestandenen Tests führt. Insoweit kann man sagen,
dass eine Verschlechterung durch einen Verbesserungsversuch (mit-)verursacht wurde.

Regressionstests knüpfen an den Zusammenhang zwischen dem alten Testlauf, dem verschlechterten Testlauf
und dem wieder ausgebesserten Testlauf an. In der Praxis werden Testfälle lediglich "kontinuierlich" wiederholt.
An dieser Stelle setzen Werkzeuge zur kontinuierlichen Integration an (bspw. Hudson/Jenkins , CruiseControl, Atlassian Bamboo), 
die dem Entwickler die Arbeit des ständigen Wiederholens des Testens abnehmen und für eine automatisierte Wiederholung 
der Testfälle sorgen. In welchem Testlauf ein Testfehler auftrat und/oder wieder behoben wurde ist dabei irrelevant.
Ich bezeichne diese Art des Testens als "vertikales" Testen.

Theoretisch müsste ein Regressionstest jedoch durch die Testformulierung einen Bezug zwischen dem letzten 
erfolgreichen Test (Testlauf-1), dem nachfolgenden erfolglosen Test aufgrund der Modifikation (Testlauf-2) 
und dem Beheben des Regressionsfehlers (Testlauf-3) hergestellt werden. Mir ist jedoch kein Testsystem bekannt,
dass eine solche Erwartung bereitstellt, um eine Rückverknüpfung zwischen den Testergebnissen mehrerer Testläufe herzustellen.
Ich bezeichne diese Art des Testens als "horizontal", da durch Regressionstests horizontale Verknüpfungen zwischen 
den "vertikalen" Testläufen hergestellt werden.

.Vorteile Test-getriebener Entwicklung
Die Test schaffen Sicherheit darüber, dass der Code auch tatsächlich das tut, was in der Funktionsprüfung beschrieben wurde.
Beim Implementieren des Code wird der Entwickler durch die Tests geführt.
Dabei wird keine Zeile Code geschrieben, die nicht tatsächlich auch gebraucht wurde.
Der geschriebene Code ist in der Zukunft leicht änderbar und man wird durch Tests darauf hingewiesen, 
wenn etwas kaputt gemacht wurde. Somit lassen sich beispielsweise die angesprochenen Regressionsfehler in den Griff bekommen.

a) Überblick wahren
Es ist grundsätzlich sehr schwierig die Übersicht über die Tests zu behalten.
Schon für eine kleine Applikation wächst die Anzahl der Testfälle sehr schnell an.
Allerdings ist die Wahrung der Zuordung von Test zu Programmcode sehr wichtig.
Daher ist eine systematische und kontextabhängige Ablage und Ordnung der Tests im Dateisystem 
zu empfehlen. Beispielsweise können Tests nach Klassen und Funktionen sortiert abgelegt werden.
Jeder Test sollte zudem im Dokumentationsblock einen natürlich-sprachlicher Kommentar enthalten,
der Aufschluss über die Absicht des Tests gibt. Damit kann auch nach längerer Zeit und mehreren 
beteiligten Entwicklern die Frage beantwortet werden, warum der Test existiert.

b) Tests erstellen, die die Datenbank verwenden
Das Arbeiten mit einer Datenbank und Tests kann sich am Anfang recht schwierig gestalten.
Die Lösung ist das Einrichten einer gleichbleibenden Testumgebung, welche die Datenbank 
vor den auszuführenden Tests initialisiert. Dazu wird vor jedem Test ein Script aufgerufen,
dass die Datenbank klont, ohne aber Daten zu übernehmen. 
Für die Dauer des/der Tests wird so eine reine Testdatenbank eingesetzt.
Grundsätzlich werden bei diesem Verfahren also mehrere Datenbanken eingesetzt.

c) Testszenario entwerfen
Es ist wichtig mit Daten zu arbeiten, die nah an der Realität sind.
Grundsätzlich neigen Programmierer dazu, lediglich Testdaten im Stil von "Blabla123" oder "Test123". 
Testdaten sind jedoch Daten, die real aussehen. Nach Möglichkeit kann für die Generierung von Testdaten 
auf Hilfswerkzeuge, wie z.B. die Beispieldaten-Bibliotheken "Faker" zurückgegriffen werden.

d) Stubs
Stubs ersetzen Objekte oder Methoden für den Zeitraum des Tests durch Test-Dummys. So lassen sich beispielsweise 
Schnittstellenaufrufe bzw. API Aufrufe von Onlinediensten wie PayPal oder GoogleMaps "ersetzen". Der Code wird für 
den Moment des Tests von externen Abhängigkeiten, Nebenwirkungen und langwierigen Abläufen (Verbindung zum Onlineservice)
befreit werden.

e) Mocks
Mocks ersetzen Objekte oder Methoden für den Zeitraum des Tests durch Test-Dummys.
Damit kann getestet werden, ob Methoden wie erwartet aufgerufen wurden, und, ob die Kommunikation
mit externen Abhängigkeiten tatsächlich reibungslos funktioniert, ohne den Ablauf tatsächlich zu starten.

f) Benutzeroberfläche testen / Frontendtests
Für das Testen der Benutzeroberfläche muss sich der Test wie ein User verhalten und sich durch die Webanwendung klicken.
Die Web-Benutzeroberflächen sind aber nicht dafür erstellt worden, um von einer Maschine getestet zu werden.
Daher gestaltet sich das Testen von Benutzeroberflächen als relativ kompliziert.
Die Testumgebung muss sich auf HTTP-Aufrufe, HTML-Quelltext, Umgang mit Formularen und die Auswertung von Cookies verstehen.
Um diesen Vorgang zu automatisieren stehen Werkzeuge wie "Selenium", "Webrat" oder "Cucumber" bereit.
Dabei werden die Benutzerschritte aufgezeichnet und sind später automatisiert und als Test abspielbar.
Hierbei ist ein systematisches Durcharbeiten durch die Möglichkeiten der Benutzeroberfläche erforderlich.

===== Testabdeckungsbericht (Code-Coverage Report)

Der Code-Coverage Bericht gibt Aufschlüss über den Grad an Testabdeckung.
Von diesem Report werden bestimmte Bestandteile von Clansuite ausgeschlossen.

a) Tests - Denn Tests werden nicht getestet.
b) Templates - Denn in Templates werden nur Variablen eingesetzt.
c) Fremde Bibliotheken, Komponenten und Drittanbieter (3th party) Code - Denn wir sind nicht für die Tests zuständig.

===== Simpletest als Testwerkzeug

Wir verwenden Simpletest für automatisierte Tests gegen den Clansuite Core und Module.
Die Tests befinden bei der Entwicklerversion im Verzeichnis "/tests".
Dieser Ordner wird jedoch bei Neubildung von Clansuite entfernt.
Um alle Tests im Browser auszuführen, ruft man "/tests/runAllTests.php" auf.

Wir "runAllTests.php" auf der CommandLine aufgerufen, so bewirkt dies die 
XML Ausgabe im JUnit Format. Die erste Version dieser Ausgabe wurde von Steven Jones
footnote:[http://www.computerminds.co.uk/hudson-and-simpletest] 
erarbeitet und später als Extension in den SimpleTest Core aufgenommen.

Nachfolgend finden Sie die Webseite des Simpletest Projekts:
http://sourceforge.net/projects/simpletest/
https://sourceforge.net/project/showfiles.php?group_id=76550

===== Kontinuierliche Integration mit Jenkins (früher Hudson)

Jenkins und Hudson sind synonyme Begriffe für Butler oder Diener. 
Es ist ein java-basierter modularer Serverdaemon. Die Einrichtung und der Umgang mit einem 
Server zur kontinuierlichen Integration gestaltet sich wie nachfolgend beschrieben.

Voraussetzung ist eine kontinuierliche Integration von Quellcode. Das bedeutet, dass die 
Mitglieder des Entwicklungsteams ihre Arbeitsanteile in regelmäßigen Abständen
in das zentrale Quellcode-Repository einstellen. Natürlich können hierbei mehrfache 
Integrationen an einem Tag vorkommen. Jede Integration wird getestet und man bekommt
ein Feedback, ob die Integration das System nachteilig verändert hat.

Normalerweise wird Quellcode kompiliert. Diese Aufgabe würde Jenkins übernehmen und damit auch
den Entwicklerrechner entlasten, den regelmäßig dauert das kompilieren größerer Applikation unter
Einbeziehung verschiedener Bibliotheken lange. Es besteht die Möglichkeit den Komplierungsprozess auf mehrere Rechner zu verteilen.
Hierbei fungiert Jenkins als Master-Server und die Clients als Slaves.
Im PHP Umfeld entfällt dieser Kompilierungsvorgang gänzlich.
Ein CI-Server nimmt hier lediglich qualitätssichernde Aufgaben wahr.

Der Server arbeitet folgende Schritte ab:
1) Er stellt eine Verbindung zum Quellcode-Repository her
   Dies kann zeitgesteuert oder ereignisgesteuert erfolgen, beispielsweise ausgelöst 
   durch die letzte Integration bzw. den letzten Commit.
2) Der Arbeitsbereich wird geupdatet
   Dazu wird der Arbeitsbereich zunächst gesäubert.
3) Sodann werden die Buildscripte ausgeführt
   Dies sind häufig Shell-Scripte oder Ant bzw. im PHP-Umfeld Phing Anweisungen.
   Für komplexe Buildanweisungen können diverse Kommandozeilenargumente und Variablen als Platzhalter eingesetzt werden.
4) Bereitstellen der Ergebnisse bzw. Reports
   Wichtigste Aufgabe ist natürlich das Bereitstellen der Ergebnisse der zahlreichen Werkzeuge zur Quellcodeuntersuchung.

An dieser Stelle kann Jenkins seine Stärke als Reporting und Monitoring Werkzeug voll ausspielen.
Sowohl die Geschichte eines Projekts über eine Anzahl von Builds, aber auch
eine Übersicht über alle ausgeführten Shellscripte für jeden Build, sowie eine
Übersicht über Unit-Tests und den Test-Trend werden bereitgestellt.
Aufgrund der modularen Architektur des Systems können weitere Reportingwerkzeuge sehr einfach integriert werden.
Gleiches gilt natürlich für den Bereich der Benachrichtigungswerkzeuge.
Hier gibt es bereits viele verschiedene Benachrichtungs-Plugins.
Neben den grundsätzlichen Funktionen wie Start, Changelog, Stop, Status, ist es auch 
möglich eine Blame-Funktion (Autor X broke the build) bzw. Praise-Funktion (Autor X fixes the build)
einzusetzen.

5) Zu guter Letzt kommt Hudson als Deploymentwerkzeug ins Spiel.
   Nach erfolgreichem Test wird die Software zusammengepackt und zum Download bereitgestellt. 

===== Selenium als Testwerkzeug

Wir verwenden die Firefox Erweiterung "Selenium IDE" für die Aufnahme und die Bearbeitung von Tests und das
Debbuging des Frontends der Applikation. Die aufgenommenen Tests ermöglichen ein wiederholtes und automatisiertes Testen.

Nachfolgend finden Sie die Webseite des Selenium IDE Projekts.
http://seleniumhq.org/projects/ide/

===== Webtest als Testwerkzeug

Nachfolgend finden Sie die Webseite von Webtest.
http://webtest.canoo.com/

===== Lasttests mit ab & siege

Unter einem Lasttest versteht man einen Test, der ein Softwaresystem systematisch
unter Belastung stellt, um zu beobachten, wie sich das System verhält.
Insbesondere dienen Lasttests dazu, sicherzustellen, dass ein System
unter künstlichem Stress stabil und performant läuft.

.Das Lasttestwerkzeug Apache Benchmark "ab"

Das Lasttestwerkzeug Apache Benchmark (genannt "ab") ruft eine Webseite auf einem Webserver mehrfach ab und
berechnet aus den Wartezeiten den Mittelwert.

Webseite: http://httpd.apache.org/docs/2.0/programs/ab.html

.Das Lasttestwerkzeug "siege"

Webseite: http://www.joedog.org/index/siege-home