////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://docs.clansuite.com/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 9 - Die Fehlersuche und das Testen

Das Kapitel gliedert sich in zwei thematisch zusammenhängende Teile.
Der erste Abschnitt beschäftigt sich mit Methoden und Werkzeugen der Fehlersuche (engl. debugging) in Clansuite.
Bei der Fehlersuche geht es darum, den Ursprung eines Fehlers in der Software zu finden und zu beheben.
Der zweite Abschnitt beschäftigt sich mit einer speziellen Form der Fehlervorbeugung, dem Testen.
Beim Testen geht es darum, Fehler zu finden und es gar erst zu einem Fehler kommen zu lassen.

=== Methoden und Werkzeuge zur Fehlersuche

Clansuite stellt eine Reihe von Debugging Tools zur Verfügung, die dem Entwickler einen Einblick in einen
Problembereich eröffnen und somit beim Lösen von Fehlern und Entwickeln zur Seite stehen. Grundsätzlich kann
man die Aufgabe von Debugging Tools beschreiben, als das Bereitstellen von zusätzlichen Informationen, die bei
normaler Nutzung der Anwendung nicht eingesehen werden können. Sie erweitern also den Wahrnehmungsbereich des
Entwicklers. Die Erweiterung des Wahrnehmungsbereichs ist ebenfalls ein wichtiger Punkt im Bereich des Fehler-
und Exceptionshandlings. Eine abgeschaltete oder unterdrückte Fehlerbehandlung, bewirkt dass sich so mancher
Fehler unterhalb der Wahrnehmungsgrenze für den Entwickler bewegt. Für beide Bereiche gilt, dass sie jeweils
nur im Entwicklungsmodus eines Systems verfügbar sein sollten, da sie ansonsten Tür und Tor für eine
unbestimmte Vielzahl von Angriffen eröffnen.

Dies führt zur Feststellung das das Fehlerhandling teilweise automatisiert ist und teilweise durch den 
Entwickler gesteuert werden kann. So wird PHP automatisch einen Fehler werfen, wenn sie eine 
Syntaxregel misachten. Das Exceptionhandling und der Einsatz von Debugging-Befehlen sind
hingegen vollständig vom Entwickler steuerbar.

Die Problembereiche können dabei an mannigfaltigen Stellen auftreten, so z. B. im Bereich des
Zuweisungsgehalts einer Variablen oder einer Konstante oder bei komplexen mehrdimensionalen Arraystrukturen.
Man sollte meinen das eine Skript- bzw. Programmiersprache wie PHP5, die speziell als Sprache entwickelt
wurde, um Webanwendungen zu erstellen, ein funktional ausreichendes Angebot an Debuggingwerkzeugen
bereitstellt. Doch leider ist dies nicht der Fall. PHP bietet keine integrierten Debugging Werkzeuge. Das
Angebot im Bereich der Fehleranalyse ist spärlich und meiner Ansicht nach sträflich vernachlässigt worden.
Dies gilt sowohl für den Bereich des Highlevel-, wie auch des Lowlevel-Debuggings. Mit Highlevel-Debugging
bezeichne ich die Verwendung von PHP Umgebungserweiterungen, die einen tieferen Einblick in die Vorgänge des
Systems ermöglichen. Zu diesen Highlevel-Tools gehört Beispielseweise das Debugger-Projekt "xdebug". Mit
Lowlevel-Debugging meine ich PHP Syntaxelemente, die es ermöglichen auf einfache Art und Weise
eine Fehleranalyse durchzuführen.

==== Einfache Debugging-Elemente des PHP Syntax

Als einfache Elemente des PHP Syntax, die sich zum Debuggen eignen, kommen die folgenden Funktionen in Betracht.
Grundsätzlich sind den Ausgabefunktionen echo, print, print_r, var_export, var_dump sind die Abbruchfunktionen exit und die relevant.

Verwenden Sie bitte "var_dump();" anstelle von "print_r();", um den Inhalt einer Variablen zu prüfen.
Hilfreich ist oft auch "var_export();". Sollte eine bestimmte Stelle in der Applikation zu debuggen sein,
kann wahlweise mit einem anschießenden "exit();" oder einem "die();" der Applikationslauf gestoppt werden.

==== Erweitertes Debugging mit dem Clansuite_Logger

==== Erweitertes Debugging mit der FirePHP Debugkonsole

FirePHP ist eine Erweiterung für FireBug. Beides sind Addons für Firefox. Die Funktionsweise von FirePHP ist
trivial. Die anzuzeigenden Daten werden einer PHP Methode übergeben. Diese setzt sie in den Antwortheader (X-
FirePHP-Data). Dort werden sie von der FirePHP Erweiterung ausgelesen und in der FireBug-Konsole dargestellt.
Auf diese Art und Weise vermischt sich der Debugoutput nicht mit dem eigentlichen Seiteninhalt.

[source, txt]
---------------------------------------------------------------------
Das Firefox Addon FireBug erhalten sie unter
https://addons.mozilla.org/en-US/firefox/addon/1843

Das Firefox Addon FirePHP erhalten sie unter
https://addons.mozilla.org/en-US/firefox/addon/6149
---------------------------------------------------------------------

Methode 1 - Direkte Verwendung der FirePHP Klasse

[source, php]
---------------------------------------------------------------------
# Laden der FirePHP Klasse
require ROOT_LIBRARIES.'firephp/FirePHP.class.php');
# Instanzierung über Singleton
$firephp = FirePHP::getInstance(true);

# Loggen in die Konsole
$firephp->log('Hello World');
$firephp->dump('Key', 'Value');
$firephp->fb('Schreiben in die Konsole');
---------------------------------------------------------------------

Methode 2 - Indirekte Verwendung über die Methode Clansuite_Xdebug::firebug()

Wenn Sie Clansuite_Debug verwenden, dann können Sie sich die Zeilen zur Initalisierung von FirePHP sparen,
denn die statische Methode Clansuite_Debug::firebug() erledigt dies für Sie. Die Methode übergibt der Konsole
ebenfalls den Ort an dem sie eingesetzt wird. Dies erleichtert das Wiederfinden der Debugging-Position im Quellcode.

[source, php]
---------------------------------------------------------------------
# Gibt den Inhalt von $variable in der FireBug Konsole aus und verwendet dabei das Kommando log().
Clansuite_Debug::firebug($variable);

# Folgende String-Werte sind als zweiter Parameter verwendbar: info, log, warn, error.
# Gibt den Inhalt von $variable in der FireBug Konsole aus und verwendet dabei das Kommando error().
Clansuite_Debug::firebug($variable, 'error');
---------------------------------------------------------------------

TIP: Setzen Sie Codevervollständigung ein, um dieses oft benötigte Kommando nicht ständig tippen zu müssen.
Ich schlage Ihnen die Verwendung der Zeichenkette "fbg" für den Textschnippsel "Clansuite_Debug::firebug($variable);"
vor. So brauchen Sie nur noch den Variablennamen ersetzen und sparen sich Zeit und Tipparbeit. 

==== Clansuite_Debug und Clansuite_Xdebug

Mich hat das Funktionsangebot von PHP im Bereich des Debugging nicht zufrieden gestellt. Clansuite setzt daher
eine eigene Debugging Klasse ein, um die Programmierung des Systems einfacher und komfortabler zu gestalten.
Es gibt die Klasse Clansuite_Debug, welche verschiedene Hilfsfunktionen, wir printR()und firebug() bereitstellt.
Desweiteren gibt es die Klasse Clansuite_Xdebug. Sie stellt Start und Stop Methoden bereit, um mit dem Debugger
"Xdebug" zu interagieren. Diese Methoden setzen also eine installierte PHP Erweiterung "Xdebug" voraus.
Grundsätzlich empfehle ich für das Debugging XDebug. Als Highlevel-Debugging Extension verschafft Xdebug,
im Gegensatz zur normalen Debugging-Anzeige, eine Steigerung der Übersichtlichkeit bei Fehler- und Debugdumps
durch verbesserte Darstellung der Debuginformationen. Mit Xdebug lassen sich sehr einfach Funktionsaufrufe
nachverfolgen, Abhängigkeiten erkennen und die Laufzeit von Codeabschnitten ermittlen.

Hint: Den Debug-Modus können sie aktivieren, indem sie in der Konfiguration (/configuration/clansuite.config.php)
die Einstellung [error] debug = 1 setzen. Für den XDebug-Modus setzen sie [error] xdebug = 1.

===== Die Methode Clansuite_Debug::printR()

Wenn Sie den Debug-Modus des Systems aktiviert haben, ist zusätzlich der Befehl "Clansuite_Debug::printR($assoc_array);"
verfügbar. Der Befehlt hat drei Vorteile. Erstens verbessert er die Anzeige von Variablen und assoziativen
Arrays. Diese werden übersichtlich aufbereitet und farblich hervorgehoben. Zweitens zeigt er den genauen Ort
seiner Verwendung an. Somit ist ein schnelles Wiederfinden des Debug-Statements innerhalb des Quellcodes
gewährleistet. Dies ist insbesondere dann hilfreich, wenn sie mehrere Debug-Statements einsetzen. Drittens
wird die Applikation an dieser Stelle automatisch gestoppt. Ein Nachschieben der Anweisungen exit; oder die;
entfällt. Die Verwendung ist trivial und analog zum PHP-Kommando print_r().

==== Konfigurationseinstellungen für das Debugging

Weitere hilfreiche Debugging Einstellungen sind:

[source, php]
---------------------------------------------------------------------
[error]
suppress_errors = 0
debug = 1
xdebug = 1
debug_popup = 0

[switches]
phpdebug = 1
---------------------------------------------------------------------

[source, php]
---------------------------------------------------------------------
# Verwendung der statischen Methode printR() der Klasse Clansuite_Debug
Clansuite_Debug::printR($data);

# Verwendung der statischen Methode xd_varDump() der Klasse Clansuite_Xdebug
Clansuite_Xdebug::xd_varDump($data);
---------------------------------------------------------------------

==== Debugging im Bereich der Präsentationsschicht

Für die Fehleranalyse im Bereich der Präsentationsschicht stehen eigene Kommandos zur Verfügung.

Verwendet man Smarty als RenderEngine, dann eignen sich die folgenden drei, die Variablenausgabe modifizierenden Smarty Befehle
(Smarty Modifiers), um den Inhalt einer Variable oder eines Arrays angezeigt zu bekommen.

[source, php]
---------------------------------------------------------------------
# Zeigt ein strukturiertes Array innerhalb des Templates.
{$array|@var_dump}

# Die Ausgabe mit dem Modifier @dump zeigt ein strukturiertes Array in einer Box innerhalb des Templates.
{$array|@dump}

# Der Modifer @dump kann auch auf mehrdimentsionale Arrays und deren Schlüssel angewandt werden.
{$array.subarray|@dump:schlüssel}

/**
 * Zeigt nur das Array an.
 * Die restlichen Ausgaben werden unterdrückt und das Programm zu Debbuging-Zwecken abgebrochen.
 */
{$array|@debug}
---------------------------------------------------------------------

==== Profiling

===== Profiling mit XDebug

===== Profiling mit XHProf

XHProf wurde ursprünglich als Profiler für Facebook entwickelt.
Es ist ein hierarchischer Profiler der Wall Time von Funktionen, dem Speicherverbrauch oder auch der Anzahl der Calls pro Funktion.

PECL Projekt Webseite: http://pecl.php.net/package/xhprof
Webseite: http://mirror.facebook.net/facebook/xhprof/

=== Das Testen

==== Warum eine Testsuite?

Wer vorher testet, muss später weniger Fehler beheben. Das Ziel des Testens ist Fehler zu entdecken.

Glenford J. Myers definiert das Testen wie folgt:
"Testen ist der Prozeß, ein Programm mit der Absicht auszuführen, Fehler zu finden.".
footnote:[Glenford J. Myers, Methodisches Testen von Programmen, 1995, Oldenburg Verlag]

==== Was ist eine Testsuite?

Die Testsuite ist eine Sammlung von Funktionsüberprüfungen. Diese Sammlung wird mittels eines Test-Werkzeugs
durchlaufen. Eine Funktionsüberprüfung besteht immer aus zwei Teilen, der Funktionsbeschreibungen und dem
Aufruf der entsprechenden Funktion der Applikation. Der Bericht nach einer Funktionsüberprüfung, das
sogenannte Testprotokoll, gibt Auskunft darüber, ob Clansuite die vom Test gewünschte Funktionen ordnungsgemäß
bereitstellt. Der zusammenfassende Bericht gibt nach Durchlaufen aller Funktionsüberprüfungen Auskunft über
alle identifizierten Fehlfunktionen. Man nennt ihn Testabdeckungsbericht (engl. Coverage-Report).
Die Suche nach den Defekten und die Analyse der Fehlfunktionen gehört nicht in den Bereich des Testens.

.Negative Todo-Liste

Man kann Tests als negative Aufgaben- bzw. Todoliste verstehen und auch so einsetzen. Dabei schreibt man
zuerst den Test, definiert also was von Clansuite erwartet wird und welche Funktion von Clansuite erfüllt
werden soll. Lässt man den Test nun laufen, bekommt man logischerweise einen negativen Bericht für diesen
Test. Er wurde nicht erfolgreich durchlaufen. Nun schreibt man die eigentliche Funktion für Clansuite. Lässt
man den Test erneut laufen, wird er erfolgreich durchlaufen und man kann sicher sein, dass dieses Feature
funktioniert. Bei diesem Verfahren spricht man von "Test getriebener Entwicklung" (engl. Test-Driven-Development,
abgekürzt auch TDD).

===== Testabdeckungsbericht (Code-Coverage Report)

Der Code-Coverage Bericht gibt Aufschlüss über den Grad an Testabdeckung.
Von diesem Report werden bestimmte Bestandteile von Clansuite ausgeschlossen.

a) Tests - Tests werden nicht getestet.
b) Templates - In Templates werden nur Variablen eingesetzt.
c) Fremde Bibliotheken, Komponenten und Drittanbieter (3th party) Code - Wir sind nicht für die Tests zuständig.

===== Simpletest als Testwerkzeug

Wir verwenden Simpletest für automatisierte Tests gegen den Clansuite Core und Module.
Die Tests befinden bei der Entwicklerversion im Verzeichnis "/tests".
Dieser Ordner wird jedoch bei Neubildung von Clansuite entfernt.
Um alle Tests auszuführen, ruft man "/tests/runAllTests.php" auf.

Nachfolgend finden Sie die Webseite des Simpletest Projekts:
http://sourceforge.net/projects/simpletest/
https://sourceforge.net/project/showfiles.php?group_id=76550

===== Selenium als Testwerkzeug

Wir verwenden die Firefox Erweiterung "Selenium IDE" für die Aufnahme und die Bearbeitung von Tests und das
Debbuging der Applikation. Die aufgenommenen Tests ermöglichen ein wiederholtes und automatisiertes Testen.

Nachfolgend finden Sie die Webseite des Selenium IDE Projekts.
http://seleniumhq.org/projects/ide/

===== Webtest als Testwerkzeug

Nachfolgend finden Sie die Webseite von Webtest.
http://webtest.canoo.com/

===== Lasttests mit ab & siege

Unter einem Lasttest versteht man einen Test, der ein Softwaresystem systematisch
unter Belastung stellt, um zu beobachten, wie sich das System verhält.
Insbesondere dienen Lasttests dazu, sicherzustellen, dass ein System
unter künstlichem Stress stabil und performant läuft.

.Das Lasttestwerkzeug Apache Benchmark "ab"

Das Lasttestwerkzeug Apache Benchmark (genannt "ab") ruft eine Webseite auf einem Webserver mehrfach ab und
berechnet aus den Wartezeiten den Mittelwert.

Webseite: http://httpd.apache.org/docs/2.0/programs/ab.html

.Das Lasttestwerkzeug "siege"

Webseite: http://www.joedog.org/index/siege-home