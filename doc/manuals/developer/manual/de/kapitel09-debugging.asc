////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://docs.clansuite.com/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 9 - Die Fehlersuche und das Testen

Das Kapitel gliedert sich in zwei thematisch zusammenhängende Teile.
Der erste Abschnitt beschäftigt sich mit Methoden und Werkzeugen der Fehlersuche (engl. debugging) in Clansuite.
Bei der Fehlersuche geht es darum, den Ursprung eines Fehlers in der Software zu finden und zu beheben.
Der zweite Abschnitt beschäftigt sich mit einer speziellen Form der Fehlervorbeugung, dem Testen.
Beim Testen geht es darum, Fehler zu finden und es gar erst zu einem Fehler kommen zu lassen.

=== Methoden und Werkzeuge zur Fehlersuche

Clansuite stellt eine Reihe von Debugging Tools zur Verfügung, die dem Entwickler einen Einblick in einen
Problembereich eröffnen und somit beim Lösen von Fehlern und Entwickeln zur Seite stehen. Grundsätzlich kann
man die Aufgabe von Debugging Tools beschreiben, als das Bereitstellen von zusätzlichen Informationen, die bei
normaler Nutzung der Anwendung nicht eingesehen werden können. Sie erweitern also den Wahrnehmungsbereich des
Entwicklers. Die Erweiterung des Wahrnehmungsbereichs ist ebenfalls ein wichtiger Punkt im Bereich des Fehler-
und Exceptionshandlings. Eine abgeschaltete oder unterdrückte Fehlerbehandlung, bewirkt dass sich so mancher
Fehler unterhalb der Wahrnehmungsgrenze für den Entwickler bewegt. Für beide Bereiche gilt, dass sie jeweils
nur im Entwicklungsmodus eines Systems verfügbar sein sollten, da sie ansonsten Tür und Tor für eine
unbestimmte Vielzahl von Angriffen eröffnen.

Dies führt zur Feststellung das das Fehlerhandling teilweise automatisiert ist und teilweise durch den 
Entwickler gesteuert werden kann. So wird PHP automatisch einen Fehler werfen, wenn sie eine 
Syntaxregel misachten. Das Exceptionhandling und der Einsatz von Debugging-Befehlen sind
hingegen vollständig vom Entwickler steuerbar.

Die Problembereiche können dabei an mannigfaltigen Stellen auftreten, so z. B. im Bereich des
Zuweisungsgehalts einer Variablen oder einer Konstante oder bei komplexen mehrdimensionalen Arraystrukturen.
Man sollte meinen das eine Skript- bzw. Programmiersprache wie PHP5, die speziell als Sprache entwickelt
wurde, um Webanwendungen zu erstellen, ein funktional ausreichendes Angebot an Debuggingwerkzeugen
bereitstellt. Doch leider ist dies nicht der Fall. PHP bietet keine integrierten Debugging Werkzeuge. Das
Angebot im Bereich der Fehleranalyse ist spärlich und meiner Ansicht nach sträflich vernachlässigt worden.
Dies gilt sowohl für den Bereich des Highlevel-, wie auch des Lowlevel-Debuggings. Mit Highlevel-Debugging
bezeichne ich die Verwendung von PHP Umgebungserweiterungen, die einen tieferen Einblick in die Vorgänge des
Systems ermöglichen. Zu diesen Highlevel-Tools gehört Beispielseweise das Debugger-Projekt "xdebug". Mit
Lowlevel-Debugging meine ich PHP Syntaxelemente, die es ermöglichen auf einfache Art und Weise
eine Fehleranalyse durchzuführen.

==== Einfache Debugging-Elemente des PHP Syntax

Als einfache Elemente des PHP Syntax, die sich zum Debuggen eignen, kommen die folgenden Funktionen in Betracht.
Grundsätzlich sind den Ausgabefunktionen echo, print, print_r, var_export, var_dump sind die Abbruchfunktionen exit und die relevant.

Verwenden Sie bitte "var_dump();" anstelle von "print_r();", um den Inhalt einer Variablen zu prüfen.
Hilfreich ist oft auch "var_export();". Sollte eine bestimmte Stelle in der Applikation zu debuggen sein,
kann wahlweise mit einem anschießenden "exit();" oder einem "die();" der Applikationslauf gestoppt werden.

==== Erweitertes Debugging mit dem Clansuite_Logger

==== Erweitertes Debugging mit der FirePHP Debugkonsole

FirePHP ist eine Erweiterung für FireBug. Beides sind Addons für Firefox. Die Funktionsweise von FirePHP ist
trivial. Die anzuzeigenden Daten werden einer PHP Methode übergeben. Diese setzt sie in den Antwortheader (X-
FirePHP-Data). Dort werden sie von der FirePHP Erweiterung ausgelesen und in der FireBug-Konsole dargestellt.
Auf diese Art und Weise vermischt sich der Debugoutput nicht mit dem eigentlichen Seiteninhalt.

[source, txt]
---------------------------------------------------------------------
Das Firefox Addon FireBug erhalten sie unter
https://addons.mozilla.org/en-US/firefox/addon/1843

Das Firefox Addon FirePHP erhalten sie unter
https://addons.mozilla.org/en-US/firefox/addon/6149
---------------------------------------------------------------------

Methode 1 - Direkte Verwendung der FirePHP Klasse

[source, php]
---------------------------------------------------------------------
# Laden der FirePHP Klasse
require ROOT_LIBRARIES.'firephp/FirePHP.class.php');
# Instanzierung über Singleton
$firephp = FirePHP::getInstance(true);

# Loggen in die Konsole
$firephp->log('Hello World');
$firephp->dump('Key', 'Value');
$firephp->fb('Schreiben in die Konsole');
---------------------------------------------------------------------

Methode 2 - Indirekte Verwendung über die Methode Clansuite_Xdebug::firebug()

Wenn Sie Clansuite_Debug verwenden, dann können Sie sich die Zeilen zur Initalisierung von FirePHP sparen,
denn die statische Methode Clansuite_Debug::firebug() erledigt dies für Sie. Die Methode übergibt der Konsole
ebenfalls den Ort an dem sie eingesetzt wird. Dies erleichtert das Wiederfinden der Debugging-Position im Quellcode.

[source, php]
---------------------------------------------------------------------
# Gibt den Inhalt von $variable in der FireBug Konsole aus und verwendet dabei das Kommando log().
Clansuite_Debug::firebug($variable);

# Folgende String-Werte sind als zweiter Parameter verwendbar: info, log, warn, error.
# Gibt den Inhalt von $variable in der FireBug Konsole aus und verwendet dabei das Kommando error().
Clansuite_Debug::firebug($variable, 'error');
---------------------------------------------------------------------

TIP: Setzen Sie Codevervollständigung ein, um dieses oft benötigte Kommando nicht ständig tippen zu müssen.
Ich schlage Ihnen die Verwendung der Zeichenkette "fbg" für den Textschnippsel "Clansuite_Debug::firebug($variable);"
vor. So brauchen Sie nur noch den Variablennamen ersetzen und sparen sich Zeit und Tipparbeit. 

==== Clansuite_Debug und Clansuite_Xdebug

Mich hat das Funktionsangebot von PHP im Bereich des Debugging nicht zufrieden gestellt. Clansuite setzt daher
eine eigene Debugging Klasse ein, um die Programmierung des Systems einfacher und komfortabler zu gestalten.
Es gibt die Klasse Clansuite_Debug, welche verschiedene Hilfsfunktionen, wir printR()und firebug() bereitstellt.
Desweiteren gibt es die Klasse Clansuite_Xdebug. Sie stellt Start und Stop Methoden bereit, um mit dem Debugger
"Xdebug" zu interagieren. Diese Methoden setzen also eine installierte PHP Erweiterung "Xdebug" voraus.
Grundsätzlich empfehle ich für das Debugging XDebug. Als Highlevel-Debugging Extension verschafft Xdebug,
im Gegensatz zur normalen Debugging-Anzeige, eine Steigerung der Übersichtlichkeit bei Fehler- und Debugdumps
durch verbesserte Darstellung der Debuginformationen. Mit Xdebug lassen sich sehr einfach Funktionsaufrufe
nachverfolgen, Abhängigkeiten erkennen und die Laufzeit von Codeabschnitten ermittlen.

Hint: Den Debug-Modus können sie aktivieren, indem sie in der Konfiguration (/configuration/clansuite.config.php)
die Einstellung [error] debug = 1 setzen. Für den XDebug-Modus setzen sie [error] xdebug = 1.

===== Die Methode Clansuite_Debug::printR()

Wenn Sie den Debug-Modus des Systems aktiviert haben, ist zusätzlich der Befehl "Clansuite_Debug::printR($assoc_array);"
verfügbar. Der Befehlt hat drei Vorteile. Erstens verbessert er die Anzeige von Variablen und assoziativen
Arrays. Diese werden übersichtlich aufbereitet und farblich hervorgehoben. Zweitens zeigt er den genauen Ort
seiner Verwendung an. Somit ist ein schnelles Wiederfinden des Debug-Statements innerhalb des Quellcodes
gewährleistet. Dies ist insbesondere dann hilfreich, wenn sie mehrere Debug-Statements einsetzen. Drittens
wird die Applikation an dieser Stelle automatisch gestoppt. Ein Nachschieben der Anweisungen exit; oder die;
entfällt. Die Verwendung ist trivial und analog zum PHP-Kommando print_r().

==== Konfigurationseinstellungen für das Debugging

Weitere hilfreiche Debugging Einstellungen sind:

[source, php]
---------------------------------------------------------------------
[error]
suppress_errors = 0
debug = 1
xdebug = 1
debug_popup = 0

[switches]
phpdebug = 1
---------------------------------------------------------------------

[source, php]
---------------------------------------------------------------------
# Verwendung der statischen Methode printR() der Klasse Clansuite_Debug
Clansuite_Debug::printR($data);

# Verwendung der statischen Methode xd_varDump() der Klasse Clansuite_Xdebug
Clansuite_Xdebug::xd_varDump($data);
---------------------------------------------------------------------

==== Debugging im Bereich der Präsentationsschicht

Für die Fehleranalyse im Bereich der Präsentationsschicht stehen eigene Kommandos zur Verfügung.

Verwendet man Smarty als RenderEngine, dann eignen sich die folgenden drei, die Variablenausgabe modifizierenden Smarty Befehle
(Smarty Modifiers), um den Inhalt einer Variable oder eines Arrays angezeigt zu bekommen.

[source, php]
---------------------------------------------------------------------
# Zeigt ein strukturiertes Array innerhalb des Templates.
{$array|@var_dump}

# Die Ausgabe mit dem Modifier @dump zeigt ein strukturiertes Array in einer Box innerhalb des Templates.
{$array|@dump}

# Der Modifer @dump kann auch auf mehrdimentsionale Arrays und deren Schlüssel angewandt werden.
{$array.subarray|@dump:schlüssel}

/**
 * Zeigt nur das Array an.
 * Die restlichen Ausgaben werden unterdrückt und das Programm zu Debbuging-Zwecken abgebrochen.
 */
{$array|@debug}
---------------------------------------------------------------------

==== Profiling

===== Profiling mit XDebug

===== Profiling mit XHProf

XHProf wurde ursprünglich als Profiler für Facebook entwickelt.
Es ist ein hierarchischer Profiler der Wall Time von Funktionen, dem Speicherverbrauch oder auch der Anzahl der Calls pro Funktion.

PECL Projekt Webseite: http://pecl.php.net/package/xhprof
Webseite: http://mirror.facebook.net/facebook/xhprof/

=== Das Testen

==== Warum eine Testsuite?

Wer vorher testet, muss später weniger Fehler beheben. Das Ziel des Testens ist Fehler zu entdecken.

Glenford J. Myers definiert das Testen wie folgt:
"Testen ist der Prozeß, ein Programm mit der Absicht auszuführen, Fehler zu finden.".
footnote:[Glenford J. Myers, Methodisches Testen von Programmen, 1995, Oldenburg Verlag]

==== Was ist eine Testsuite?

Eine Testsuite ist eine Sammlung von mehreren Tests. Diese Sammlung wird mittels eines Test-Werkzeugs
durchlaufen. Ein Test ist eine Funktionsüberprüfungen. Die Funktionsüberprüfung besteht immer aus zwei Teilen,
der Funktionsbeschreibungen und dem Aufruf der entsprechenden Funktion der Applikation.
Ein Test ist also ein Beispiel dafür, wie sich der Quellcode (später) verhalten soll.
Der Bericht nach einer Funktionsüberprüfung, das sogenannte Testprotokoll, gibt Auskunft darüber,
ob Clansuite die vom Test gewünschte Funktionen ordnungsgemäß bereitstellt.
Der zusammenfassende Bericht gibt nach Durchlaufen aller Funktionsüberprüfungen Auskunft über
alle identifizierten Fehlfunktionen. Man nennt ihn Testabdeckungsbericht (engl. Coverage-Report).
Die Suche nach den Defekten und die Analyse der Fehlfunktionen gehört nicht in den Bereich des Testens.

.Test-getriebene Entwicklung bzw. Negative Todo-Liste

Man kann Tests als negative Aufgaben- bzw. Todoliste verstehen und auch so einsetzen.
Dabei schreibt man zuerst den Test, definiert also was von Clansuite erwartet wird und welche Funktion von Clansuite erfüllt
werden soll. Lässt man den Test nun laufen, bekommt man logischerweise einen negativen Bericht für diesen
Test. Er wurde nicht erfolgreich durchlaufen. Nun schreibt man die eigentliche Funktion für Clansuite. Lässt
man den Test erneut laufen, wird er erfolgreich durchlaufen und man kann sicher sein, dass dieses Feature
funktioniert. Bei diesem Verfahren spricht man von "Test getriebener Entwicklung" (engl. Test-Driven-Development,
abgekürzt auch TDD). 

Das Verfahren lässt sich in die drei typische TDD-Schritte aufteilen:
1. Einen neuen Test schreiben [Neues Feature / Neue Funktion wird beschrieben]
2. Den Test scheitern lassen [Failure]
3. Code schreiben, bis Test erfüllt ist [OK]

Um einen Bug, also einen Programmfehler, mittels TDD-Verfahren zu beseitigen, kann man folgendermaßen vorgehen:
1. Einen neuen Test schreiben, der den Bug entlarvt [Fehler wird beschrieben]
2. Der Test scheitert, weil der Bug existiert [Failure]
3. Bugfix-Code schreiben, bis der Test erfüllt und der Bug gefixt ist [OK]
Man spricht von "Test getriebenen Bugfixing".

.Vorteile Test-getriebener Entwicklung
Die Test schaffen Sicherheit darüber, dass der Code auch tatsächlich das tut, was in der Funktionsprüfung beschrieben wurde.
Beim Implementieren des Code wird der Entwickler durch die Tests geführt.
Dabei wird keine Zeile Code geschrieben, die nicht tatsächlich gebraucht wurde.
Der geschriebene Code ist in der Zukunft leicht änderbar und man wird durch Tests darauf hingewiesen, 
wenn etwas kaputt gemacht wurde. So lassen sich beispielsweise Regressionsfehler in den Griff bekommen.

.Nachteile
a) Überblick wahren
Es ist grunsätzlich sehr schwierig die Übersicht über die Tests zu behalten.
Schnell sind für eine kleine Applikation sehr viele Tests angelegt.
Allerdings ist die Wahrung der Zuordung von Test zu Programmcode sehr wichtig.
Daher ist eine systematische und kontextabhängige Ablage und Ordnung der Tests im Dateisystem 
zu empfehlen. Beispielsweise können Tests nach Klassen und Funktionen sortiert abgelegt werden.
Jeder Test sollte zudem im Dokumentationsblock einen natürlich-sprachlicher Kommentar
enthalten, der Aufschluss über die Absicht des Tests gibt.
Damit kann auch nach längerer Zeit und mehreren beteiligten Entwicklern die Frage beantwortet werden, 
warum der Test existiert.

b) Tests erstellen, die die Datenbank verwenden
Das Arbeiten mit einer Datenbank und Tests kann sich am Anfang recht schwierig gestalten.
Die Lösung ist das Einrichten einer gleichbleibenden Testumgebung, welche die Datenbank 
vor den auszuführenden Tests initialisiert. Dazu wird vor jedem Test ein Script aufgerufen,
dass die Datenbank klont, ohne aber Daten zu übernehmen. 
Für die Dauer des/der Tests wird so eine reine Testdatenbank eingesetzt.
Grundsätzlich werden bei diesem Verfahren also mehrere Datenbanken eingesetzt.

c) Testszenario entwerfen
Es ist wichtig mit Daten zu arbeiten, die nah an der Realität sind.
Grundsätzlich neigen Programmierer dazu, lediglich Testdaten im Stil von
"Blabla123" oder "Test123". Testdaten sind jedoch Daten, die real aussehen.
Nach Möglichkeit kann für die Generierung von Testdaten auf Hilfswerkzeuge,
wie z.B. die Beispieldaten-Bibliotheken "Faker" zurückgegriffen werden.

d) Stubs
Stubs ersetzen Objekte oder Methoden für den Zeitraum des Tests durch Test-Dummys.
So lassen isch beispielsweise Schnittstellenaufrufe  bzw. API Aufrufe von 
Onlinediensten (PayPal, GoogleMaps) "ersetzen". Der Code wird für den Moment des Tests 
von externen Abhängigkeiten, Nebenwirkungen und langwierigen Abläufen (Verbindung zum Onlineservice)
befreit werden.

e) Mocks
Mocks ersetzen Objekte oder Methoden für den Zeitraum des Tests durch Test-Dummys.
Damit kann getestet werden, ob Methoden wie erwartet aufgerufen wurden und, ob die Kommunikation
mit externen Abhängigkeiten tatsächlich reibungslos funktioniert, ohne den Ablauf tatsächlich zu starten.

f) Benutzeroberfläche testen / Frontendtests
Für das Testen der Benutzeroberfläche muss sich der Test wie ein User verhalten und sich durch die Webanwendung clicken.
Die Benutzeroberfläche ist aber nicht dafür erstellt worden, um von einer Maschine getestet zu 
werden. Daher gestaltet sich dieser Vorang relativ kompliziert. Die Testumgebung muss sich auf HTTP-Aufrufe, HTML-Quelltext, 
Umgang mit Formularen und die Auswertung von Cookies verstehen.
Um diesen Vorgang zu automatisieren stehen Werkzeuge wie "Selenium", "Webrat" oder "Cucumber" bereit.
Dabei werden die Benutzerschritte aufgezeichnet und sind später automatisiert und als Test abspielbar.

===== Testabdeckungsbericht (Code-Coverage Report)

Der Code-Coverage Bericht gibt Aufschlüss über den Grad an Testabdeckung.
Von diesem Report werden bestimmte Bestandteile von Clansuite ausgeschlossen.

a) Tests - Tests werden nicht getestet.
b) Templates - In Templates werden nur Variablen eingesetzt.
c) Fremde Bibliotheken, Komponenten und Drittanbieter (3th party) Code - Wir sind nicht für die Tests zuständig.

===== Simpletest als Testwerkzeug

Wir verwenden Simpletest für automatisierte Tests gegen den Clansuite Core und Module.
Die Tests befinden bei der Entwicklerversion im Verzeichnis "/tests".
Dieser Ordner wird jedoch bei Neubildung von Clansuite entfernt.
Um alle Tests auszuführen, ruft man "/tests/runAllTests.php" auf.

Nachfolgend finden Sie die Webseite des Simpletest Projekts:
http://sourceforge.net/projects/simpletest/
https://sourceforge.net/project/showfiles.php?group_id=76550

===== Selenium als Testwerkzeug

Wir verwenden die Firefox Erweiterung "Selenium IDE" für die Aufnahme und die Bearbeitung von Tests und das
Debbuging der Applikation. Die aufgenommenen Tests ermöglichen ein wiederholtes und automatisiertes Testen.

Nachfolgend finden Sie die Webseite des Selenium IDE Projekts.
http://seleniumhq.org/projects/ide/

===== Webtest als Testwerkzeug

Nachfolgend finden Sie die Webseite von Webtest.
http://webtest.canoo.com/

===== Lasttests mit ab & siege

Unter einem Lasttest versteht man einen Test, der ein Softwaresystem systematisch
unter Belastung stellt, um zu beobachten, wie sich das System verhält.
Insbesondere dienen Lasttests dazu, sicherzustellen, dass ein System
unter künstlichem Stress stabil und performant läuft.

.Das Lasttestwerkzeug Apache Benchmark "ab"

Das Lasttestwerkzeug Apache Benchmark (genannt "ab") ruft eine Webseite auf einem Webserver mehrfach ab und
berechnet aus den Wartezeiten den Mittelwert.

Webseite: http://httpd.apache.org/docs/2.0/programs/ab.html

.Das Lasttestwerkzeug "siege"

Webseite: http://www.joedog.org/index/siege-home