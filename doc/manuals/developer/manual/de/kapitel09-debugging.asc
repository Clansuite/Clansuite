////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 10 - Das Debugging und das Error- und Exceptionhandling

=== Debugging

Clansuite stellt eine Reihe von Debbuging Tools zur Verfügung, die dem Entwickler einen Einblick in einen
Problembereich eröffnen und somit beim lösen von Fehlern und entwickeln zur Seite stehen. Grundsätzlich kann
man die Aufgabe von Debugging Tools beschreiben, als das Bereitstellen von zusätzlichen Informationen, die bei
normaler Nutzung der Anwendung nicht eingesehen werden können. Sie erweitern also den Wahrnehmungsbereich des
Entwicklers. Die Erweiterung des Wahrnehmungsbereichs ist ebenfalls ein wichtiger Punkt im Bereich des Fehler-
und Exceptionshandlings. Ein abgeschaltete oder unterdrückte Fehlerbehandlung, bewirkt dass sich so mancher
Fehler unterhalb der Wahrnehmungsgrenze für den Entwickler bewegt. Für beide Bereiche gilt, dass sie jeweils
nur im Entwicklungsmodus eines Systems verfügbar sein sollten, da sie ansonsten Tür und Tor für eine
unbestimmte Vielzahl von Angriffen eröffnen.

Dies führt zur Feststellung das das Fehlerhandling teilweise automatisiert (durch die Sprache selbst erfolgt)
und teilweise durch den Entwickler gesteuert werden kann. Das Excpetionhandling und das Debugging sind
hingegen vollständig vom Entwickler steuerbar.

Die Problembereiche können dabei an mannigfaltigen Stellen auftreten, so z. B. im Bereich des
Zuweisungsgehalts einer Variablen oder einer Konstante oder bei komplexen mehrdimensionalen Arraystrukturen.
Man sollte meinen das eine Skript- bzw. Programmiersprache wie PHP5, die speziell als Sprache entwickelt
wurde, um Webanwendungen zu erstellen, ein funktional ausreichendes Angebot an Debuggingwerkzeugen
bereitstellt. Doch leider ist dies nicht der Fall. PHP bietet keine integrierten Debugging Werkzeuge. Das
Angebot im Bereich der Fehleranalyse ist spärlich und meiner Ansicht nach sträflich vernachlässigt worden.
Dies gilt sowohl für den Bereich des Highlevel-, wie auch des Lowlevel-Debuggings. Mit Highlevel-Debugging
bezeichne ich die Verwendung von PHP Umgebungserweiterungen, die einen tieferen Einblick in die Vorgänge des
Systems ermöglichen. Zu diesen Highlevel-Tools gehört Beispielseweise das Debugger-Projekt "xdebug".
Mit Lowlevel-Debugging meine ich PHP Syntaxelemente, die es ermöglichen auf einfache Art und Weise
eine Fehleranalyse durchzuführen.

==== Einfache Debugging-Elemente des PHP Syntax

Als einfache Elemente des PHP Syntax, die sich zum Debuggen eignen, kommen die folgenden Funktionen in Betracht.
Verwenden Sie bitte "var_dump();" anstelle von "print_r();", um den Inhalt einer Variablen zu prüfen.
Hilfreich ist oft auch "var_export;". Sollte eine bestimmte Stelle in der Applikation zu debuggen sein,
kann wahlweise mit einem anschießenden "exit();" der Applikationslauf gestoppt werden.
Ebenso steht "die();" zur Verfügung.

==== Clansuite_Xdebug

Mich das Funktionsangebot von PHP im Bereich des Debugging nicht zufrieden gestellt. Clansuite setzt daher
eine eigene Debugging Klasse ein, um die Programmierung des Systems einfacher und komfortabler zu gestalten.
Die Klasse Clansuite_Xdebug stellt Start und Stop Methoden bereit, um mit dem Debugger "Xdebug" zu
interagieren. Diese Methoden setzen also eine installierte PHP Erweiterung "Xdebug" voraus. Grundsätzlich wird
für das Debugging XDebug empfohlen. Als Highlevel-Debugging Extension verschafft Xdebug, im Gegensatz zur
normalen Debugging-Anzeige, eine Steigerung der Übersichtlichkeit bei Fehler- und Debugdumps durch verbesserte
Darstellung der Debuginformationen. Mit Xdebug lassen sich sehr einfach Funktionsaufrufe nachverfolgen,
Abhängigkeiten erkennen und die Laufzeit von Codeabschnitten ermittlen. Wenn Sie den XDebug-Modus des Systems
aktiviert haben, ist zusätzlich der Befehl "clansuite_xdebug::printR($assoc_array);" verfügbar. Der eine
nochmals verbesserte Anzeige von Variablen und assoziativen Arrays bereitstellt.
Die Verwendung ist trivial und analog zum PHP-Kommando print_r().

Hint: Den XDebug-Modus können sie aktivieren, indem sie in der Konfiguration (/configuration/clansuite.config.php)
die Einstellung [error] xdebug = 1 setzen.

==== Konfigurationseinstellungen für das Debugging

Weitere hilfreiche Debugging Einstellungen sind:
[error]
suppress_errors = 0
debug = 1
xdebug = 1
debug_popup = 0

[switches]
phpdebug = 1

[source, php]
---------------------------------------------------------------------
# Verwendung der statischen Methode printR() der Klasse clansuite_xdebug
clansuite_xdebug::printR($assoc_array);
---------------------------------------------------------------------

==== Debugging im Bereich der Präsentationsschicht

Für die Fehleranalyse im Bereich der Präsentationsschicht stehen eigene Kommandos zur Verfügung.

Verwendet man Smarty als RenderEngine, dann eignen sich die folgenden drei, die Variablenausgabe
modifizierende Smarty Befehle (Smarty Modifiers), um den Inhalt einer Variable oder eines Arrays angezeigt
zu bekommen:
1. {$array|@var_dump}
Zeigt ein strukturiertes Array innerhalb des Templates.
2. {$array|@dump}
Zeigt ein strukturiertes Array in einer Box innerhalb des Templates.
3. {$array|@debug}
Zeigt nur das Array an. Die restlichen Ausgaben werden unterdrückt und das Programm zu Debbuging-Zwecken abgebrochen.

=== Der Errorhandler

Die Behandlung von Programmfehlern erfolgt mittels der Klasse Clansuite_Errorhandler.

Zahlreiche Webanwendungen machen von der Möglichkeit gebrauch, das Errorhandling an den Exceptionhandler zu
übertragen. Dies führt zu einer Vereinfachung des Systems, da nicht mehr zwei Handler-Klassen gepflegt werden
müssen. Clansuite nutzt diese Möglichkeit nicht. Ausgehend von einem jeweils eigenen Aussehen mit eigenen
Templates des jweiligen Handlers. Zum einen müsste der Exceptionhandler intern prüfen, ob eine Error die E
xception ausgelöst hat,  womit eigentlich Logik des Errorhandlers in den Exceptionhandler verschoben wird.

=== Der Exceptionhandler

Die Exceptionbehandlung ist ähnlich der Behandlung von Errors. Die Klasse Clansuite_Exception erweitert die
normale PHP Exception Klasse. footnote:[http://php.net/exceptions, PHP Handbuch - Kapitel Exceptions] Die
Erweiterung besteht dabei einerseits in verbesserter Darstellung der Exceptions, andererseits in dem
automatischen auffangen aller nicht abgefangenen Exceptions, z.B. denen fremder Bibliotheken.

Kern der Klasse ist die Methode yellowScreenOfDeath(), mit der eine Darstellungsmethode für Exceptions
eingeführt wird. Sie zeigt Exceptionmessage und Code, sowie die Ausgabe der nicht abgefangenen Exception an.
Erweitert wird die Anzeige durch Debuginformationen, wie z.B. dem Debug-Call-Stacktrace, welcher die zuletzt
ausgeführten Methodenaufrufe vor dem Exceptioneintritt aufführt und der Anzeige von Direktlinks zum Support
und zu den Handbüchern.

Mittels set_exception_handler wird ein systemweiter Exceptionhandler registriert. Er sorgt dafür, dass nicht
abgefangene Exceptions mittels dieser Darstellungsmethode anzeigt werden. Dies erfolgt bei Initialisierung des
Systems innerhalb der Methode initialize_Errorhandling() in der Datei "bootstrap/clansuite.application.php".
Dieser wirft durch Aufruf der Methode throwException() eine neue Clansuite_Exception.

=== Das Werfen von Exceptions

[source, php]
---------------------------------------------------------------------
/**
 * Hier wird eine normale Exception geworfen.
 * Diese wird durch den Exception Handler gefangen und in eine Clansuite Exception umgewandelt.
 */
throw new Exception('Meine Exception');

/**
 * Es wird eine Clansuite Exception mit der Exceptionnummer 60 geworfen.
 * Sollte ein Exception Template für die Nummer 60 existieren, wird sein
 * Inhalt innerhalb des Exception-Kontext dargestellt.
 */
throw new Clansuite_Exception('Meine Exception', 60);

# werfen einer Exception
Clansuite_Exception->throwException(),

# Verwendung bei Methoden, die einen Wert des Typs Boolean zurückliefern
someBooleanMethod() or throwException();
# Beispielsweise
isFileandReadable('filename.txt') or throwException('File not found or not readable!');
---------------------------------------------------------------------

==== Die Exceptionhandler Templates

Der Exceptionhandler bietet die Möglichkeit mit Exceptiontemplates zu arbeiten. Das sind Templates die zu
einer Exception einen ausführlicheren Beschreibungstext anbieten und somit den Kontext der Exception
erläutern, um den Fehler zu überwinden. Jeder Exception ist eine Identifikatonsnummer zugewiesen, anhand
dieser wird ein entsprechendes Template geladen.

Dabei unterscheiden wir zwei Arten von Exceptiontemplates. Zum einen normale Exceptiontemplates. Die angezeigt
werden, wenn das System im Debugmodus betrieben wird. Zum anderen Entwickler-Exceptiontemplates. Die angezeigt
werden, wenn das System im Debug- und Developermodus betrieben wird. Die Exceptionstemplates befinden sich im
Verzeichnis "themes\core\exceptions".

Der Unterschied zwischen der beiden Arten von Templates findet seinen Ausdruck in der Benennung der
Templatedateien. Der Dateiname normaler Exceptiontemplates lautet "exception-x.tpl". Der Dateiname von
Entwickler-Exceptiontemplates lautet "dev-exception-x.tpl". Hierbei steht das "x" jeweils für den
Exceptioncode, die eindeutige Identifikationsnummer. Wenn für einen Excpetioncode beide Templates existieren,
dann werden auch beide nacheinander innerhalb der Exceptionanzeige angezeigt.
Die Reihenfolge der Darstellung ist dabei Normaltemplate vor Entwicklertemplate.

==== Die Exceptionhandler Codes

Nachfolgende Tabelle schlüsselt die bisher vergebenen Exceptioncodes auf.
Eine entsprechende Datei befindet sich auch im Verzeichnis der Templates.