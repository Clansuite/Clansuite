////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://docs.clansuite.com/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 17 - Die Clansuite Programmierrichtlinien

Dieses Kapitel stellt den Clansuite Coding Standard, also die jeweils aktuell geltenden Programmierrichtlinien
von Clansuite dar. Es ist untergliedert in drei Abschnitte. Im ersten und zweiten Abschnitt werden zwei
Richtlinienarten erläutert. Die Richtlinien für die förmliche Gestaltung des Quelltextes und die Regeln für
die Programmierung. Der dritte Abschnitt beschäftigt sich mit der automatischen Kontrolle dieser Richtlinien
mit dem Werkzeug CodeSniffer.

Regeln und Konventionen sind feste, starre Richtlinien für den Entwurf einer Applikation. Diese Regeln mögen
vielen Entwicklern als Gängellei erscheinen. Doch das ist bei Regeln der Normalfall. Sie wurden festgelegt, um
Fehler zu vermeiden und hervortreten zu lassen und um eine bestimmte Form und Qualität bei der Entwicklung zu
erzielen. Es sind absichtliche (künstliche) Einschränkungen der Software, die dem Entwickler einige
Entscheidungen abnehmen und den Entwicklungsprozess effizienter und konsistenter gestalten. Es sind kleine,
sich wiederholende Zeremonien.

Die Notwendigkeit von Programmierrichtlinien ergibt sich aus dem Gebot der Quellcodeschönheit ("Code is Poetry") 
und einer Kostenbetrachtung bei der Softwareentwicklung. Während des Lebenszyklus einer Software wird ein 
Großteil der Kosten durch die Wartung verursacht. Oft sind in den unterschiedlichen Lebensphasen einer 
Software nicht die gleichen Programmierer am Werke. Die Wartungskosten entstehen daher oft durch die zusätzliche 
Einarbeitungszeit in den zu wartenden Quellcode durch neue Programmierer. Um die Wartungskosten, und damit die
Gesamtkosten, gering zu halten, ist es erforderlich Quellcode so zu schreiben, dass er einfach nachzuvollziehen 
und die Einarbeitungszeit gering ist.

Mache den Codingstyle nach, den Du im Clansuite Repository vorfindest. Erfinde den Style nicht neu und halte
Dich an die gegebenen Spielregeln. Um auf Fehler automatisch beim Committen ins SVN hingewiesen zu werden,
kannst Du einen SVN pre-commit-hook einsetzen. Beim Versuch eine Datei ins SVN zu committen, wird der
PHP CodeSniffer zunächst den Stil und die Richtigkeit der PHP-Syntax der Datei kontrollieren.
Im Fehlerfall bekommst Du eine ausführliche Meldung, was in einer Datei zu verändern ist,
damit sie regelkonform wird.

Für alle offenen Fragen und unbehandelten Themen gilt die analoge Anwendung der PEAR Standards.
- http://pear.php.net/manual/en/standards.php
- http://www.dagbladet.no/development/phpcodingstandard/

=== Richtlinien für die förmliche Gestaltung des Quelltextes

Wenn in diesem Kapitel von richtig und falsch gesprochen wird, dann ist damit nicht
die Funktionalität des Quellcodeabschnitts gemeint, sondern seine Form und Darstellung.

==== PHP Dateianfang und Dateiende

Jede PHP Datei beginnt mit <?php und endet mit ?>.
Das bedeutet, dass weder vor dem öffnenden noch nach dem schließenden Tag Leerzeichen stehen.
Abgekürzte Tags (engl. short tags) sind verboten ( <? ?> ).

[source, php]
---------------------------------------------------------------------
<?php
    /**
     * Quelltext
     */
?>
---------------------------------------------------------------------

Viele PHP-Projekte definieren in Ihren Programmierrichtlinien den Verzicht auf das schließende ?> Tag.
Zum einen wird angeführt, dass man den schließenden ?> Tag nicht wirklich braucht. Das mag wohl richtig sein,
aber schlampig arbeiten ist eben sehr einfach. Zum anderen wird angeführt, dass es zu Problemen kommen kann,
wenn nach dem ?> Tag weitere Zeichen, regelmäßig sind es vergessene Leerzeichen, folgen. Diese Meinung kann
man gut vertreten, wenn man die Übersicht über die Leerzeichen nach dem eigenen Programm bereits verloren hat
und der Verzicht auf den schließenden Tag die einfachste Lösungsmöglichkeit ist.

==== Kommentare

Um den Umfang eines oder mehrerer Kommentare zu bestimmen, kann man beherzt auf die einfache Grundregel
40% Kommentare und 60 % Code zurückgreifen.
Beim Kommentieren ist es wichtig, darauf zu achten, dass die Kommentare so einfach wie möglich geschrieben sind.
Kommenate sind keine wissenschaftlichen Abhandlungen.
Im Prinzip sollte Deine Oma verstehen können, was der Code an dieser Stelle macht.
Mit anderen Worten, ist es für einen Nichtprogrammierer möglich, anhand der Kommentare den Ablauf des Programms
nachzuvollziehen.
Es hat sich aber herausgestellt, dass für ein späteres Wiederverstehen von Codeabschnitten durch Programmierer,
Kommentare besonders hilfreich sind, die nicht lediglich das "Wie" oder "Was" kommentieren, denn das beschreibt
der Quellcode selbst, sondern die das "Warum eine bestimmte Codezeile existiert" erläutern.

Einzeilige Kommentare werden durch # eingeleitet (Perl-Style), nicht durch "//" oder "/* */".

.Einzeilige Kommentare
[source, php]
---------------------------------------------------------------------
Richtig:
# Kommentar

Falsch:
// Kommentar

Falsch:
/* Kommentar */
---------------------------------------------------------------------

Es ist erlaubt einzeilige Kommentare hinter dem zu kommentieren Quellcode einzusetzen.

.Kommentareinsatz nach PHP Anweisung
[source, php]
---------------------------------------------------------------------
# Richtig (Kann-Vorschrift):
$counter = '123'; # Der Kommentar erklärt was warum gezählt wird.
---------------------------------------------------------------------

.Mehrzeilige Kommentare
Mehrzeilige Kommentare werden im DocBlock-Style dargestellt.
Sie werden in der ersten Kommentarzeilen mit +++"/**"+++ eröffnet.
Die zweite Kommentarzeilen beginnt mit +++" *"+++ (Leerzeichen dann Sternchen).
Dies erfolgt, damit die Sterne +++"*"+++ untereinander stehen, gefolgt vom ersten Kommentar.
Es folgen beliebig viele weitere Kommentarzeilen dieser Art.
Die letzte Kommentarzeilen enthält den Kommentarabschluss +++" */"+++.

[source, php]
---------------------------------------------------------------------
Richtig:
/**
 * Ein Kommentar
 * über mehrere Zeilen.
 */

Falsch:
/*
Ein Kommentar
über mehrere Zeilen.
*/

Falsch:
// Ein Kommentar
// über mehrere Zeilen.
---------------------------------------------------------------------

.PHPDocumentor Kommentierungsstil

Immer den PHPDocumentor Kommentierungsstil einsetzen.
Die automatische Erstellung von PHPDoc-Tags wird durch IDEs wie Netbeans, Zend Studio, Eclipse PDT unterstützt.
Die IDEs werten die PHPDoc Tags aus und bieten CodeHints, CodeCompletion und Popup-Documentation on the fly.
footnote:[http://manual.phpdoc.org/HTMLSmartyConverter/HandS/phpDocumentor/tutorial_phpDocumentor.howto.pkg.html#basics.starting]
Link zum PHPdoc-Tutorial.

.PHPDoc Schlüsselwörter (Tags)

a. Pflichtangaben

   Immer *@license*, *@author* und *@param*, *@returns*, *@vars* definieren. Zusätzlich bei Bedarf *@see* und *@link*.
   Bei der Definition von *@param* ist stets der Typ des Parameters anzugeben. Im Zweifel ist "mixed" als Typ zu verwenden.
   Der Tag *@license* ist immer: [ * @license    GNU/GPL v2 or (at your option) any later version, see "/doc/LICENSE". ]

b. Verbote

   Keinesfalls *@globals* definieren. Da die Verwendung von globalen Variablen verboten ist, sind sie auch nicht zu dokumentieren.
   Keinesfalls *@access* definieren. Dieser Tag ist veraltet (PHP4) und kann durch einen PHPDOC-Parser automatisch bestimmt werden.
   Keinesfalls *@since* definieren. Um die Versionsgeschichte nachzuvollziehen, können die Logs des Quellcode-Repositories bemüht werden.

c. Optionale Schlüsselwörter verwenden:

   - *@todo* [taskid] Topicname evtl. URL zum  Bugtracker
   - *@bug*  [bugid]  Topicname
   - *@example* Angabe von Quellcode der die Verwendung erläutert.

d. Ein PHPDoc-Block beginnt immer mit einem Satz und endet mit einem Punkt.
   Alle PHPDoc Tags hingegen verzichten auf den abschließenden Punkt.

.Dateien

Der Dateikopf einer PHP-Datei beginnt immer mit dem DocBlock des Projekts.

[source, php]
---------------------------------------------------------------------
<?php
   /**
    * Clansuite - just an eSports CMS
    * Jens-André Koch © 2005 - onwards
    * http://www.clansuite.com/
    *
    * This file is part of "Clansuite - just an eSports CMS".
    *
    * LICENSE:
    *
    *    This program is free software; you can redistribute it and/or modify
    *    it under the terms of the GNU General Public License as published by
    *    the Free Software Foundation; either version 2 of the License, or
    *    (at your option) any later version.
    *
    *    This program is distributed in the hope that it will be useful,
    *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    *    GNU General Public License for more details.
    *
    *    You should have received a copy of the GNU General Public License
    *    along with this program; if not, write to the Free Software
    *    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
    *
    * @license    GNU/GPL v2 or (at your option) any later version, see "/doc/LICENSE".
    * @author     Jens-André Koch <vain@clansuite.com>
    * @copyright  Jens-André Koch (2005 - onwards)
    * @link       http://www.clansuite.com
    *
    * @version    SVN: $Id$
    */

# Security Handler
if(defined('IN_CS') === false)
{
    die('Clansuite not loaded. Direct Access forbidden.');
}
---------------------------------------------------------------------

.Klassen

Klassen und Interfaces beginnen immer mit einem DocBlock nachfolgender Art:

[source, php]
---------------------------------------------------------------------
/**
 * Name der Klasse evtl. Kurzbeschreibung. Ein Satz.
 *
 * Ein längerer
 * auch mehrzeiliger
 * Beschreibungstext.
 *
 * @author      Vorname Nachname <email>
 *
 * @category    Clansuite
 * @package     Core
 * @subpackage  ModuleController
 */
---------------------------------------------------------------------

Der *@license* Tag über der Klassendefinition ist regelmäßig entbehrlich, da die Lizenzdefinition bereits im Projektheader erfolgt ist.
Möchte ein Klassenautor denoch davon abweichen, so hat er zuerst eine GNU/GPL v2+ kompatible Lizenz zu wählen und kann diese
anschließend mit dem @license Tag im DocBlock der Klasse angeben.

Der *@category* Tag muss immer den Inhalt "Clansuite" haben.
Das *@package* Tag gibt an in welchen Bereich des Systems die Klasse gehört. Wir unterscheiden die Angaben "Core" und "Modules".
Das *@subpackage* Tag wiederholt den Namen der Klasse.

.Methoden

Methoden beginnen immer mit einem DocBlock nachfolgender Art. Dieser Dokumentationsblock enthält
einen kurzen einführenden Satz der die Methode bezeichnet, gefolgt von einem optionalen Beschreibungstext
und einer Beispielsangabe, welche die Verwendung der Methode verdeutlicht.
Anzugeben sind immer die Parameter und eventuelle Rückgabewerte.
Gleiches gilt auch für Funktionen (dann natürlich ohne die Sichtbarkeitsdefinition).

[source, php]
---------------------------------------------------------------------
/**
 * eineMethode - ist eine PHPDoc-Block Demonstration.
 *
 * Eine längere Beschreibung ist optional.
 *
 * Wünschenswert ist die Angabe eines Beispiels.
 * @example
 *      $this->eineMethode('meinParameterXY');
 *
 * @param <type> $parameter Erläuterung zum Parameter
 * @return <type> Beschreibung
 */
public function eineMethode($parameter)
{
    /**
     * Methode für das PHPDoc Beispiel
     */

    return $parameter;
}
---------------------------------------------------------------------

==== Einrückungen

Quellcode ist einzurücken.
Im Quellcode sind keine Tabulatoren (Tabulatoren-Sprünge) zu verwenden.
Sie können bei den meisten Editoren und IDE's einstellen, dass der Tabulator (Tab-Taste) einer bestimmten Anzahl von Leerzeichen entspricht.
Diese Einstellung findet sich unter "Tabulatorgröße in Leerzeichen einstellen" oder "Tabulator zu Leerzeichen" oder "Tab Policy".
Verwende in PHP Dateien 4 Leerzeichen, in CSS und JS und YML jeweils 2 Leerzeichen.

==== Weißraum und Leerzeichen

.Weißraum am Zeilenende entfernen.
Der Weißraum an Zeilenenden ist zu entfernen.

.Leerzeichen in und nach Anweisungen
Um die Lesbarkeit zu erhöhen, sind innerhalb und nach Anweisungen Leerzeichen zu verwenden.

[source, php]
---------------------------------------------------------------------
# richtig
if ( $bedingung === true )
{
    echo 'bedingung ist wahr!';
}

for($i = 0; $i < count($result); $i++)

# falsch
if($bedingung===true){echo'bedingung ist wahr!';}
for($i=0;$i<count($result);$i++)
---------------------------------------------------------------------

.Commit ins SCM
Entferne Weißraum nur von Zeilen, die du tatsächlich verändert hast.
Oder anders formuliert: Deine Änderungen bringen keinen überflüssigen Weißraum mit.
Wenn bei einem Commit die Mehrzahl der Änderungen auf "Weißraum" / "Leerzeichen" Entfernung entfällt, 
dann ist dieser Commit als alleinstehender QA bzw. Coding Style Enforcement Commit durchzuführen.
Somit werden eventuell vorhandene, überflüssige Leerzeichen durch Quality Assurance Commits entfernt.

==== Boolean-Ausdrücke

Boolean-Ausdrücke immer klein schreiben (true, false, null) und nicht groß (nicht TRUE, FALSE) oder mit großem
Anfangsbuchstaben (nicht True, False). Keine Zahlenwerte für Booleans verwenden (nicht 0 / 1).
Eine Ausnahme gilt im Bereich der Konfigurationsdateien. Hier sind Zahlenwerte für Booleans zulässig.
Boolean-Kontrolle mit "===" durchführen, anstelle von "==".

Vergleiche sind immer explizit durchzuführen - implizite Vergleiche sind verboten.
.Verbot impliziter Vergleiche
[source, php]
---------------------------------------------------------------------
# Falsch:
if ( is_null($var) ) # impliziter true-vergleich
{
    ...
}

# Richtig:
if ( is_null($var) === true ) # expliziter true-vergleich
{
    ...
}
---------------------------------------------------------------------


Verwenden Sie is_null() um zu prüfen, ob eine Variable vom Typ "null" ist.

.Verwendung von is_null
[source, php]
---------------------------------------------------------------------
# Richtig:
if ( is_null($var) === true )
{
    ...
}

# Falsch:
if ( $var == null)
{
    ...
}
---------------------------------------------------------------------

=== Logische Operatoren

Die Verwendung der logischen Operatoren "&&" und "||", sowie "!" ist verboten.

Die beiden Operatoren "&&" und "||" haben eine höhere Priorität als die logischen Operatoren "and" und "or",
obwohl sie logisch-funktional äquivalent sind[footnote: http://www.php.net/manual/de/language.operators.precedence.php].
Viele PHP-Programmierer sehen zumeist nur die funktionale Gleichwertigkeit.
Der Grund für die Existenz zweier unterschiedlicher Operatoren für die "Und"- und die "Oder"-Verknüpfung ist jedoch,
dass die beiden Operatoren jeweils eine Rangfolge haben.
Die zu beachtende Operatoren-Rangfolge wird oft vernachlässigt oder ist oftmals gar nicht bewusst.
Bei uneinheitlicher und unachtsamer Verwendung der Operatoren und insbesondere bei gemischter Verwendung,
kann dieser Umstand aber zu erheblichen Problemen bei der Auswertung von If-Ausdrücken führen.

Zudem ist die Verwendung von "and" (Und) , "or" (Oder), "xor" (Entweder Oder) schneller!

Der logische Operator "!" (Nicht) prüft auf "nicht true". Er kann oft durch einen Vergleich mit false ersetzt werden.
Nach Möglichkeit sind Negativprüfungen (Vergleiche mit false) zu vermeiden und Positivprüfungen (Vergleiche mit true) durchzuführen.

==== Klammern

.Klammern auf einer Zeile
Klammern sind auf einer Zeile darzustellen. Diese Regel gilt solange die maximale Zeilenlänge erreicht ist.

Zu einer Überschreitung der maximalen Zeilenläge kommt es oftmals bei komplexen Bedingungen
und mehrdimensionalen Arrays. Hier gelten die folgenden Klammer-Regeln.

.If-Anweisung mit mehreren Bedingungen
[source, php]
---------------------------------------------------------------------
if ( ($bedingung1 != 1 and $bedingung2 == 2) or
     ($bedingung3 != 3 or $bedingung4 == 4)
   )
{
    Anweisung
}
---------------------------------------------------------------------

.Mehrdimensionale Arrays
[source, php]
---------------------------------------------------------------------
$array = array (
                 'element1' => 'wert1',
                 'element2' => 'wert2',
                 'element3' => 'wert3'
               );
---------------------------------------------------------------------

==== Geschweifte Klammern

Die geschweiften Klammern { und } befinden sich jeweils auf einer neuen Zeile. Die öffnende geschweifte
Klammer ist unterhalb des ersten Zeichens des PHP-Commands zu platzieren. Die schließende auf gleicher
Einrückungshöhe. Das ist der sogenannte Eric Allman-Stil (Autor von sendmail) und das Gegenteil vom Unix-
Style!

Die Zeilen mit geschweiften Klammern sind als Quasi-Leerzeilen zu verstehen und sehr wichtig, denn sie erhöhen
die Lesbarkeit der Programmstrukturen. Man kann sie auch als Absatz eines Textes verstehen.
Daher gilt, jeder Weißraum der durch eine geschweifte Klammer geschaffen wird, ist positiv zu bewerten.
Der Unix-Style ist in seiner Form eher auf komprimierte Kurzschreibweise ausgerichtet.
Als Entwickler muß man Quellcode nicht ausdrucken und inzwischen (2010!) sind 20+ Zoll Monitore verbreitet.

Das Weglassen von geschweiften Klammern ist verboten.
Ein häufig anzutreffendes Beispiel ist das Weglassen von Klammern bei einzeiligen if-Anweisungen.

.Weglassen von geschweiften Klammern bei einzeiligen if-Anweisungen
[source, php]
---------------------------------------------------------------------
# falsch (syntaktisch natürlich korrekt und lauffähig)
if($bedingung) echo 'Bedingung ist wahr!';

# richtig
if ($bedingung === true)
{
    echo 'Bedingung ist wahr!';
}
---------------------------------------------------------------------

=== Richtlinien für die Programmierung

Bevor etwas programmiert wird, sollte erstmal ein logischer Vorentwurf erfolgen. Dazu kann man eine Skizze auf
einem Blatt anfertigen oder ein Grafik- oder Schreibprogramm verwenden. Insbesondere gibt es CASE-Tools und
UML-, sowie ER-Werkzeuge, um Strukturen und Beziehungen besser zu modellieren. Dieses Vorgehen entspricht der
Vorentwicklungsphase innerhalb des Drei-Phasen-Prinzips der Softwareentwicklung. Man unterteilt dabei die zu
verrichtenden Tätigkeiten in die Phasen Vorentwicklung, Entwicklung, und Nachentwicklung.
Siehe dazu auch den Abschnitt zum Entwicklungsprozess im Kapitel 2 Projektorganisation.

==== Struktur

Es ist stets die Gesamtstruktur und ein bestehender Ablaufplan beachten.
Ein neues Teil fügt sich immer in das Ganze.
Zerlegen der größeren Aufgabe in kleinere Teile (Teile-Herrsche & Salami-Taktik).

Am Anfang erfolgt immer die Initialisierung von Variablen.
So werden Notices vermieden und der schwachen Typisierung von PHP entgegengewirkt.

Der Anfang einer Applikation ist der richtige Ort um Konstanten zu definieren.

Danach kann mit der Deklaration von Funktionen oder Klassen mit Methoden begonnen werden.

Innerhalb von Klassen sind normale Methoden vor magischen Methoden zu deklarieren.
Eine Ausnahme bildet der Konstruktor einer Klasse. Er ist die einzige magische Methode,
die an den Anfang der Klasse gehört. Eine __toString() Methode kommt regelmäßig an das Ende einer Klasse.

==== Konvention geht über Konfiguration

Im Ergebnis soll ein konfigurierbarer Teil der Software lauffähig sein, ohne eine Konfiguration vornehmen zu müssen.
Nach Möglichkeit sind für alle Konfigurationseinstellungen sinnvolle Standardwerte zu setzen.
Nach Möglichkeit ist also mit Fallbacks auf Konfigurationsstandardwerte zu arbeiten.

==== Klassen

.Lose Kopplung
Abhängigkeiten zwischen den Klassen vermeiden. Lose Kopplung der Klassen bevorzugen.
Jede Klasse als ein funktional eigenständiges Gebilde betrachten.

.Klassennamen und Namespaces
Weil PHP erst ab Version 5.3.0 die Verwendung von Namespaces unterstützt, ist allen Clansuite Klassen
der Prefix "Clansuite_" vorangestellt. Namensräume ermöglichen eine neue Art der Kategorienbildung
und damit der Ordnung von Klassen. Auf diese Art lassen sich benutzerdefinierte Klassen besser
von systemeigenen Klassen unterscheiden und es treten keine Kollisionen auf.

Wir werden zu gegebenen Zeitpunkt Namespaces einsetzen, um die langen Klassennamen zu kürzen.

.Interfaces (Schnittstellen)

Die Namen für Interfaces entsprechen denen Klassennamen. Sie enden jedoch immer mit "_Interface".
[source, php]
---------------------------------------------------------------------
class Clansuite_Klassenname implements Clansuite_Klassenname_Interface
{
   # ...
}
---------------------------------------------------------------------

==== Umgang mit SQL

SQL gehört aufgrund der MVC-Schichtentrennugn immer in den Bereich des Models.
Die SQL Abfragen sind in Methoden zu fassen.
Diese SQL-Methoden liefern ein oder ein zusammengefasstes Array (compact) zurück.

==== Funktionen, Methoden

.Klassenmethoden statisch deklarieren
Nach Möglichkeit sind Klassenmethoden als statisch zu deklarieren ("static functions"). Klassenmethoden als
statisch zu deklarieren macht diese zugänglich, ohne dass man die Klasse instanzieren muss. Dabei ist zuerst
immer die Sichtbarkeit anzugeben. Demnach ist die Benennung "public static function" formrichtig,
nicht hingegen "static public function".

[source, php]
---------------------------------------------------------------------
public    static method1()  { ... }
private   static method2()  { ... }
protected static method3()  { ... }
---------------------------------------------------------------------

.Auspacken von Schachteln
Das Ineinanderverschachteln von Funktionen ist unübersichtlich und daher nicht wünschenswert.
Ab einer Verschachtelungstiefe von 3 Funktionen mit Parametern, sind die Verschachtelungen aufzulösen.

.Verkettungen
Im Bereich der Konkatenation ist sprintf() einzusetzen.
Als eine Orientierung, ab wann auf sprintf() zurückzugreifen ist, um einen String zu erzeugen, gilt ein Wert von 3 Verkettungen.

==== Der goto Operator

Der goto-Operator ist verboten. Er führt häufig zu Spaghetticode, verschlechtert also die Programmqualität.

Der goto-Operator wurde in PHP 5.3 als neue Kontrollstruktur eingeführt.
Mit Goto lassen sich bedingte Sprünge oder Schleifen ausdrücken.
Der Ursprung des Goto-Operators liegt in der unbedingten Sprunganweisung JMP (jump / Assembler68),
die die Kontrolle an einen anderen Punkt im Programm überträgt. Dieser Punkt wird durch eine Sprungmarke (label)
definiert. 

Goto verstärkt PHPs Ausdrucksmöglichkeiten im Bereich von kleinen Scripten.
Für mehr taugt dieses Sprachmittel meiner Meinung nach nicht, da die
Nachvollziehbarkeit eines längeren Programmflusses durch die Sprünge erheblich leidet.
Es sind immer zusätzliche Sprungmarken (labels) einzuführen.

Zudem gibt es einige Einschränkungen bei der Verwendung.
Man kann aus Code-Blöcken zwar herausspringen, aber nicht in sie hinein.
Zudem sind Sprünge nur im gleichen OpCode-Array Bereich durchführbar, d.h. nur innerhalb der gleichen Funktion
bzw. innerhalb des globalen Bereichs der gleichen Datei. 

.Beispiele
[source, php]
---------------------------------------------------------------------
label-A: echo 'Hello World!';
goto label-A;
---------------------------------------------------------------------

Ich möchte an dieser Stelle, an den kurzen und oft zitierten Artikel "Go To Statement Considered Harmful" von Edsger W. Dijkstra erinnern,
der bereits im März 1968 erschienen ist. Schon der Einleitungssatz bringt es auf den Punkt:
"the quality of programmers is a decreasing function of the density of go to statements in the programs they produce".
footnote:[Communications of the ACM, Vol. 11, No. 3, March 1968, pp. 147-148. Copyright © 1968, Association for Computing Machinery, Inc.]

==== Grundsätzliches zu Variablen und Konstanten in PHP

.Namenskonventionen für die Bezeichnung von Konstanten und Variablen
Konstanten und Variablen sind eindeutig zu bezeichnen. Ein Bezeichner ist immer so zu wählen, das in ihm kurz
und prägnant zum Ausdruck kommt, welchen Inhalt oder welche Funktion sich dahinter verbirgt. Es sollen
logische und unabgekürzte Namen bei gleichbleibender Verwendung sein. Zur Bezeichnung bzw. Identifikation
sind Literale (Buchstaben und Buchstabenketten) und Numerale (Zahlen und Zahlenketten) zu verwenden. Zulässig
ist dabei eine Kombination von Literalen und Numeralen, sowie der Einsatz des Unterstrichs als Trennzeichen und 
zur Gruppierung durch einen Prefix. Eine Bezeichnung unter ausschließlicher Verwendung von Numeralen ist ebenso 
untersagt, wie die Verwendung von "l33tspeak". Konstanten werden in Großbuchstaben geschrieben.

Variablennamen sollen möglichst prägnant sein, denn man soll sofort sehen können was eine Variable macht. Aber
vor allem soll man einer Variable ansehen können, wenn sie falsch verwendet wird. Die falsche
Variablenverwendung soll im Quelltext deutlich als falsch erkennbar sein. Außerdem soll eine Variable so nah
wie möglich an ihrem Verwendungsort definiert werden.
Das erleichtert die Suche im Kontext durch Beschränkung auf einen kleinen Umkreis.

.Beispiele
[source, php]
---------------------------------------------------------------------
/**
 * Der Bezeichner für die Variable besteht aus Literalen und Unterstrichen.
 * Man kann nachvollziehen, was sich hinter dem Namen verbirgt.
 * Er ist grundsätzlich zulässig, allerdings nicht kurz und prägnant gewählt.
 */
$das_haus_in_dem_ich_wohne_hat_die_hausnummer = '20';

# Ok.
$haunummer = '20';

# Auch das  Voranstellen des Variablentyps ist zulässig.
$intHausnummer = '20';
$boolUserIsAuthed = true;

# Unzulässig, da nur Numerale eingesetzt werden.
$558 = array('');

# Zulässige Kombination von Literalen und Numeralen und Unterstrich.
$haus_1 = array( 'hausnummer' => '20', 'straße' => 'sonnenallee', 'stadt' => 'köln');
---------------------------------------------------------------------


.Datentypen
PHP ist eine schwach typisierte Sprache. Einer Variablen kann man daher verschiedene Datentypen zuweisen.
Einige Beispiele:
$var = 0;         # int
$var = false;     # bool
$var = 'string';  # string
Der Datentyp muss daher vom Programmierer unbedingt im Auge behalten werden.
Aber auch der Aufgabengehalt einer Variable ist wichtig. Dafür ist eine Kontextbeobachtung notwendig.
Es gibt also zwei wichtige Dinge bei einer Variablen: ihr Datentyp und ihre Aufgabe.

Ein typisches Beispiel wäre eine Flag-Variable. Jeder Variable kann man nur Datentyp und Inhalt entnehmen. Die
Eigenschaft eine Flag-Variable zu sein, kann man der Variable selbst nicht entnehmen, sie ergibt sich nur im
Programmkontext. Der Kontext lässt sich durch einen Kommentar hinter der Initialisierung der Variable angeben.
Aber damit ist diese Information nicht an jeder Stelle verfügbar, bei der diese Variable verwendet wird.
(Ausnahme: Gute Entwicklungsumgebungen (IDE's) und Editoren können einmal definierte Variablen und deren
Kommentare bei Wiederverwendung anzeigen. Beispielsweise implementiert NetBeans diese Kontextfunktion für
Klassen, Methoden und Variablen. Sie ist mittels der Tastenkombination "Steuerung und Leertaste" zu
erreichen.)

Zu einer Zeit als helfende IDE's noch nicht entwickelt waren führte man eine spezielle Methode ein, um den
Kontext anzugeben. Um diese Variablen-Kontextbeobachtung zu erleichtern, wurde eine Namenskonvention für
Variablen entwickelt, bei der die Art der Variablen in ihrem spezifischen Kontext zu einem Bestandteil des
Variablennames wurde. Man nennt diese Namenskonvention "ungarische Notation". Die Konvention geht auf Charles
Simonyi, einen ungarischen Programmierer und späteren Chefentwickler bei Mircosoft zurück.
Die originale "ungarische Notation", auch "Apps Hungarian" genannt, gibt den Kontext einer Variablen an, nicht den Datentyp.

.Speicherfreigabe
Nach Verwendung einer Variablen sollte sie aus Gründen der Ressourcenschonung aus dem Speicher entfernt werden.
Ein unset() zu verwenden ist die saubere und manuelle Art der Speicherbereinigung.
Bei PHP-Applikationen ist dieser Punkt nicht ganz so wichtig.

.Unterstrich am Anfang des Variablennamens
Außer Kraft: Klasseninterne Variablen haben mit einem Unterstrich "_" zu beginnen.
Der Unterstich ist meiner Meinung nach sinnlos, da der Sichtbarkeitsbereich der Variablen durch Doc-Werkzeuge
automatisch erkannt werden kann. Nachfolgende Regelungen sind ohne den beginnenden Unterstich zu lesen.

.CamelCase
Bei Variablennamen ist grundsätzlich CamelCase zu verwenden.
Jedoch mit der Ausnahme, dass das erste Variablenwort dabei klein zu schreiben ist.
Richtig: $this->_klassenVariable;

Bei der Zuweisung eines Strings an eine Variable sind stets einfache Anführungszeichen zu verwenden.

.Doppelte Anführungszeichen sind verboten
[source, php]
---------------------------------------------------------------------
#Richtig:
$string = 'text';

#Falsch:
$string = "text";
---------------------------------------------------------------------

Das Verbot doppelter Anführungszeichen zieht das Verbot der Variablenausgabe innerhalb von Strings nach sich.

.Variablenausgabe innerhalb von Strings
[source, php]
---------------------------------------------------------------------
Falsch:
$var = 'Hello';
$string = "$var World!";
---------------------------------------------------------------------

Verwenden Sie stattdessen Konkatenation. Setzen Sie also Zeichenketten aus Teilen zusammen.

.Konkatenation
[source, php]
---------------------------------------------------------------------
Richtig:
$string = $var . ' World!';
---------------------------------------------------------------------

Sind mehrere Ersetzungen in einem String erforderlich, so greifen Sie auf sprintf() zurück.

.Bei mehreren String-Ersetzungen sprintf() verwenden
[source, php]
---------------------------------------------------------------------
$var2 = 'This is';
$string = sprintf('%s %s World!', $var2, $var); # This is Hello World!
---------------------------------------------------------------------

.Leerzeile vor return Anweisung
Jeder return Anweisung ist eine Leerzeile voranzustellen.
Dies hebt einen Rückgabewert nochmals hervor.
[source, php]
---------------------------------------------------------------------
# falsch:
$variable = 'Text to return';
return $variable;

# richtig:
$variable = 'Text to return';

return $variable;
---------------------------------------------------------------------

==== Fehlerbehandlung

.Fehlerberichterstattungslevel E_STRICT
Damit jedes noch so kleine Warning sofort ins Auge springt.

.Fehlerunterdrückung mittels Silencing-Operator (@) ist verboten
Keine Fehlerunterdrückung mittels @-Operator bei Funktionsaufrufen verwenden!
Erstens ist es eine teure Operation, denn die Fehlerbehandlung wird zunächst abgestellt und nach Ausführung des
Kommandos wieder eingeschaltet. Zweitens entstehen dadurch nur unnötige Schwierigkeiten beim Debugging, die man vermeiden kann.
Wenn es nicht anders geht und Fehlerunterdrückung zum Einsatz kommt, ist immer detailliert zu Kommentieren.

==== Einsatz von PHP Kommandos

Für die Prüfung, ob eine Datei existiert, ist anstatt file_exists() immer is_file() zu bevorzugen.

Um eine Datei einzubinden bzw. zu laden ist immer die PHP Funktion _require_ anstatt _require_once_ zu verwenden.
Dabei ist immer der absolute Pfad zu verwenden und auf Klammern zu verzichten.

Zur Klammerverwendung bei require, require_once, include und include_once wird oft Eingewand,
Die Befehle können auch ohne Klammern geschrieben werden, dies aber bitte vermeiden.
Das unterstreicht den aktiven Charakter dieser Anweisungen (den Seiteneffekt der _once()-Variante).

==== Keine Globals

Keine Globals verwenden! Verboten: "global", "$GLOBALS".

==== PHP und HTML (Templates) auseinander halten

Trennungsprinzip beachten: Kein HTML im PHP.
Kein ECHO in Modulfunktionen verwenden (MVC-Durchbrechung), denn die Ausgabe erfolgt regelmäßig automatisch.
Das Trennungsprinzip darf nur im Bereich Fehler- und Ausnahmebehandlung durchbrochen werden.

==== Ternärer Operator

Das Grundanliegen des ternären Operators ist, eine einfache if-else-Anweisung platzsparend auszudrücken.
Das Konstrukt ist zweifellos sehr platzsparend. Manche Entwickler sehen aufgrund der Verkürzung der
if-else-Schleife auch eine verbesserte Lesbarkeit. Andere sehen darin eher eine Verschlechterung, wobei
neben das Lesbarkeitsproblem ein Verständlichkeitsproblem tritt. So beispielsweise bei Verwendung
von mehreren Bedingungen mit unterschiedlichen Boolean-Operatoren, sowie bei einer Einbettung
des ternären Operators in eine andere Anweisung.

Unter dem Namen "issetOr"-Operator wurde die Einführung der Kurzsyntax (?:) des ternären Operators diskutiert.
Es stellte sich heraus, dass einer der Hauptanwendungsbereiche des ternären Operators im Bereich der Variablen-Initialisierung
von Request-Parametern liegt.

[source, php]
---------------------------------------------------------------------
# Normalsyntax des ternären Operators
$id = isset($_GET['id']) ? $_GET['id'] : 0;

# Kurzsyntax des ternären Operators, der sogenannte "issetOr"-Operator (?:)
$id = $_GET['id'] ?: 0;

# Eingebettete Nutzung
echo 'Es ($i == 1 ? 'ist' : 'sind') '.$i.' Nutzer angemeldet.';

# Verschachtelter ternärer Opearator.
$value = ( $a == $b )
            ? 'true value # 1'
            : ( $a == $c )
                ? 'true value # 2'
                : 'false value';

# Etwas klarer, aber immernoch ungenügend, ist die Darstellung bei Anordnung
# der Bedingung und des Ergebnisses auf der gleichen Zeile.
$result = (condition == A) ? resultA :
          (condition == B) ? resultB :
          (condition == C) ? resultC :
          (condition == D) ? resultD :
                             fail_result;
---------------------------------------------------------------------

Der ternäre Operator ist verboten.

Statt des ternären Operators ist immer eine if-else-Anweisung zu verwenden.

==== Anführungszeichen

Einfache Anführungszeichen anstatt doppelte Anführungszeichen verwenden!

==== Datei- und Verzeichnisnamen

Für Dateien und Verzeichnisse sind nur alphanumerische Zeichen, sowie der Unterstrich (engl. underscore) "_" und
der Trennstrich "-" (engl. dash) erlaubt. Leerzeichen sind verboten.
Zusätzlich gilt für Datei- und Verzeichnisnamen die Kleinschreibung.

=== Clansuite CodeSniffer Standard

CodeSniffer ist ein PEAR Paket. Es überprüft den Quelltext auf die Verletzung vorher definierter
Programmierrichtlinien. Jeder Programmierer ist zwar gehalten, den Richtlinien zu folgen, aber im Eifer des
Gefechts werden starre Regeln manchmal über Bord geworfen, um zu schnellen Ergebnissen zu gelangen.
Unter dieser Verletzung der Richtlinien leidet jedoch die Qualität des Quellcodes.

Die in den vorherigen Abschnitten befindlichen Programmierrichtlinien wurden daher in einem CodeSniffer Regelsatz
zusammengefasst. Mit Hilfe dieses Regelsatzes ist es CodeSniffer möglich, den Quellcode automatisch auf Fehler zu prüfen
und diese anzuzeigen. Durch Verwendung von CodeSniffer lässt sich also die hohe Qualität des Clansuite Quellcodes sichern.

Der "Clansuite CodeSniffer Standard" befindet sich im SVN unter "/build-tools/CodeSniffer". CodeSniffer
liefert bereits einige Regelsätze bekannter Projekte wie Zend, Squiz und PEAR mit. Jeder Regelsatz besteht aus
einzelnen Regeln, den sogenannten Sniffs. So gibt es zum Beispiel einen Regelsatz "LineLengthSniff.php", der
die maximale Zeilenlänge einer PHP-Datei festlegt. Soweit die Konventionen anderer Projekte mit denen des
Clansuite Projekts übereinstimmen, wurde auf einige dieser "Standard Sniffs" zurückgegriffen, um den Clansuite
Standard zu realisieren. Wir definieren jedoch zahlreiche eigene "Sniffs", da die Clansuite
Programmierrichtlinien teilweise erheblich von denen anderer Projekte abweichen.

==== Installation des Clansuite CodeSniffer Standards

Die Installation des "Clansuite CodeSniffer Standards" kann auf zwei Wegen erfolgen.

Einmal ist der "Clansuite CodeSniffer Standard" als PEAR Paket erhältlich.
Er ergänzt also lediglich die bestehende PEAR CodeSniffer Installation um den Clansuite Regelsatz.

Falls man keinen Zugriff auf "pear" hat, kann man alternativ auch das Archiv herunterladen, auspacken und in das
PEAR Verzeichnis kopieren. Der richtige Ort innerhalb des PEAR Verzeichnisses ist: [PEAR]/PHP/CodeSniffer/Standards.

==== Verwendung von CodeSniffer

Wir setzen CodeSniffer auf zwei Arten ein:

.Ständiges Quellcode-Monitoring

Der Quelltext im "/trunk" wird ständig durch CodeSniffer auf Verletzungen der Richtlinien untersucht. Die
Überprüfung erfolgt mittels einer Phing Aufgabe ("codesniffer-report" und "codesniffer-report-w32"). Diese
CodeSniffer-Aufgabe wird regelmäßig aufgerufen. Der Aufruf erfolgt einerseits ausgelöst durch einen Cronjob
auf dem Clansuite-Entwicklungsserver, andererseits auch im Rahmen des kontinuierlichen Integrationsprozesses
durch Bitten (Trac). Alle Fehler werden in einem Fehlerbericht zusammengefasst und automatisch im
Entwicklerbereich der Webseite veröffentlicht. Jeder Entwickler kann so Verstöße erkennen und Fehler beheben.

Sie finden den CodeSniffer Fehlerbericht unter
http://docs.clansuite.com/developer/reports/codesniffer.html

.Quellcode-Kontrolle vor dem Commit

Damit fehlerhafter Quellcode aber gar nicht erst unter Versionskontrolle gestellt wird, kann und sollte man
ihn vor einem Commit überprüfen. Die Überprüfung kann auf zwei Arten geschehen.

Einmal durch manuelles Aufrufen des CodeSniffers: "phpcs --standard=Clansuite zu-prüfende-datei.php".
Dadurch wird die einzelne Datei gegen den Clansuite Standard geprüft.

HINT: Man kann die Angabe des "--standards" auch weglassen, wenn man in den CodeSniffer Einstellungen
      die Verwendung des "Clansuite Standards" als Grundeinstellung setzt.
      Der Befehl dafür ist "phpcs --config-set default_standard Clansuite".

Alternativ kann der Aufruf des CodeSniffers auch automatisch erfolgen, wenn man ihn in die Versionsverwaltung
einbindet. Diese Einbindung lässt sich sehr einfach mit einem Subversion "Pre-Commit-Hook" zum Aufruf von
"phpcs" umsetzen. Der "Pre-Commit-Hook", so ja auch schon sein Name, wird vor einem Commit ins Repository
automatisch ausgeführt. Sollten zu diesem Zeitpunkt Fehler im Quelltext enthalten sein, wird der Commit
abgebrochen. Man kann zum Code zurückkehren, die gemeldeten Fehler beheben und dann ein weiteres Mal versuchen
zu committen.
Werden keine Fehler gefunden erfolgt der Commit ins Quellcodearchiv.

http://pear.php.net/package/PHP_CodeSniffer

=== Standards für CMS und Frameworks

==== PHP-Standard für Frameworks

Derzeit wird in der Google Group "PHP-Standards" über eine Vereinheitlichung der Programmierrichtlinien
für PHP-Frameworks diskutiert. Es sind Vertreter der folgenden Systeme sind an der Diskussion beteiligt:
Cake, Seagull, Symfony, Prado, Zend Framework und Joomla, Mambo sowie Magento. Die Diskussion soll
dazu führen, dass Module und Komponenten zwischen den verschiedenen Systemen austauschbar und
wiederverwendbar werden. Ein aktueller Entwurf des zukünftigen Standards ist in der Google-Group abrufbar.

Google-Diskussionsgruppe
http://groups.google.com/group/php-standards?pli=1