////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 17 - Die Clansuite Programmierrichtlinien

Dieses Kapitel stellt den Clansuite Coding Standard, also die jeweils aktuell geltenden Programmierrichtlinien
von Clansuite dar. Es ist untergliedert in drei Abschnitte. Im ersten und zweiten Abschnitt werden zwei
Richtlinienarten erläutert. Die Richtlinien für die förmliche Gestaltung des Quelltextes und die Regeln für
die Programmierung. Der dritte Abschnitt beschäftigt sich mit der automatischen Kontrolle dieser Richtlinien
mit dem Werkzeug CodeSniffer.

Regeln und Konventionen sind feste, starre Richtlinien für den Entwurf einer Applikation. Diese Regeln mögen
vielen Entwicklern als Gängellei erscheinen. Doch das ist bei Regeln der Normalfall. Sie wurden festgelegt, um
Fehler zu vermeiden und hervortreten zu lassen und um eine bestimmte Form und Qualität bei der Entwicklung zu
erzielen. Es sind absichtliche (künstliche) Einschränkungen der Software, die dem Entwickler einige
Entscheidungen abnehmen und den Entwicklungsprozess effizienter und konsistenter gestalten. Es sind kleine,
sich wiederholende Zeremonien.

Mache den Codingstyle nach, den Du im Clansuite Repository vorfindest. Erfinde den Style nicht neu und halte
Dich an die gegebenen Spielregeln. Um auf Fehler automatisch beim Committen ins SVN hingewiesen zu werden,
kannst Du einen SVN pre-commit-hook einsetzen. Beim Versuch eine Datei ins SVN zu committen, wird der
PHP CodeSniffer zunächst den Stil und die Richtigkeit der PHP-Syntax der Datei kontrollieren.
Im Fehlerfall bekommst Du eine ausführliche Meldung, was in einer Datei zu verändern ist,
damit sie regelkonform wird.

Für alle offenen Fragen und unbehandelten Themen gilt die analoge Anwendung der PEAR Standards.
- http://pear.php.net/manual/en/standards.php
- http://www.dagbladet.no/development/phpcodingstandard/

=== Richtlinien für die förmliche Gestaltung des Quelltextes

Wenn in diesem Kapitel von richtig und falsch gesprochen wird, dann ist damit nicht
die Funktionalität des Quellcodeabschnitts gemeint, sondern seine Form und Darstellung.

==== PHP Dateianfang und Dateiende

Jede PHP Datei beginnt mit <?php und endet mit ?>.
Das bedeutet, dass weder vor dem öffnenden noch nach dem schließenden Tag Leerzeichen stehen.
Abgekürzte Tags (engl. short tags) sind verboten ( <? ?> ).

[source, php]
---------------------------------------------------------------------
<?php
    /**
     * Quelltext
     */
?>
---------------------------------------------------------------------

Viele PHP-Projekte definieren in Ihren Programmierrichtlinien den Verzicht auf das schließende ?> Tag.
Zum einen wird angeführt, dass man den schließenden ?> Tag nicht wirklich braucht. Das mag wohl richtig sein,
aber schlampig arbeiten ist eben sehr einfach. Zum anderen wird angeführt, dass es zu Problemen kommen kann,
wenn nach dem ?> Tag weitere Zeichen, regelmäßig sind es vergessene Leerzeichen, folgen. Diese Meinung kann
man gut vertreten, wenn man die Übersicht über die Leerzeichen nach dem eigenen Programm bereits verloren hat
und der Verzicht auf den schließenden Tag die einfachste Lösungsmöglichkeit ist.

==== Kommentare

Grundregel 40% Kommentare und 60 % Code.
Im Prinzip muß Deine Oma verstehen können, was "das" (der Code an dieser Stelle) macht.
Das "Warum" diese Codezeile existiert kommentieren, nicht das wie/was, das is der Code selbst.

Einzeilige Kommentare werden durch # eingeleitet (Perl-Style), nicht durch "//" oder "/* */".

.Einzeilige Kommentare
[source, php]
---------------------------------------------------------------------
Richtig:
# Kommentar

Falsch:
// Kommentar

Falsch:
/* Kommentar */
---------------------------------------------------------------------

Es ist erlaubt einzeilige Kommentare hinter dem zu kommentieren Quellcode einzusetzen.

.Kommentareinsatz nach PHP Anweisung
[source, php]
---------------------------------------------------------------------
# Richtig (Kann-Vorschrift):
$counter = '123'; # Der Kommentar erklärt was warum gezählt wird.
---------------------------------------------------------------------

.Mehrzeilige Kommentare
Mehrzeilige Kommentare werden im DocBlock-Style dargestellt.
Sie werden in der ersten Kommentarzeilen mit +++"/**"+++ eröffnet.
Die zweite Kommentarzeilen beginnt mit +++" *"+++ (Leerzeichen dann Sternchen).
Dies erfolgt, damit die Sterne +++"*"+++ untereinander stehen, gefolgt vom ersten Kommentar.
Es folgen beliebig viele weitere Kommentarzeilen dieser Art.
Die letzte Kommentarzeilen enthält den Kommentarabschluss +++" */"+++.

[source, php]
---------------------------------------------------------------------
Richtig:
/**
 * Ein Kommentar
 * über mehrere Zeilen.
 */

Falsch:
/*
Ein Kommentar
über mehrere Zeilen.
*/

Falsch:
// Ein Kommentar
// über mehrere Zeilen.
---------------------------------------------------------------------

.PHPDocumentor Kommentierungsstil

Immer den PHPDocumentor Kommentierungsstil einsetzen.
footnote:[http://manual.phpdoc.org/HTMLSmartyConverter/HandS/phpDocumentor/tutorial_phpDocumentor.howto.pkg.html#basics.starting]
Link zum PHPdoc-Tutorial.

.PHPDoc Schlüsselwörter (Tags)
a. Immer @license, @author und @param, @returns, @vars definieren. Zusätzlich bei Bedarf @see und @link.
   Bei der Definition von @param ist der Typ des Parameters anzugeben. Im Zweifel ist "mixed" als Typ zu verwenden.
   Keinesfalls @globals definieren. Da die Verwendung von globalen Variablen verboten ist, sind sie auch nicht zu dokumentieren.
   Keinesfalls @access definieren. Dieser Tag ist veraltet (PHP4) und kann durch einen PHPDOC-Parser automatisch bestimmt werden.
   Keinesfalls @since definieren. Um die Versionsgeschichte nachzuvollziehen, können die Logs des Quellcode-Repositories bemüht werden.
b. Optionale Schlüsselwörter verwenden:
   - @TODO [taskid] Topicname evtl. URL zum  Bugtracker
   - @BUG  [bugid]  Topicname
   - @example Angabe von Quellcode der die Verwendung erläutert.
c. Der Tag @license ist immer:
    [ * @license    GNU/GPL v2 or (at your option) any later version, see "/doc/LICENSE". ]
d. Ein PHPDoc-Block beginnt immer mit einem Satz. Dieser Satz endet mit einem Punkt.
   Alle PHPDoc Tags verzichten auf den abschließenden Punkt.

.Dateien

Der Dateikopf einer PHP-Datei beginnt immer mit dem DocBlock des Projekts.

[source, php]
---------------------------------------------------------------------
<?php
   /**
    * Clansuite - just an eSports CMS
    * Jens-André Koch © 2005 - onwards
    * http://www.clansuite.com/
    *
    * This file is part of "Clansuite - just an eSports CMS".
    *
    * LICENSE:
    *
    *    This program is free software; you can redistribute it and/or modify
    *    it under the terms of the GNU General Public License as published by
    *    the Free Software Foundation; either version 2 of the License, or
    *    (at your option) any later version.
    *
    *    This program is distributed in the hope that it will be useful,
    *    but WITHOUT ANY WARRANTY; without even the implied warranty of
    *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    *    GNU General Public License for more details.
    *
    *    You should have received a copy of the GNU General Public License
    *    along with this program; if not, write to the Free Software
    *    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
    *
    * @license    GNU/GPL v2 or (at your option) any later version, see "/doc/LICENSE".
    *
    * @author     Jens-André Koch <vain@clansuite.com>
    * @copyright  Jens-André Koch (2005 - onwards)
    *
    * @link       http://www.clansuite.com
    * @link       http://gna.org/projects/clansuite
    *
    * @version    SVN: $Id$
    */

// Security Handler
if (!defined('IN_CS')){ die('Clansuite not loaded. Direct Access forbidden.' );}
---------------------------------------------------------------------

.Klassen

Klassen und Interfaces beginnen immer mit einem DocBlock nachfolgender Art:

/**
 * Name der Klasse evtl. Kurzbeschreibung. Ein Satz.
 *
 * Ein längerer
 * auch mehrzeiliger
 * Beschreibungstext.
 *
 * @author      Vorname Nachname <email>
 *
 * @category    Clansuite
 * @package     Core
 * @subpackage  ModuleController
 */

Der @license Tag ist bei Klassen regelmäßig entbehrlich, da die Lizenzdefinition bereits im Projektheader erfolgt ist.
Möchte ein Klassenautor denoch davon abweichen, so hat er zuerst eine GNU/GPL v2+ kompatible Lizenz zu wählen und kann diese
anschließend mit dem @license Tag im DocBlock der Klasse angeben.

.Methoden

Methoden beginnen immer mit einem DocBlock nachfolgender Art.
Gleiches gilt auch für Funktionen (dann natürlich ohne die Sichtbarkeitsdefinition).

[source, php]
---------------------------------------------------------------------
/**
 * eineMethode - ist eine PHPDoc-Block Demonstration.
 *
 * Eine längere Beschreibung ist optional.
 *
 * Wünschenswert ist die Angabe eines Beispiels.
 * @example
 *      $this->eineMethode('meinParameterXY');
 *
 * @param <type> $parameter Erläuterung zum Parameter
 * @return <type> Beschreibung
 */
public function eineMethode($parameter)
{
    /** Methode für das PHPDoc Beispiel **/

    return $parameter;
}
---------------------------------------------------------------------

==== Einrückungen

Quellcode ist einzurücken.
Im Quellcode sind keine Tabulatoren (Tabulatoren-Sprünge) zu verwenden.
Sie können bei den meisten Editoren und IDE's einstellen, dass der Tabulator (Tab-Taste) einer bestimmten Anzahl von Leerzeichen entspricht.
Diese Einstellung findet sich unter "Tabulatorgröße in Leerzeichen einstellen" oder "Tabulator zu Leerzeichen" oder "Tab Policy".
Verwende in PHP Dateien 4 Leerzeichen, in CSS und JS und YML jeweils 2 Leerzeichen.

==== Weißraum und Leerzeichen

.Weißraum am Zeilenende entfernen.
Der Weißraum an Zeilenenden ist zu entfernen.

.Leerzeichen in und nach Anweisungen
Um die Lesbarkeit zu erhöhen, sind innerhalb und nach Anweisungen Leerzeichen zu verwenden.

[source, php]
---------------------------------------------------------------------
# richtig
if ( $bedingung === true )
{
    echo 'bedingung ist wahr!';
}

for($i = 0; $i < count($result); $i++)

# falsch
if($bedingung===true){echo'bedingung ist wahr!';}
for($i=0;$i<count($result);$i++)
---------------------------------------------------------------------

==== Boolean-Ausdrücke

Boolean-Ausdrücke immer klein schreiben (true, false, null) und nicht groß (nicht TRUE, FALSE) oder mit großem
Anfangsbuchstaben (nicht True, False). Keine Zahlenwerte für Booleans verwenden (nicht 0 / 1).
Eine Ausnahme  gilt im Bereich der Konfigurationsdateien. Hier sind Zahlenwerte für Booleans zulässig.
Boolean-Kontrolle mit "===" durchführen, anstelle von "==".

Verwenden Sie is_null() um zu prüfen, ob eine Variable vom Typ "null" ist.

.Verwendung von is_null
[source, php]
---------------------------------------------------------------------
# Richtig:
if ( is_null($var) )
{
    ...
}

# Falsch:
if ( $var == null)
{
    ...
}
---------------------------------------------------------------------

==== Klammern

.Klammern auf einer Zeile
Klammern sind auf einer Zeile darzustellen. Diese Regel gilt solange die maximale Zeilenlänge erreicht ist.

Zu einer Überschreitung der maximalen Zeilenläge kommt es oftmals bei komplexen Bedingungen
und mehrdimensionalen Arrays. Hier gelten die folgenden Klammer-Regeln.

.If-Anweisung mit mehreren Bedingungen
[source, php]
---------------------------------------------------------------------
<?php
    if  (
               ($bedingung1 != 1 and $bedingung2 == 2)
            or ($bedingung3 != 3 or $bedingung4 == 4)
        )
    {
        Anweisung
    }
?>
---------------------------------------------------------------------

.Mehrdimensionale Arrays
[source, php]
---------------------------------------------------------------------
<?php
    $array = array (
                     'element1' => 'wert1',
                     'element2' => 'wert2',
                     'element3' => 'wert3'
                   );
?>
---------------------------------------------------------------------

==== Geschweifte Klammern

Die geschweiften Klammern { und } befinden sich jeweils auf einer neuen Zeile. Die öffnende geschweifte
Klammer ist unterhalb des ersten Zeichens des PHP-Commands zu platzieren. Die schließende auf gleicher
Einrückungshöhe. Das ist der sogenannte Eric Allman-Stil (Autor von sendmail) und das Gegenteil vom Unix-
Style!

Die Zeilen mit geschweiften Klammern sind als Quasi-Leerzeilen zu verstehen und sehr wichtig, denn sie erhöhen
die Lesbarkeit der Programmstrukturen. Man kann sie auch als Absatz eines Textes verstehen.
Daher gilt, jeder Weißraum der durch eine geschweifte Klammer geschaffen wird, ist positiv zu bewerten.
Der Unix-Style ist in seiner Form eher auf komprimierte Kurzschreibweise ausgerichtet.
Als Entwickler muß man Quellcode nicht ausdrucken und inzwischen (2010!) sind 20+ Zoll Monitore verbreitet.

Das Weglassen von geschweiften Klammern ist verboten.
Ein häufig anzutreffendes Beispiel ist das Weglassen von Klammern bei einzeiligen if-Anweisungen.

.Weglassen von geschweiften Klammern bei einzeiligen if-Anweisungen
[source, php]
---------------------------------------------------------------------
# falsch (syntaktisch natürlich korrekt und lauffähig)
if($bedingung) echo 'Bedingung ist wahr!';

# richtig
if ($bedingung === true)
{
    echo 'Bedingung ist wahr!';
}
---------------------------------------------------------------------

=== Richtlinien für die Programmierung

Bevor etwas programmiert wird, sollte erstmal ein logischer Vorentwurf erfolgen. Dazu kann man eine Skizze auf
einem Blatt anfertigen oder ein Grafik- oder Schreibprogramm verwenden. Insbesondere gibt es CASE-Tools und
UML-, sowie ER-Werkzeuge, um Strukturen und Beziehungen besser zu modellieren. Dieses Vorgehen entspricht der
Vorentwicklungsphase innerhalb des Drei-Phasen-Prinzips der Softwareentwicklung. Man unterteilt dabei die zu
verrichtenden Tätigkeiten in die Phasen Vorentwicklung, Entwicklung, und Nachentwicklung.
Siehe dazu auch den Abschnitt zum Entwicklungsprozess im Kapitel 2 Projektorganisation.

Es ist stets die Gesamtstruktur und ein bestehender Ablaufplan beachten.
Ein neues Teil fügt sich immer in das Ganze.
Zerlegen der größeren Aufgabe in kleinere Teile (Teile-Herrsche & Salami-Taktik).

==== Struktur

Am Anfang erfolgt immer die Initialisierung von Variablen.
So werden Notices vermieden und der schwachen Typisierung von PHP entgegengewirkt.

Der Anfang einer Applikation ist der richtige Ort um Konstanten zu definieren.

Danach kann mit der Deklaration von Funktionen oder Klassen mit Methoden begonnen werden.

Innerhalb von Klassen sind normale Methoden vor magischen Methoden zu deklarieren.
Eine Ausnahme bildet der Konstruktor einer Klasse. Er ist die einzige magische Methode, die an den Anfang der Klasse gehört.
Eine __toString() Methode kommt regelmäßig an das Ende einer Klasse.

==== Konvention geht über Konfiguration

Im Ergebnis soll ein konfigurierbarer Teil der Software lauffähig sein, ohne eine Konfiguration vornehmen zu müssen.
Nach Möglichkeit sind für alle Konfigurationseinstellungen sinnvolle Standardwerte zu setzen.
Nach Möglichkeit ist also mit Fallbacks auf Konfigurationsstandardwerte zu arbeiten.

==== Klassen

.Lose Kopplung
Abhängigkeiten zwischen den Klassen vermeiden. Lose Kopplung der Klassen bevorzugen.
Jede Klasse als ein funktional eigenständiges Gebilde betrachten.

.Klassennamen und Namespaces
Weil PHP erst ab Version 5.3.0 die Verwendung von Namespaces unterstützt, ist allen Clansuite Klassen
der Prefix "Clansuite_" vorangestellt. Namensräume ermöglichen eine neue Art der Kategorienbildung
und damit der Ordnung von Klassen. Auf diese Art lassen sich benutzerdefinierte Klassen besser
von systemeigenen Klassen unterscheiden und es treten keine Kollisionen auf.

Wir werden zu gegebenen Zeitpunkt Namespaces einsetzen, um die langen Klassennamen zu kürzen.

.Interfaces (Schnittstellen)

Die Namen für Interfaces entsprechen denen Klassennamen. Sie enden jedoch immer mit "_Interface".
[source, php]
---------------------------------------------------------------------
class Clansuite_Klassenname implements Clansuite_Klassenname_Interface
{
   # ...
}
---------------------------------------------------------------------

==== Umgang mit SQL

SQL gehört aufgrund der MVC-Schichtentrennugn immer in den Bereich des Models.
Die SQL Abfragen sind in Methoden zu fassen.
Diese SQL-Methoden liefern ein oder ein zusammengefasstes Array (compact) zurück.

==== Funktionen, Methoden

.static bevorzugen
Nach Möglichkeit statische Funktionen ("static functions") einsetzen.
Benennung "public static function", nicht "static public function" (Sichtbarkeit zuerst angeben).

[source, php]
---------------------------------------------------------------------
public    static method1()  { ... }
private   static method2()  { ... }
protected static method3()  { ... }
---------------------------------------------------------------------

.Auspacken von Schachteln
Das Ineinanderverschachteln von Funktionen ist unübersichtlich und daher nicht wünschenswert.
Ab einer Verschachtelungstiefe von 3 Funktionen mit Parametern, sind die Verschachtelungen aufzulösen.

.Verkettungen
Im Bereich der Konkatenation ist sprintf() einzusetzen.
Als eine Orientierung, ab wann auf sprintf() zurückzugreifen ist, um einen String zu erzeugen, gilt ein Wert von 3 Verkettungen.

==== Der goto Operator

Der goto-Operator ist verboten. Der goto-Operator wurde in PHP 5.3 als neue Kontrollstruktur eingeführt. Mit
Goto lassen sich bedingte Sprünge oder Schleifen ausdrücken. Es verstärkt PHPs Ausdrucksmöglichkeiten im
Bereich von kleinen Scripten. Für mehr taugt dieses Sprachmittel meiner Meinung nach nicht, da die
Nachvollziehbarkeit eines längeren Programmflusses durch die Sprünge erheblich leidet.

==== Grundsätzliches zu Variablen und Konstanten in PHP

.Namenskonventionen für die Bezeichnung von Konstanten und Variablen
Konstanten und Variablen sind eindeutig zu bezeichnen. Ein Bezeichner ist immer so zu wählen, das in ihm kurz
und prägnant zum Ausdruck kommt, welchen Inhalt oder welche Funktion sich dahinter verbirgt. Es sollen
logische und unabgekürzte Nnamen bei gleichbleibender Verwendung sein. Zur Bezeichnung bzw. Identifikation
sind Literale (Buchstaben und Buchstabenketten) und Numerale (Zahlen und Zahlenketten) zu verwenden. Zulässig
ist dabei eine Kombination von Literalen und Numeralen, sowie der Einsatz des Unterstrichs als Trennzeichen.
Eine Bezeichnung unter ausschließlicher Verwendung von Numeralen ist untersagt (nein, auch kein l33tspeak).

Variablennamen sollen möglichst prägnant sein, denn man soll sofort sehen können was eine Variable macht. Aber
vor allem soll man einer Variable ansehen können, wenn sie falsch verwendet wird. Die falsche
Variablenverwendung soll im Quelltext deutlich als falsch erkennbar sein. Außerdem soll eine Variable so nah
wie möglich an ihrem Verwendungsort definiert werden.
Das erleichtert die Suche im Kontext durch Beschränkung auf einen kleinen Umkreis.

.Beispiele
[source, php]
---------------------------------------------------------------------
/**
 * Der Bezeichner für die Variable besteht aus Literalen und Unterstrichen.
 * Man kann nachvollziehen, was sich hinter dem Namen verbirgt.
 * Er ist grundsätzlich zulässig, allerdings nicht kurz und prägnant gewählt.
 */
$das_haus_in_dem_ich_wohne_hat_die_hausnummer = '20';

# Ok.
$haunummer = '20';

# Auch das  Voranstellen des Variablentyps ist zulässig.
$intHausnummer = '20';
$boolUserIsAuthed = true;

# Unzulässig, da nur Numerale eingesetzt werden.
$558 = array('');

# Zulässige Kombination von Literalen und Numeralen und Unterstrich.
$haus_1 = array( 'hausnummer' => '20', 'straße' => 'sonnenallee', 'stadt' => 'köln');
---------------------------------------------------------------------


.Datentypen
PHP ist eine schwach typisierte Sprache. Einer Variablen kann man daher verschiedene Datentypen zuweisen.
Einige Beispiele:
$var = 0;         # int
$var = false;     # bool
$var = 'string';  # string
Der Datentyp muss daher vom Programmierer unbedingt im Auge behalten werden.
Aber auch der Aufgabengehalt einer Variable ist wichtig. Dafür ist eine Kontextbeobachtung notwendig.
Es gibt also zwei wichtige Dinge bei einer Variablen: ihr Datentyp und ihre Aufgabe.

Ein typisches Beispiel wäre eine Flag-Variable. Jeder Variable kann man nur Datentyp und Inhalt entnehmen. Die
Eigenschaft eine Flag-Variable zu sein, kann man der Variable selbst nicht entnehmen, sie ergibt sich nur im
Programmkontext. Der Kontext lässt sich durch einen Kommentar hinter der Initialisierung der Variable angeben.
Aber damit ist diese Information nicht an jeder Stelle verfügbar, bei der diese Variable verwendet wird.
(Ausnahme: Gute Entwicklungsumgebungen (IDE's) und Editoren können einmal definierte Variablen und deren
Kommentare bei Wiederverwendung anzeigen. Beispielsweise implementiert NetBeans diese Kontextfunktion für
Klassen, Methoden und Variablen. Sie ist mittels der Tastenkombination "Steuerung und Leertaste" zu
erreichen.)

Zu einer Zeit als helfende IDE's noch nicht entwickelt waren führte man eine spezielle Methode ein, um den
Kontext anzugeben. Um diese Variablen-Kontextbeobachtung zu erleichtern, wurde eine Namenskonvention für
Variablen entwickelt, bei der die Art der Variablen in ihrem spezifischen Kontext zu einem Bestandteil des
Variablennames wurde. Man nennt diese Namenskonvention "ungarische Notation". Die Konvention geht auf Charles
Simonyi, einen ungarischen Programmierer und späteren Chefentwickler bei Mircosoft zurück.
Die originale "ungarische Notation", auch "Apps Hungarian" genannt, gibt den Kontext einer Variablen an, nicht den Datentyp.

.Speicherfreigabe
Nach Verwendung einer Variablen sollte sie aus Gründen der Ressourcenschonung aus dem Speicher entfernt werden.
Ein unset() zu verwenden ist die saubere und manuelle Art der Speicherbereinigung.
Bei PHP-Applikationen ist dieser Punkt nicht ganz so wichtig.

.Unterstrich am Anfang des Variablennamens
Außer Kraft: Klasseninterne Variablen haben mit einem Unterstrich "_" zu beginnen.
Der Unterstich ist meiner Meinung nach sinnlos, da der Sichtbarkeitsbereich der Variablen durch Doc-Werkzeuge
automatisch erkannt werden kann. Nachfolgende Regelungen sind ohne den beginnenden Unterstich zu lesen.

.CamelCase
Bei Variablennamen ist grundsätzlich CamelCase zu verwenden.
Jedoch mit der Ausnahme, dass das erste Variablenwort dabei klein zu schreiben ist.
Richtig: $this->_klassenVariable;

Bei der Zuweisung eines Strings an eine Variable sind stets einfache Anführungszeichen zu verwenden.

.Doppelte Anführungszeichen sind verboten
[source, php]
---------------------------------------------------------------------
#Richtig:
$string = 'text';

#Falsch:
$string = "text";
---------------------------------------------------------------------

Das Verbot doppelter Anführungszeichen zieht das Verbot der Variablenausgabe innerhalb von Strings nach sich.

.Variablenausgabe innerhalb von Strings
[source, php]
---------------------------------------------------------------------
Falsch:
$varA = 'Hello';
$string = "$var World!";
---------------------------------------------------------------------

Verwenden Sie stattdessen Konkatenation. Setzen Sie also Zeichenketten aus Teilen zusammen.

.Konkatenation
[source, php]
---------------------------------------------------------------------
Richtig:
$string = $var . ' World!';
---------------------------------------------------------------------

Sind mehrere Ersetzungen in einem String erforderlich, so greifen Sie auf sprintf() zurück.

.Bei mehreren String-Ersetzungen sprintf() verwenden
[source, php]
---------------------------------------------------------------------
$varB = 'This is';
$string = sprintf('%s %s World!', $varA, $varB);
---------------------------------------------------------------------

.Leerzeile vor return Anweisung
Jeder return Anweisung ist eine Leerzeile voranzustellen.
Dies hebt einen Rückgabewert nochmals hervor.
[source, php]
---------------------------------------------------------------------
# falsch:
$variable = 'Text to return'; return $variable;

# richtig:
$variable = 'Text to return';

return $variable;
---------------------------------------------------------------------

==== Fehlerbehandlung

.Fehlerberichterstattungslevel E_STRICT
Damit jedes noch so kleine Warning sofort ins Auge springt.

.Fehlerunterdrückung mittels Silencing-Operator (@) ist verboten
Keine Fehlerunterdrückung mittels @-Operator bei Funktionsaufrufen verwenden!
Erstens ist es eine teure Operation, denn die Fehlerbehandlung wird zunächst abgestellt und nach Ausführung des
Kommandos wieder eingeschaltet. Zweitens entstehen dadurch nur unnötige Schwierigkeiten beim Debugging, die man vermeiden kann.
Wenn es nicht anders geht und Fehlerunterdrückung zum Einsatz kommt, ist immer detailliert zu Kommentieren.

==== Einsatz von PHP Kommandos

Für die Prüfung, ob eine Datei existiert, ist anstatt file_exists() immer is_file() zu bevorzugen.

Um eine Datei einzubinden bzw. zu laden ist immer die PHP Funktion require() anstatt require_once() zu verwenden.
Dabei ist immer der absolute Pfad zu verwenden und auf Klammern zu verzichten.

==== Keine Globals

Keine Globals verwenden! Verboten: "global", "$GLOBALS".

==== PHP und HTML (Templates) auseinander halten

Trennungsprinzip beachten: Kein HTML im PHP.
Kein ECHO in Modulfunktionen verwenden (MVC-Durchbrechung), denn die Ausgabe erfolgt regelmäßig automatisch.
Das Trennungsprinzip darf nur im Bereich Fehler- und Ausnahmebehandlung durchbrochen werden.

==== Ternärer Operator

Das Grundanliegen des ternären Operators ist, eine einfache if-else-Anweisung platzsparend auszudrücken.
Das Konstrukt ist zweifellos sehr platzsparend. Manche Entwickler sehen aufgrund der Verkürzung der
if-else-Schleife auch eine verbesserte Lesbarkeit. Andere sehen darin eher eine Verschlechterung, wobei
neben das Lesbarkeitsproblem ein Verständlichkeitsproblem tritt. Dies tritt beispielsweise bei Verwendung
von mehreren Bedingungen mit unterschiedlichen Boolean-Operatoren auf. Sowie im Fall einer Einbettung
des ternären Operators in eine andere Anweisung.

[source, php]
---------------------------------------------------------------------
# Beispielsweise:
echo 'Es ($i == 1 ? 'ist' : 'sind') '.$i.' Nutzer angemeldet.';
---------------------------------------------------------------------

Daher ist der Ternäre Operator verboten.

Statt des ternären Operators ist immer eine if-else-Anweisung zu verwenden.

==== Anführungszeichen

Einfache Anführungszeichen anstatt doppelte Anführungszeichen verwenden!

==== Datei- und Verzeichnisnamen

Für Dateien und Verzeichnisse sind nur alphanumerische Zeichen, sowie der Unterstrich (engl. underscore) "_" und
der Trennstrich "-" (engl. dash) erlaubt. Leerzeichen sind verboten.
Zusätzlich gilt für Datei- und Verzeichnisnamen die Kleinschreibung.

=== Clansuite CodeSniffer Standard

CodeSniffer ist ein PEAR Paket. Es überprüft den Quelltext auf die Verletzung vorher definierter
Programmierrichtlinien. Jeder Programmierer ist zwar gehalten, den Richtlinien zu folgen, aber im Eifer des
Gefechts werden starre Regeln manchmal über Bord geworfen, um zu schnellen Ergebnissen zu gelangen.
Unter dieser Verletzung der Richtlinien leidet jedoch die Qualität des Quellcodes.

Die in den vorherigen Abschnitten befindlichen Programmierrichtlinien wurden daher in einem CodeSniffer Regelsatz
zusammengefasst. Mit Hilfe dieses Regelsatzes ist es CodeSniffer möglich, den Quellcode automatisch auf Fehler zu prüfen
und diese anzuzeigen. Durch Verwendung von CodeSniffer lässt sich also die hohe Qualität des Clansuite Quellcodes sichern.

Der "Clansuite CodeSniffer Standard" befindet sich im SVN unter "/build-tools/CodeSniffer". CodeSniffer
liefert bereits einige Regelsätze bekannter Projekte wie Zend, Squiz und PEAR mit. Jeder Regelsatz besteht aus
einzelnen Regeln, den sogenannten Sniffs. So gibt es zum Beispiel einen Regelsatz "LineLengthSniff.php", der
die maximale Zeilenlänge einer PHP-Datei festlegt. Soweit die Konventionen anderer Projekte mit denen des
Clansuite Projekts übereinstimmen, wurde auf einige dieser "Standard Sniffs" zurückgegriffen, um den Clansuite
Standard zu realisieren. Wir definieren jedoch zahlreiche eigene "Sniffs", da die Clansuite
Programmierrichtlinien teilweise erheblich von denen anderer Projekte abweichen.

==== Installation des Clansuite CodeSniffer Standards

Die Installation des "Clansuite CodeSniffer Standards" kann auf zwei Wegen erfolgen.

Einmal ist der "Clansuite CodeSniffer Standard" als PEAR Paket erhältlich.
Er ergänzt also lediglich die bestehende PEAR CodeSniffer Installation um den Clansuite Regelsatz.

Falls man keinen Zugriff auf "pear" hat, kann man alternativ auch das Archiv herunterladen, auspacken und in das
PEAR Verzeichnis kopieren. Der richtige Ort innerhalb des PEAR Verzeichnisses ist: [PEAR]/PHP/CodeSniffer/Standards.

==== Verwendung von CodeSniffer

Wir setzen CodeSniffer auf zwei Arten ein:

.Ständiges Quellcode-Monitoring

Der Quelltext im "/trunk" wird ständig durch CodeSniffer auf Verletzungen der Richtlinien untersucht. Die
Überprüfung erfolgt mittels einer Phing Aufgabe ("codesniffer-report" und "codesniffer-report-w32"). Diese
CodeSniffer-Aufgabe wird regelmäßig aufgerufen. Der Aufruf erfolgt einerseits ausgelöst durch einen Cronjob
auf dem Clansuite-Entwicklungsserver, andererseits auch im Rahmen des kontinuierlichen Integrationsprozesses
durch Bitten (Trac). Alle Fehler werden in einem Fehlerbericht zusammengefasst und automatisch im
Entwicklerbereich der Webseite veröffentlicht. Jeder Entwickler kann so Verstöße erkennen und Fehler beheben.

.Quellcode-Kontrolle vor dem Commit

Damit fehlerhafter Quellcode aber gar nicht erst unter Versionskontrolle gestellt wird, kann und sollte man
ihn vor einem Commit überprüfen. Die Überprüfung kann auf zwei Arten geschehen.

Einmal durch manuelles Aufrufen des CodeSniffers: "phpcs --standard=Clansuite zu-prüfende-datei.php".
Dadurch wird die einzelne Datei gegen den Clansuite Standard geprüft.

HINT: Man kann die Angabe des "--standards" auch weglassen, wenn man in den CodeSniffer Einstellungen
      die Verwendung des "Clansuite Standards" als Grundeinstellung setzt.
      Der Befehl dafür ist "phpcs --config-set default_standard Clansuite".

Alternativ kann der Aufruf des CodeSniffers auch automatisch erfolgen, wenn man ihn in die Versionsverwaltung
einbindet. Diese Einbindung lässt sich sehr einfach mit einem Subversion "Pre-Commit-Hook" zum Aufruf von
"phpcs" umsetzen. Der "Pre-Commit-Hook", so ja auch schon sein Name, wird vor einem Commit ins Repository
automatisch ausgeführt. Sollten zu diesem Zeitpunkt Fehler im Quelltext enthalten sein, wird der Commit
abgebrochen. Man kann zum Code zurückkehren, die gemeldeten Fehler beheben und dann ein weiteres Mal versuchen
zu committen.
Werden keine Fehler gefunden erfolgt der Commit ins Quellcodearchiv.

http://pear.php.net/package/PHP_CodeSniffer

=== Standards für CMS und Frameworks

==== PHP-Standard für Frameworks

Derzeit wird in der Google Group "PHP-Standards" über eine Vereinheitlichung der Programmierrichtlinien
für PHP-Frameworks diskutiert. Es sind Vertreter der folgenden Systeme sind an der Diskussion beteiligt:
Cake, Seagull, Symfony, Prado, Zend Framework und Joomla, Mambo sowie Magento. Die Diskussion soll
dazu führen, dass Module und Komponenten zwischen den verschiedenen Systemen austauschbar und
wiederverwendbar werden. Ein aktueller Entwurf des zukünftigen Standards ist in der Google-Group abrufbar.

Google-Diskussionsgruppe
http://groups.google.com/group/php-standards?pli=1