////////////////////////////////////////////////////////////////////////////////

This file belongs to "Clansuite - just an eSports CMS" as part of the "Clansuite Documentation".
This file is written in ASCIIDOC format. It's dual-licensed under the GNU Free Documentation License,
Version 1.3 and the Creative Commons Attribution-Share-Alike 3.0 License (cc-by-sa).

You find a comprehensive AsciiDoc UserGuide here:
http://www.methods.co.nz/asciidoc/userguide.html

You find a Ascii Doc SheetCheat here:
http://powerman.name/doc/asciidoc-compact

For the Clansuite Documentation visit:
http://www.clansuite.com/documentation/

SVN: $Id$

////////////////////////////////////////////////////////////////////////////////

== Kapitel 17 - Die Clansuite Programmierrichtlinien

Dieses Kapitel stellt den Clansuite Coding Standard, also die jeweils aktuell geltenden Programmierrichtlinien 
von Clansuite dar. Es ist untergliedert in drei Abschnitte. Im ersten und zweiten Abschnitt werden zwei 
Richtlinienarten erläutert. Die Richtlinien für die förmliche Gestaltung des Quelltextes und die Regeln für 
die Programmierung. Der dritte Abschnitt beschäftigt sich mit der automatischen Kontrolle dieser Richtlinien 
mit dem Werkzeug CodeSniffer.

Regeln und Konventionen sind feste, starre Richtlinien für den Entwurf einer Applikation. Diese Regeln mögen
vielen Entwicklern als Gängellei erscheinen. Doch das ist bei Regeln der Normalfall. Sie wurden festgelegt, um
Fehler zu vermeiden und hervortreten zu lassen und um eine bestimmte Form und Qualität bei der Entwicklung zu
erzielen. Es sind absichtliche (künstliche) Einschränkungen der Software, die dem Entwickler einige
Entscheidungen abnehmen und den Entwicklungsprozess effizienter und konsistenter gestalten. Es sind kleine,
sich wiederholende Zeremonien.

Mache den Codingstyle nach, den Du im Clansuite Repository vorfindest. Erfinde den Style nicht neu und halte
Dich an die gegebenen Spielregeln. Um auf Fehler automatisch beim Committen ins SVN hingewiesen zu werden,
kannst Du einen SVN pre-commit-hook einsetzen. Beim Versuch eine Datei ins SVN zu committen, wird der
PHP CodeSniffer zunächst den Stil und die Richtigkeit der PHP-Syntax der Datei kontrollieren.
Im Fehlerfall bekommst Du eine ausführliche Meldung, was in einer Datei zu verändern ist,
damit sie regelkonform wird.

Für alle offenen Fragen und unbehandelten Themen gilt die analoge Anwendung der PEAR Standards.
* http://pear.php.net/manual/en/standards.php
* http://www.dagbladet.no/development/phpcodingstandard/

=== Richtlinien für die förmliche Gestaltung des Quelltextes

Wenn in diesem Kapitel von richtig und falsch gesprochen wird, dann ist damit nicht
die Funktionalität des Quellcodeabschnitts gemeint, sondern seine Form und Darstellung.

==== PHP Dateianfang und Dateiende

Jede PHP Datei beginnt mit <?php und endet mit ?>.

[source, php]
---------------------------------------------------------------------
<?php
    /**
     * Quelltext
     */
?>
---------------------------------------------------------------------

Viele PHP-Projekte definieren in Ihren Programmierrichtlinien den Verzicht auf das schließende ?> Tag.
Zum einen wird angeführt, dass man den ?> - Tag nicht wirklich braucht. Das ist wohl richtig, aber
schlampig arbeiten ist eben sehr einfach. Zum anderen wird angeführt, dass es zu Problemen kommen kann,
wenn nach dem ?> Tag weitere Zeichen, regelmäßig Leerzeichen folgen. Diese Meinung kann man gut vertreten,
wenn man die Übersicht über die Leerzeichen nach dem eigenen Programm bereits verloren hat und
der Verzicht auf den schließenden Tag die einfachste Lösungsmöglichkeit ist.

==== Kommentare

Grundregel 40% Kommentare und 60 % Code.
Im Prinzip muß Deine Oma verstehen können, was "das" (der Code an dieser Stelle) macht.
Das "Warum" diese Codezeile existiert kommentieren, nicht das wie/was, das is der Code selbst.

Einzeilige Kommentare werden durch # eingeleitet (Perl-Style), nicht durch "//" oder "/* */".

.Einzeilige Kommentare
[source, php]
---------------------------------------------------------------------
Richtig:
# Kommentar

Falsch:
// Kommentar

Falsch:
/* Kommentar */
---------------------------------------------------------------------

Es ist erlaubt einzeilige Kommentare hinter dem zu kommentieren Quellcode einzusetzen.

.Kommentareinsatz nach PHP Anweisung
[source, php]
---------------------------------------------------------------------
# Richtig (Kann-Vorschrift):
$counter = '123'; # Der Kommentar erklärt was warum gezählt wird.
---------------------------------------------------------------------

.Mehrzeilige Kommentare
Mehrzeilige Kommentare werden im DocBlock-Style dargestellt.
Sie werden in der ersten Kommentarzeilen mit "/**" eröffnet.
Die zweite Kommentarzeilen beginnt mit " *" (Leerzeichen dann Sternchen).
Dies erfolgt, damit die Sterne "*" untereinander stehen, gefolgt vom ersten Kommentar.
Es folgen beliebig viele weitere Kommentarzeilen dieser Art.
Die letzte Kommentarzeilen enthält den Kommentarabschluss " */".

[source, php]
---------------------------------------------------------------------
Richtig:
/**
 * Ein Kommentar
 * über mehrere Zeilen.
 */

Falsch:
/*
Ein Kommentar
über mehrere Zeilen.
*/

Falsch:
// Ein Kommentar
// über mehrere Zeilen.
---------------------------------------------------------------------

.PHPDocumentor Kommentierungsstil

Immer den PHPDocumentor Kommentierungsstil einsetzen.
footnote:[http://manual.phpdoc.org/HTMLSmartyConverter/HandS/phpDocumentor/tutorial_phpDocumentor.howto.pkg.html#basics.starting]
Link zum PHPdoc-Tutorial.

.PHPDoc Schlüsselwörter (Tags)
a. Immer @license, @author und @parms, @returns, @vars definieren. Zusätzlich bei Bedarf @see und @link.
   Keinesfalls @globals definieren. Da die Verwendung von globalen Variablen verboten ist, sind sie auch nicht zu dokumentieren.
   Keinesfalls @access definieren. Dieser Tag ist veraltet (PHP4) und kann durch einen PHPDOC-Parser automatisch bestimmt werden.
b. Optionale Schlüsselwörter verwenden:
   - @TODO [taskid] Topicname evtl. URL zum  Bugtracker
   - @BUG  [bugid]  Topicname
c. Der Tag @license ist immer:
    [ * @license    GNU/GPL v2 or (at your option) any later version, see "/doc/LICENSE". ]
d. Ein PHPDoc-Block beginnt immer mit einem Satz. Dieser Satz endet mit einem Punkt.
   Alle PHPDoc Tags verzichten auf den abschließenden Punkt.

[source, php]
---------------------------------------------------------------------
/**
 * A PHPDoc-Block Demonstration.
 *
 * @param xy A XY Parameter
 */
---------------------------------------------------------------------

==== Einrückungen

Quellcode ist einzurücken.
Im Quellcode sind keine Tabulatoren (Tabulatoren-Sprünge) zu verwenden.
Sie können bei den meisten Editoren und IDE's einstellen, dass der Tabulator (Tab-Taste) einer bestimmten Anzahl von Leerzeichen entspricht.
Diese Einstellung findet sich unter "Tabulatorgröße in Leerzeichen einstellen" oder "Tabulator zu Leerzeichen" oder "Tab Policy".
Verwende in PHP Dateien 4 Leerzeichen, in CSS und JS und YML jeweils 2 Leerzeichen.

==== Weißraum und Leerzeichen

.Weißraum am Zeilenende entfernen.

.Leerzeichen in und nach Anweisungen
Um die Lesbarkeit zu erhöhen sind innerhalb und nach Anweisungen Leerzeichen zu verwenden.

[source, php]
---------------------------------------------------------------------
# richtig
if ( $bedingung === true )
{
    echo 'bedingung ist wahr!';
}
for($i = 0; $i < count($result); $i++)

# falsch
if($bedingung===true){echo'bedingung ist wahr!';}
for($i=0;$i<count($result);$i++)
---------------------------------------------------------------------

==== Boolean-Ausdrücke

Boolean-Ausdrücke immer klein schreiben (true, false, null) und nicht groß (nicht TRUE oder True).
Keine Zahlenwerte für Booleans verwenden (nicht 0 / 1).
Boolean-Kontrolle mit "===" durchführen, anstelle von "==".

Verwenden Sie is_null() um zu prüfen, ob eine Variable vom Typ "null" ist.

.Verwendung von is_null
[source, php]
---------------------------------------------------------------------
# Richtig:
if ( is_null($var) ) { ...}

# Falsch:
if ( $var == null) { ... }
---------------------------------------------------------------------

==== Klammern

.Klammern auf einer Zeile
Klammern sind auf einer Zeile darzustellen.
Diese Regel gilt solange die maximale Zeilenlänge erreicht ist.

Zu einer Überschreitung der maximalen Zeilenläge kommt es oftmals bei komplexen Bedingungen
und mehrdimensionalen Arrays. Hier gelten die folgenden Klammer-Regeln.

.Mehrere Bedingungen
[source, php]
---------------------------------------------------------------------
<?php
    if  (
               ($bedingung1 != 1 and $bedingung2 == 2)
            or ($bedingung3 != 3 or $bedingung4 == 4)
        )
    {
        Anweisung
    }
?>
---------------------------------------------------------------------

.Mehrdimensionale Arrays
[source, php]
---------------------------------------------------------------------
<?php
    $array = array (
                     'element1' => 'wert1',
                     'element2' => 'wert2',
                     'element3' => 'wert3'
                   );
?>
---------------------------------------------------------------------

Das Weglassen von Klammern ist verboten.
Ein häufig anzutreffendes Beispiel ist das Weglassen von Klammern bei einzeiligen if-Anweisungen.

.Weglassen von Klammern bei einzeiligen if-Anweisungen
[source, php]
---------------------------------------------------------------------
# falsch (syntaktisch natürlich korrekt und lauffähig)
if($bedingung) echo 'Bedingung ist wahr!';

# richtig
if ($bedingung === true)
{
    echo 'Bedingung ist wahr!';
}
---------------------------------------------------------------------

==== If-Anweisung

.If-Anweisung mit mehreren Bedingungen
[source, php]
---------------------------------------------------------------------
if (
      conditional ops # diverse Bedingungen
   )
{
   Anweisung
}
---------------------------------------------------------------------

==== Geschweifte Klammern

Die geschweiften Klammern { und } befinden sich jeweils auf einer neuen Zeile. Die öffnende geschweifte
Klammer ist unterhalb des ersten Zeichens des PHP-Commands zu platzieren. Die schließende auf gleicher
Einrückungshöhe. Das ist der sogenannte Eric Allman-Stil (Autor von sendmail) und das Gegenteil vom Unix-
Style!

Die Zeilen mit geschweiften Klammern sind als Quasi-Leerzeilen zu verstehen und sehr wichtig, denn sie erhöhen
die Lesbarkeit der Programmstrukturen. Man kann sie auch als Absatz eines Textes verstehen.
Daher gilt, jeder Weißraum der durch eine geschweifte Klammer geschaffen wird, ist positiv zu bewerten.
Der Unix-Style ist in seiner Form eher auf komprimierte Kurzschreibweise ausgerichtet.
Als Entwickler muß man Quellcode nicht ausdrucken und inzwischen (2010!) sind 20+ Zoll Monitore verbreitet.

=== Richtlinien für die Programmierung

Bevor etwas programmiert wird, sollte erstmal ein logischer Vorentwurf erfolgen. Dazu kann man eine Skizze auf
einem Blatt anfertigen oder ein Grafik- oder Schreibprogramm verwenden. Insbesondere gibt es CASE-Tools und
UML-, sowie ER-Werkzeuge um Strukturen und Beziehungen besser zu modellieren. Dieses Vorgehen entspricht der
Vorentwicklungsphase innerhalb des Drei-Phasen-Prinzip der Softwareentwicklung. Man unterteilt dabei die zu
verrichtenden Tätigkeiten in die Phasen Vorentwicklung, Entwicklung, und Nachentwicklung.
Siehe dazu auch im Kapitel 2 Projektorganisation den Abschnitt zum Entwicklungsprozess.

Es ist stets die Gesamtstruktur und ein bestehender Ablaufplan beachten. Ein neues Teil fügt sich immer in das
Ganze. Zerlegen der größeren Aufgabe in kleinere Teile (Teile-Herrsche & Salami-Taktik).

==== Struktur

Am Anfang erfolgt immer die Initialisierung von Variablen. So werden Notices vermieden und der
schwachen Typisierung von PHP entgegengewirkt.

Der Anfang einer Applikation ist der richtige Ort um Konstanten zu definieren.

Danach kann mit der Deklaration von Funktionen oder Klassen mit Methoden begonnen werden.

Innerhalb von Klassen sind normale Methoden vor magischen Methoden zu deklarieren.
Eine Ausnahme bildet der Konstruktor einer Klasse. Er ist magische Methode ist, die an den Anfang der Klasse gehört.
Eine __toString() Methode kommt regelmäßig an das Ende einer Klasse.

==== Konvention geht über Konfiguration
Im Ergebnis soll ein konfigurierbarer Teil der Software lauffähig sein,
ohne eine Konfiguration vornehmen zu müssen. Nach Möglichkeit sind für alle Konfigurationseinstellungen
sinnvolle Standardwerte zu setzen. Nach Möglichkeit ist mit Fallbacks auf Konfigurationsstandardwerte zu arbeiten.

==== Klassen

.Lose Kopplung
Abhängigkeiten zwischen den Klassen vermeiden. Lose Kopplung der Klassen bevorzugen.
Jede Klasse als ein funktional eigenständiges Gebilde betrachten.

.Klassennamen und Namespaces
Weil PHP erst ab Version 5.3.0 die Verwendung von Namespaces unterstützt, ist allen Clansuite Klassen
der Prefix "Clansuite_" vorangestellt. Namensräume ermöglichen eine neue Art der Kategorienbildung
und damit der Ordnung von Klassen. Auf diese Art lassen sich benutzerdefinierte Klassen besser
von systemeigenen Klassen unterscheiden und es treten keine Kollisionen auf.
Wir werden zu gegebenen Zeitpunkt Namespaces einsetzen, um die langen Klassennamen zu kürzen.

==== Umgang mit SQL

SQL gehört aufgrund der MVC-Schichtentrennugn immer in den Bereich des Models.
Die SQL Abfragen sind in Methoden zu fassen.
Diese SQL-Methoden liefern ein oder ein zusammengefasstes Array zurück.

==== Funktionen, Methoden

.static bevorzugen
Nach Möglichkeit statische Funktionen ("static functions") einsetzen.
Benennung "public static function", nicht "static public function".

.Auspacken von Schachteln
Das ineinander-verschachteln von Funktionen sind unübersichtlich und daher nicht wünschenswert.
Ab einer Verschachtelungtiefe von 3 Funktionen mit Parametern, sind die Verschachtelung aufzulösen.

.Verkettungen
Im Bereich der Konkatenation ist sprintf() einzusetzen.
Als eine Orientierung, ab wann auf sprintf() zurückzugreifen ist, um einen String zu erzeugen, gilt ein Wert von 3 Verkettungen.

==== Der goto Operator

Der goto-Operator ist verboten. Der goto-Operator wurde in PHP 5.3 als neue Kontrollstruktur eingeführt. Mit
Goto lassen sich bedingte Sprünge oder Schleifen ausdrücken. Es verstärkt PHPs Ausdrucksmöglichkeiten im
Bereich von kleinen Scripten. Für mehr taugt dieses Sprachmittel meiner Meinung nach nicht, da die
Nachvollziehbarkeit eines längeren Programmflusses durch die Sprünge leidet.

==== Grundsätzliches zu Variablen und Konstanten in PHP

.Namenskonventionen für die Bezeichnung von Konstanten und Variablen
Konstanten und Variablen sind eindeutig zu bezeichnen. Ein Bezeichner ist immer so zu wählen, das in ihm kurz 
und prägnant zum Ausdruck kommt, welchen Inhalt oder welche Funktion sich dahinter verbirgt. Es sollen 
logische und unabgekürzte Nnamen bei gleichbleibender Verwendung sein. Zur Bezeichnung bzw. Identifikation 
sind Literale (Buchstaben und Buchstabenketten) und Numerale (Zahlen und Zahlenketten) zu verwenden. Zulässig 
ist dabei eine Kombination von Literalen und Numeralen, sowie der Einsatz des Unterstrichs als Trennzeichen. 
Eine Bezeichnung unter ausschließlicher Verwendung von Numeralen ist untersagt (nein, auch kein l33tspeak).

Variablennamen sollen möglichst prägnant sein, denn man soll sofort sehen können was eine Variable macht. Aber 
vor allem soll man einer Variable ansehen können, wenn sie falsch verwendet wird. Die falsche 
Variablenverwendung soll im Quelltext deutlich als falsch erkennbar sein. Außerdem soll eine Variable so nah 
wie möglich an ihrem Verwendungsort definiert werden.
Das erleichtert die Suche im Kontext durch Beschränkung auf einen kleinen Umkreis.

.Beispiele
[source, php]
---------------------------------------------------------------------
/**
 * Der Bezeichner für die Variable besteht aus Literalen und Unterstrichen.
 * Man kann nachvollziehen, was sich hinter dem Namen verbirgt.
 * Er ist grundsätzlich zulässig, allerdings nicht kurz und prägnant gewählt.
 */
$das_haus_in_dem_ich_wohne_hat_die_hausnummer = '20';

# Ok.
$haunummer = '20';

# Auch das  Voranstellen des Variablentyps ist zulässig.
$intHausnummer = '20';
$boolUserIsAuthed = true;

# Unzulässig, da nur Numerale eingesetzt werden.
$558 = array('');

# Zulässige Kombination von Literalen und Numeralen und Unterstrich.
$haus_1 = array( 'hausnummer' => '20', 'straße' => 'sonnenallee', 'stadt' => 'köln');
---------------------------------------------------------------------


.Datentypen
PHP ist eine schwach typisierte Sprache. Einer Variablen kann man daher verschiedene Datentypen zuweisen.
Einige Beispiele:
$var = 0;         # int
$var = false;     # bool
$var = 'string';  # string
Der Datentyp muss daher vom Programmierer unbedingt im Auge behalten werden.
Aber auch der Aufgabengehalt einer Variable ist wichtig. Dafür ist eine Kontextbeobachtung notwendig.
Es gibt also zwei wichtige Dinge bei einer Variablen: ihr Datentyp und ihre Aufgabe.

Ein typisches Beispiel wäre eine Flag-Variable. Jeder Variable kann man nur Datentyp und Inhalt entnehmen. Die
Eigenschaft eine Flag-Variable zu sein, kann man der Variable selbst nicht entnehmen, sie ergibt sich nur im
Programmkontext. Der Kontext lässt sich durch einen Kommentar hinter der Initialisierung der Variable angeben.
Aber damit ist diese Information nicht an jeder Stelle verfügbar, bei der diese Variable verwendet wird.
(Ausnahme: Gute Entwicklungsumgebungen (IDE's) und Editoren können einmal definierte Variablen und deren
Kommentare bei Wiederverwendung anzeigen. Beispielsweise implementiert NetBeans diese Kontextfunktion für
Klassen, Methoden und Variablen. Sie ist mittels der Tastenkombination "Steuerung und Leertaste" zu
erreichen.)

Zu einer Zeit als helfende IDE's noch nicht entwickelt waren führte man eine spezielle Methode ein, um den
Kontext anzugeben. Um diese Variablen-Kontextbeobachtung zu erleichtern, wurde eine Namenskonvention für
Variablen entwickelt, bei der die Art der Variablen in ihrem spezifischen Kontext zu einem Bestandteil des
Variablennames wurde. Man nennt diese Namenskonvention "ungarische Notation". Die Konvention geht auf Charles
Simonyi, einen ungarischen Programmierer und späteren Chefentwickler bei Mircosoft zurück.
Die originale "ungarische Notation", auch "Apps Hungarian" genannt, gibt den Kontext einer Variablen an, nicht den Datentyp.

.Speicherfreigabe
Nach Verwendung einer Variablen sollte sie aus Gründen der Ressourcenschonung aus dem Speicher entfernt werden.
Ein unset() zu verwenden ist die saubere und manuelle Art der Speicherbereinigung.
Bei PHP-Applikationen ist dieser Punkt nicht ganz so wichtig.

.Unterstrich am Anfang des Variablennamens
Außer Kraft: Klasseninterne Variablen haben mit einem Unterstrich "_" zu beginnen.
Der Unterstich ist meiner Meinung nach sinnlos, da der Sichtbarkeitsbereich der Variablen durch Doc-Werkzeuge
automatisch erkannt werden kann. Nachfolgende Regelungen sind ohne den beginnenden Unterstich zu lesen.

.CamelCase
Bei Variablennamen ist grundsätzlich CamelCase zu verwenden.
Jedoch mit der Ausnahme, dass das erste Variablenwort dabei klein zu schreiben ist.
Richtig: $this->_klassenVariable;

Bei der Zuweisung eines Strings an eine Variable sind stets einfache Anführungszeichen zu verwenden.

.Doppelte Anführungszeichen sind verboten
[source, php]
---------------------------------------------------------------------
#Richtig:
$string = 'text';

#Falsch:
$string = "text";
---------------------------------------------------------------------

Das Verbot doppelter Anführungszeichen zieht das Verbot der Variablenausgabe innerhalb von Strings nach sich.

.Variablenausgabe innerhalb von Strings
[source, php]
---------------------------------------------------------------------
Falsch:
$varA = 'Hello';
$string = "$var World!";
---------------------------------------------------------------------

Verwenden Sie stattdessen Konkatenation. Setzen Sie also Zeichenketten aus Teilen zusammen.

.Konkatenation
[source, php]
---------------------------------------------------------------------
Richtig:
$string = $var . ' World!';
---------------------------------------------------------------------

Sind mehrere Ersetzungen in einem String erforderlich, so greifen Sie auf sprintf() zurück.

.Bei mehreren String-Ersetzungen sprintf() verwenden
[source, php]
---------------------------------------------------------------------
$varB = 'This is';
$string = sprintf('%s %s World!', $varA, $varB);
---------------------------------------------------------------------

.Leerzeile vor return Anweisung
Jeder return Anweisung ist eine Leerzeile voranzustellen.
Dies hebt einen Rückgabewert nochmals hervor.
[source, php]
---------------------------------------------------------------------
# falsch:
$variable = 'Text to return'; return $variable;

# richtig:
$variable = 'Text to return';

return $variable;
---------------------------------------------------------------------

==== Fehlerbehandlung

.Fehlerberichterstattungslevel E_STRICT
Damit jedes noch so kleine Warning sofort ins Auge springt.

.Fehlerunterdrückung mittels Silencing-Operator (@) ist verboten
Keine Fehlerunterdrückung mittels @-Operator bei Funktionsaufrufen verwenden!
Erstens ist es eine teure Operation, denn die Fehlerbehandlung wird zunächst abgestellt und nach Ausführung des
Kommandos wieder eingeschaltet. Zweitens entstehen dadurch nur unnötige Schwierigkeiten beim Debugging, die man vermeiden kann.
Wenn es nicht anders geht und Fehlerunterdrückung zum Einsatz kommt, ist immer detailliert zu Kommentieren.

==== Einsatz von PHP Kommandos

Anstatt file_exists(), is_file() bevorzugen.

==== Keine Globals

Keine Globals verwenden! Verboten: "global", "$GLOBALS".

==== PHP und HTML (Templates) auseinander halten

Trennungsprinzip beachten: Kein HTML im PHP.
Kein ECHO in Modulfunktionen verwenden (MVC-Durchbrechung), denn die Ausgabe erfolgt regelmäßig automatisch.

==== Ternärer Operator

Das Grundanliegen des ternären Operators ist, eine einfache if-else-Anweisung platzsparend auszudrücken.
Das Konstrukt ist zweifellos sehr platzsparend. Manche Entwickler sehen aufgrund der Verkürzung der
if-else-Schleife auch eine verbesserte Lesbarkeit. Andere sehen darin eher eine Verschlechterung, wobei
neben das Lesbarkeitsproblem ein Verständlichkeitsproblem tritt. Dies tritt beispielsweise bei Verwendung
von mehreren Bedingungen mit unterschiedlichen Boolean-Operatoren auf. Sowie im Fall einer Einbettung
des ternären Operators in eine andere Anweisung.

[source, php]
---------------------------------------------------------------------
# Beispielsweise:
echo 'Es ($i == 1 ? 'ist' : 'sind') '.$i.' Nutzer angemeldet.';
---------------------------------------------------------------------

Daher ist der Ternäre Operator verboten.

Statt des ternären Operators ist immer eine if-else-Anweisung zu verwenden.

==== Anführungszeichen

Einfache Anführungszeichen anstatt doppelte Anführungszeichen verwenden!

=== Clansuite CodeSniffer Standard

CodeSniffer ist ein PEAR Paket. Es überprüft den Quelltext auf die Verletzung vorher definierter
Programmierrichtlinien. Jeder Programmierer ist zwar gehalten, den Richtlinien zu folgen, aber im Eifer des
Gefechts werden starre Regeln manchmal

über Bord geworfen, um zu schnellen Ergebnissen zu gelangen. Unter dieser Verletzung der Richtlinien leidet
jedoch die Qualität des Quellcodes. Die im vorherigen Abschnitt befindlichen Programmierrichtlinien wurden
daher in einem CodeSniffer Regelsatz zusammengefasst. Mit Hilfe dieses Regelsatzes ist es CodeSniffer möglich,
den Quellcode auf Fehler zu prüfen und diese anzuzeigen.
Durch Verwendung von CodeSniffer lässt sich also die hohe Qualität des Clansuite Quellcodes sichern.

Der "Clansuite CodeSniffer Standard" befindet sich im SVN unter "/build-tools/CodeSniffer". CodeSniffer
liefert bereits einige Regelsätze bekannter Projekte wie Zend, Squiz und PEAR mit. Jeder Regelsatz besteht aus
einzelnen Regeln, den sogenannten Sniffs. So gibt es zum Beispiel einen Regelsatz "LineLengthSniff.php", der
die maximale Zeilenlänge einer PHP-Datei festlegt. Soweit die Konventionen anderer Projekte mit denen des
Clansuite Projekts übereinstimmen, wurde auf einige dieser "Standard Sniffs" zurückgegriffen, um den Clansuite
Standard zu realisieren. Wir definieren jedoch zahlreiche eigene "Sniffs", da die Clansuite
Programmierrichtlinien teilweise erheblich von denen anderer Projekte abweichen.

==== Installation des Clansuite CodeSniffer Standards

Die Installation des "Clansuite CodeSniffer Standards" kann auf zwei Wegen erfolgen.

Einmal ist der "Clansuite CodeSniffer Standard" als PEAR Paket erhältlich.
Er ergänzt also lediglich die bestehende PEAR CodeSniffer Installation um den Clansuite Regelsatz.

Falls man keinen Zugriff auf "pear" hat, kann man alternativ auch das Archiv herunterladen, auspacken und in das
PEAR Verzeichnis kopieren. Der richtige Ort innerhalb des PEAR Verzeichnisses ist: [PEAR]/PHP/CodeSniffer/Standards.

==== Verwendung von CodeSniffer

Wir setzen CodeSniffer auf zwei Arten ein:

.Ständiges Quellcode-Monitoring

Der Quelltext im "/trunk" wird ständig durch CodeSniffer auf Verletzungen der Richtlinien untersucht. Die
Überprüfung erfolgt mittels einer Phing Aufgabe. Diese CodeSniffer-Aufgabe wird regelmäßig aufgerufen. Der
Aufruf erfolgt einerseits ausgelöst durch einen Cronjob auf dem Clansuite-Entwicklungsserver, andererseits
auch im Rahmen des kontinuierlichen Integrationsprozesses durch Bitten (Trac). Alle Fehler werden in einem
Fehlerbericht zusammengefasst und automatisch im Entwicklerbereich der Webseite veröffentlicht.
Jeder Entwickler kann so Verstöße erkennen und Fehler beheben.

.Quellcode-Kontrolle vor dem Commit

Damit fehlerhafter Quellcode aber gar nicht erst unter Versionskontrolle gestellt wird, kann und sollte man ihn vor einem

Commit überprüfen.
Die Überprüfung kann auf zwei Arten geschehen.

Einmal durch manuelles Aufrufen des CodeSniffers: "phpcs --standard=Clansuite zu-prüfende-datei.php".
Dadurch wird die einzelne Datei gegen den Clansuite Standard geprüft.

HINT: Man kann die Angabe des "--standards" auch weglassen, wenn man in den CodeSniffer Einstellungen
      die Verwendung des "Clansuite Standards" als Grundeinstellung setzt.
      Der Befehl dafür ist "phpcs --config-set default_standard Clansuite".

Alternativ kann der Aufruf des CodeSniffers auch automatisch erfolgen, wenn man ihn in die Versionsverwaltung
einbindet. Diese Einbindung lässt sich sehr einfach mit einem Subversion "Pre-Commit-Hook" zum Aufruf von
"phpcs" umsetzen. Der "Pre-Commit-Hook", so ja auch schon sein Name, wird vor einem Commit ins Repository
automatisch ausgeführt. Sollten zu diesem Zeitpunkt Fehler im Quelltext enthalten sein, wird der Commit
abgebrochen. Man kann zum Code zurückkehren, die gemeldeten Fehler beheben und dann ein weiteres Mal versuchen
zu committen.
Werden keine Fehler gefunden erfolgt der Commit ins Quellcodearchiv.

http://pear.php.net/package/PHP_CodeSniffer

=== Standards für CMS und Frameworks

==== PHP-Standard für Frameworks

Derzeit wird in der Google Group "PHP-Standards" über eine Vereinheitlichung der Programmierrichtlinien 
für PHP-Frameworks diskutiert. Es sind Vertreter der folgenden Systeme sind an der Diskussion beteiligt:
Cake, Seagull, Symfony, Prado, Zend Framework und Joomla, Mambo sowie Magento. Die Diskussion soll 
dazu führen, dass Module und Komponenten zwischen den verschiedenen Systemen austauschbar und 
wiederverwendbar werden. Ein aktueller Entwurf des zukünftigen Standards ist in der Google-Group abrufbar.

Google-Diskussionsgruppe
http://groups.google.com/group/php-standards?pli=1